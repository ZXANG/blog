<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[来自kaggle文本分类银奖得主的参赛感悟]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2019%2F06%2F17%2Fkaggler%20NLP%E7%AC%AC%E4%BA%8C%E5%90%8D%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[翻译了一篇kaggler银奖得主的赛后经验博客，技巧与干货满满 Kaggle是一个学习的好地方。我从最近结束的关于Quora Insincere问题分类的比赛中学到了很多东西，其中我的排名为182/4037 。在这篇文章中，我将尝试提供我尝试过的事情的摘要。我还将尝试总结我错过的想法，但这些想法是其他获奖解决方案的一部分。 ​ 所以对于那些没有这次比赛经验的人，首先要简要介绍一下这次比赛。在本次比赛中，我们必须开发能够识别和标记虚假问题的模型。 挑战不仅仅是对性能的测试，而且还是对高效代码编写技能的测试。由于这是一个有限的外部数据选项kerner的竞争，竞争者仅限于使用竞赛组织者提供的词嵌入。这意味着我们不允许使用像BERT这样最先进的模型。我们的所有模型都应在2小时内运行完，因此我们也受到限制。所以说模型的堆叠融合是不可能的。虽然有些解决方案能够通过使代码超高效来实现这一点，稍后会详细介绍。 一些kaggle经验在进入我的最终解决方案之前，我想分享一些关于kaggle作为一个整体的学习内容： 1. 一直相信你的CV(Cross Validation)结果 在这次比赛中真正令很多人感到困惑的事情之一是，良好的CV分数并不一定能很好地转化为良好的LB分数。其主要原因是第一阶段的小测试数据集（仅65k行）（约占总测试数据的15％）。 讨论论坛上的一个共同主题是关注我们应该选择哪些提交作为最终提交的内容： 拥有最佳本地CV的人？要么 最好的LB？ 虽然说信任你的CV似乎很简单，但当你看到你的本地CV得分增加时，你的LB分数下降或保持不变时，常识就会折腾你。 幸运的是，我最终没有犯错，不相信我的CV得分。由于在Kaggle讨论板上有很多优秀的帖子，我选择了一个内核，公共LB得分为0.697，本地CV为0.701，截至最终提交时，公共LB的排名大约为1200。它的得分为0.702，在私人LB上排名第182位。 虽然这似乎是一个事后直截了当的选择，但是当你拥有公共LB得分&gt; = 0.70的公共内核时，这是一个艰难的决定。 Kaggle的CV策略是指使用train-validation split来复制 train-test split ，以便在你的本地CV上表现良好的模型在私人LB上也表现良好。 CV表示交叉验证。这是验证集中的分数。在竞赛中，LB通常仅计算20-30％的测试数据。每天你提交以获得LB的高分，即使你的CV并不好。LB.的模型其实过拟合了20-30％。对于任何竞赛，最终你需要选择最后的2个模型提交。策略总是选择一个最高的CV和一个最高的LB的 CV strategy取决于大数据的大小，我们决定是否实施K-fold。有了K-fold，我们需要大量时间来训练。对于一个小数据集，如https://www.kaggle.com/c/home-credit-default-risk，人们使用K-fold。对于非常大的数据集，比如https://www.kaggle.com/c/talkingdata-adtracking-fraud-detection，就不可能使用K-fold。 关于 CV strategy 可以查看这个讨论link 2.可以使用公开kernel的代码但检查错误​ This Benjamin Minixhofer的Pytorch内核非常棒。它成为我参加本次比赛的许多参赛作品的基础。但是这个kernel有一个错误。它没有以正确的方式实现spatial dropout。你可以在我的帖子这里或我的kernel上找到正确的spatial dropout实现。以正确的方式实施spatial dropout，使本地CV增加了约0.004。 尽管如此，我还是使用了这个kernel来学习pytorch，同样感谢他。 3.不要相信论坛上的一切 我将在这里讨论两件事： 随机种子调整（Seed tuning）：在比赛期间，每个人都试图在公共LB上获得最佳排名。这只是人性。很多讨论围绕着神经网络初始化的好种子和坏种子。虽然在第一次看起来似乎没什么问题，但是谈话进一步发展，人们开始在内核中调整种子作为超级参数。一些讨论甚至继续说这是一个有效的策略。而这导致公开排行榜上出现大量过拟合的现象。同样的提交只要通过改变种子就可使得分从0.699提升到0.704。这意味着只通过更改public kernel中的种子，你就能从400-500名前进到前50名。这是灾难性的。有些人这样做了。他们上了public LB，但在私有排行榜上惨败了。 讨论论坛上的CV得分披露：我们总是试图衡量我们对其他人的表现。在很多讨论中，人们提供了他们的CV分数和相应的public LB分数。由于不同的CV schemes，CV中没有folds，只报告Metric，过拟合, 或错误的交叉验证，所以得分分散并且没有可比性。但他们最终影响了很多初学者和新人。 4. 请在讨论论坛上保持活跃并定期检查公共内核​ 你可以通过参与讨论论坛和学习公共内核来学习很多东西。 SRK，Shujian的模型有很多关于嵌入的优秀公共内核。以及Theo Viel的预处理让每个人都有了一个开端。随着比赛的进行，讨论也在不断发展。有关加快代码，工作方法，F1阈值和其他激动人心的话题的讨论使我对新的想法和改进充满了兴趣。 即使在结束之后，在阅读关于解决方案概述的讨论时，我也学到了很多东西。我会说，查看获奖解决方案非常重要。 5. Share a lot分享是Kaggle的一切。人们在比赛期间以及比赛结束后分享了他们的代码和想法。我们可以共同进步。 6. Beware of trolls :)​ 离比赛还剩下两个星期，我们正在快乐地走向比赛的最后阶段。分数增长缓慢。顶级选手有些停滞不前。 然后Pavel和团队的公共LB得分为0.782。下一组的LB得分为0.713。如此巨大的差异。我非常确定数据中有一些漏洞，除了Pavel之外没有人抓到。我花了差不多半天时间再做EDA。 最后，事实证明他们所做的是scraping - 很好玩！ 他们还有一些非常棒的想法，包括额外的数据，这可能有效，但在本次比赛中没有尝试。 My Final Solution: 我主要关注元特征工程(meta-feature engineering)和增加嵌入覆盖率和质量。这意味着我在各种神经网络架构上的尝试并不多。以下是我在最终提交中包含的内容： 我注意到Glove嵌入在本地CV中表现不错，但在LB上却没有，而meta嵌入（Glove和paragram的意思）在LB上表现不错，但在CV上表现不佳。我采取了一种混合方法，所以我的一些模型仅使用Glove嵌入进行训练，有些则采用元嵌入。 嵌入中还包含自己提取的四个额外的特征(features)。因此，我的嵌入是一个304维向量。四个特征分别是: 标题，大写标志，Textblob字极性，textblob字主观性（title case flag, uppercase flag, Textblob word polarity, textblob word subjectivity） 使用spacy从整个训练集和测试数据中找出NER tokens ，并将tokens和实体(entities)保存在一个字典中。我用这个词典来创建额外的特征(features)，比如“GPE”，“PERSON”，“ORG”，“NORP”，“WORK_OF_ART”。增加了一些特征并与目标高度相关。 我使用的其他功能包括total_length，capitals，words_vs_unique以及一些工程特征，如sum_feat（咒骂的总和），question_start_with_why，question_start_with_how_or_what，question_start_with_do_or_are。可能没有增加太多价值，但仍然保留它们。 我的最终解决方案是四个模型以stacked方式进行融合 。我使用Logistic回归（具有正权重和0截距），并将权重作为最终kernel中的列表给出。 您可以找到我最终提交的内核此处。 其他解决方案中使用的提示和技巧：1. 增加嵌入覆盖范围：在第三名kaggler的解决方案中，wowfattie使用词干，词形还原，首字母大写，小写，大写，以及为其词典中的每个单词，使用拼写检查器对最近的单词进行词嵌入（ uses stemming, lemmatization, capitalize, lower, uppercase, as well as embedding of the nearest word using a spell checker to get embeddings for all words in his vocab）。这么棒的主意。 我最喜欢这个解决方案，因为它可以做我想做的事情并在一个非常好的地方完成。此外，代码非常干净。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from nltk.stem import PorterStemmerps = PorterStemmer()from nltk.stem.lancaster import LancasterStemmerlc = LancasterStemmer()from nltk.stem import SnowballStemmersb = SnowballStemmer("english")def load_glove(word_dict, lemma_dict): EMBEDDING_FILE = '../input/embeddings/glove.840B.300d/glove.840B.300d.txt' def get_coefs(word,*arr): return word, np.asarray(arr, dtype='float32') embeddings_index = dict(get_coefs(*o.split(" ")) for o in open(EMBEDDING_FILE)) embed_size = 300 nb_words = len(word_dict)+1 embedding_matrix = np.zeros((nb_words, embed_size), dtype=np.float32) unknown_vector = np.zeros((embed_size,), dtype=np.float32) - 1. print(unknown_vector[:5]) for key in tqdm(word_dict): word = key embedding_vector = embeddings_index.get(word) if embedding_vector is not None: embedding_matrix[word_dict[key]] = embedding_vector continue word = key.lower() embedding_vector = embeddings_index.get(word) if embedding_vector is not None: embedding_matrix[word_dict[key]] = embedding_vector continue word = key.upper() embedding_vector = embeddings_index.get(word) if embedding_vector is not None: embedding_matrix[word_dict[key]] = embedding_vector continue word = key.capitalize() embedding_vector = embeddings_index.get(word) if embedding_vector is not None: embedding_matrix[word_dict[key]] = embedding_vector continue word = ps.stem(key) embedding_vector = embeddings_index.get(word) if embedding_vector is not None: embedding_matrix[word_dict[key]] = embedding_vector continue word = lc.stem(key) embedding_vector = embeddings_index.get(word) if embedding_vector is not None: embedding_matrix[word_dict[key]] = embedding_vector continue word = sb.stem(key) embedding_vector = embeddings_index.get(word) if embedding_vector is not None: embedding_matrix[word_dict[key]] = embedding_vector continue word = lemma_dict[key] embedding_vector = embeddings_index.get(word) if embedding_vector is not None: embedding_matrix[word_dict[key]] = embedding_vector continue if len(key) &gt; 1: word = correction(key) embedding_vector = embeddings_index.get(word) if embedding_vector is not None: embedding_matrix[word_dict[key]] = embedding_vector continue embedding_matrix[word_dict[key]] = unknown_vector return embedding_matrix, nb_words 2. Checkpoint Ensembling:​ 免费获得很多模型。大多数获胜解决方案都使用了对一些模型版本的checkpoint 集成的策略。对于第三名解决方案，预测使用了第4个epoch后的预测和第5个epoch后的预测的加权平均值。我有这个想法，但忘了在我的基于kernel的 ensemble中实现并提交它。 3. Meta Embeddings:许多获胜的解决方案最终使用了加权元嵌入(weighted meta embeddings)，它们为Glove嵌入提供了更高的权重。一些解决方案也使用了连接嵌入(concatenated embeddings)。 4. Model Architecture:我看到人们做的一件令人惊讶的事情是在双向层之后使用 1Dconv层。例如，这是第一名比赛团队使用的网络架构。 5. Bucketing/Variable Sequence Length and increased hidden units:​ 我注意到的另一件事是与许多公共kernel相比，隐藏单元的数量增加了。由于时间限制，大多数公共kernel使用60个隐藏单元。我使用80个隐藏单元，但代价是少训练一个网络。由于序列长度可变或者bucketing的思想，许多高分kernel能够使用更多数量的隐藏单元。从第1名kernel开始讨论： 我们不会根据整个数据将序列填充到相同的长度，而只是在批处理级别上。这意味着我们在数据生成器级别为每个批次分别进行填充和截断，这样批量中句子的长度可以在大小上变化。 另外，我们通过不基于批次中最长序列的长度截短，但基于序列内95％百分比的长度进一步改进了这一点。这大大改善了运行时间，并且在单个模型级别上保持了非常强大的准确性，并通过更多模型平均的方法来改进它。 We do not pad sequences to the same length based on the whole data, but just on a batch level. That means we conduct padding and truncation on the data generator level for each batch separately, so that length of the sentences in a batch can vary in size. Additionally, we further improved this by not truncating based on the length of the longest sequence in the batch but based on the 95% percentile of lengths within the sequence. This improved runtime heavily and kept accuracy quite robust on single model level, and improved it by being able to average more models. 也来自第7位讨论： Bucketing是从具有相似长度的实例(instances)组成小批量来减轻padding成本。这使得训练速度提高了3倍以上，因此我可以为each split of 5-fold运行9个epochs。 Bucketing is to make a minibatch from instances that have similar lengths to alleviate the cost of padding. This makes the training speed more than 3x faster, and thus I can run 9 epochs for each split of 5-fold. 因此，使用这种技术还允许一些参赛者在更短的时间跑更多 epochs，并同时尝试更多的模型。很简约！ 6. For those winners who didn’t use bucketing, Maxlen = 72 was too large:​ 我们大多数人都看到了question length的分布，并将完全覆盖最大question长度作为maxlen参数。我从来没有试过调整它，但它似乎可以调整。 其中一个技巧是使用范围从35到60的maxlen。这使得kernel运行速度更快。 7. Time taking models/complex architectures like Capsule were mostly not used:​ 大多数获胜解决方案都没有使用Capsule网络，因为他们需要很多时间来训练。 8. Backprop errors on embeddings weights in last few epochs:我看到的另一件事是在排名第18位kernel使用单一模型 12if epoch &gt;= 3: model.embedding.embeddings.weight.requires_grad = True Conclusion:​ 这是一场长达2个月比赛，在此期间我学到了很多关于Text和NLP的知识。我想在此强调的是我最终尝试了很多在达到最终解决方案之前无效的事情。有时候有点令人沮丧，但最后，我很高兴得到了最好的数据科学实践。还要感谢Kaggle大师Kazanova和他的一些朋友一起发布了“如何赢得数据科学竞赛”Coursera课程。我从这门课程中学到了很多东西。 参考 原文 What my first Silver Medal taught me about Text Classification and Kaggle in general?]]></content>
      <categories>
        <category>kaggle</category>
      </categories>
      <tags>
        <tag>kaggle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pytorch入门教程]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2019%2F06%2F10%2Fpytorch%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[与numpy对比，较少pytorch的基本操作，然后搭建一个简单堆叠式的人工神经网络 ## １.数据表示及运算 1.0 Numpy与pytorch比较 Numpy Pytorch 导入模块 import numpy as np import torch 创建数据 np.numpy() tensor = torch.Tensor(array) 查看数据维度 np.shape() tensor.shape 查看数据类型 type() tensor.type 产生随机数 np.random.rand(2,3)) np.ones((2,3)) 产生全1矩阵/张量 np.ones() torch.ones() １.１Numpy数组与torch.Tensor相互转换 torch.from_numpy(): from numpy to tensor numpy(): from tensor to numpy 123456789# random numpy arrayarray = np.random.rand(2,2)# from numpy to tensorfrom_numpy_to_tensor = torch.from_numpy(array)# from tensor to numpytensor = from_numpy_to_tensorfrom_tensor_to_numpy = tensor.numpy() 注意Torch的Tensor和numpy的array会共享他们的存储空间，修改一个会导致另外的一个也被修改。 1.3 基础数学运算a和b都是tensor 运算 表达式/函数 Resize view() 加法 torch.add(a,b) = a + b 减法 a.sub(b) = a - b 元素对应相乘 torch.mul(a,b) = a * b 元素对应相除 torch.div(a,b) = a / b 均值 a.mean() 标准差（std） a.std() 1.4 Variables 变量和张量之间的差异是变量可以累积梯度 我们也可以用变量进行数学运算 为了进行反向传播，我们需要变量 12345# import variable from pytorch libraryfrom torch.autograd import Variable# define variablevar = Variable(torch.ones(3), requires_grad = True) 假设我们有等式y = x^2，现在要计算在点y=10处的梯度，pytorch实现如下： 123456789array = [2,4]tensor = torch.Tensor(array)x = Variable(tensor, requires_grad = True)y = x**2o = (1/2)*sum(y) #理解为一个点# backwardo.backward() # calculates gradients 1.5 使用gpu运算当我们使用.cuda()的时候，就可以把tensor移动到GPU上去 1234if torch.cuda.is_available(): x = x.cuda() y = y.cuda() x + y 2.数据来源通常来讲，当你处理图像，声音，文本，视频时需要使用python中其他独立的包来将他们转换为numpy中的数组，之后再转换为torch.Tensor 图像的话，可以用Pillow, OpenCV 声音处理可以用scipy和librosa 文本的处理使用原生Python或者Cython以及NLTK和SpaCy都可以 特别的对于图像，我们有torchvision这个包可用,其中包含了一些现成的数据集如：Imagenet, CIFAR10, MNIST等等。同时还有一些转换图像用的工具。 1234567891011121314151617181920212223242526272829303132import torchimport torch.nn as nn ## 搭建神经网络import torchvision.transforms as transforms ## 下载数据from torch.autograd import Variable ## 更新梯度import pandas as pdfrom sklearn.model_selection import train_test_split########## 准备数据，基本的numpy操作 ###############train = pd.read_csv(r&quot;../input/train.csv&quot;,dtype = np.float32)# 将数据拆分为特征(pixels) 和标签(numbers from 0 to 9)targets_numpy = train.label.valuesfeatures_numpy = train.loc[:,train.columns != &quot;label&quot;].values/255 # normalization#划分训练集与验证集：80%：20% features_train, features_test, targets_train, targets_test = train_test_split(features_numpy,targets_numpy,test_size = 0.2,random_state = 42) ########### 将numpy转为tensor,从而创建训练集和测试集 #########featuresTrain = torch.from_numpy(features_train)targetsTrain = torch.from_numpy(targets_train).type(torch.LongTensor) # 数据类型为longfeaturesTest = torch.from_numpy(features_test)targetsTest = torch.from_numpy(targets_test).type(torch.LongTensor) #数据类型为long# class torch.utils.data.TensorDataset:封装成tensor的数据集，每一个样本都通过索引张量来获得train = torch.utils.data.TensorDataset(featuresTrain,targetsTrain)test = torch.utils.data.TensorDataset(featuresTest,targetsTest)# class torch.utils.data.DataLoader 数据加载器。组合了一个数据集和采样器，并提供关于数据的迭代器train_loader = torch.utils.data.DataLoader(train, batch_size = batch_size, shuffle = False)test_loader = torch.utils.data.DataLoader(test, batch_size = batch_size, shuffle = False) 3.构建神经网络先看一个简单的例子： ### ３.１ ANN网络 1234567891011121314151617181920212223242526272829303132333435363738394041424344# Create 人工神经网络(ANN) Modelclass ANNModel(nn.Module): def __init__(self, input_dim, hidden_dim, output_dim): super(ANNModel, self).__init__() ## 继承nn.Module类 self.fc1 = nn.Linear(input_dim, hidden_dim) # Linear function 1: 784 --&gt; 100 self.relu1 = nn.ReLU() # Non-linearity 1 self.fc2 = nn.Linear(hidden_dim, hidden_dim) # Linear function 2: 100 --&gt; 100 self.tanh2 = nn.Tanh() # Non-linearity 2 # Linear function 3: 100 --&gt; 100 self.fc3 = nn.Linear(hidden_dim, hidden_dim) # Linear function 3: 100 --&gt; 100 self.elu3 = nn.ELU() # Non-linearity 3 self.fc4 = nn.Linear(hidden_dim, output_dim) # Linear function 4 (readout): 100 --&gt; 10 def forward(self, x): out = self.fc1(x) # Linear function 1 out = self.relu1(out) # Non-linearity 1 out = self.fc2(out) # Linear function 2 out = self.tanh2(out) # Non-linearity 2 out = self.fc3(out) # Linear function 2 out = self.elu3(out) # Non-linearity 2 out = self.fc4(out) # Linear function 4 (readout) return outprint(ANNModel) # 打印网络结构# 模型中可学习的参数会由ANNModel.parameters()返回params = list(ANNModel.parameters())print (len(params))print (params[0].size()) # 实例化人工神经网络input_dim = 28*28hidden_dim = 150 output_dim = 10# 创建ANN模型model = ANNModel(input_dim, hidden_dim, output_dim)# Cross Entropy Loss ## loss function采用了(output,target)作为函数的输入error = nn.CrossEntropyLoss()# SGD Optimizerlearning_rate = 0.02optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate) # torch.optim包含SGD, Nesterov-SGD, Adam, RMSProp, etc 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# ANN model trainingcount = 0loss_list = []iteration_list = []accuracy_list = []for epoch in range(num_epochs): for i, (images, labels) in enumerate(train_loader): train = Variable(images.view(-1, 28*28)) labels = Variable(labels) # 清除梯度：在每次进行backward之前，必须要清空先前存在的梯度 optimizer.zero_grad() outputs = model(train) # 前向传播，创建网络 loss = error(outputs, labels) # 计算softmax 和ross entropy loss loss.backward() # 计算梯度 optimizer.step() # 更新参数 count += 1 if count % 50 == 0: # 计算正确率 correct = 0 total = 0 # 预测测试集数据 for images, labels in test_loader: test = Variable(images.view(-1, 28*28)) # Forward propagation outputs = model(test) # Get predictions from the maximum value predicted = torch.max(outputs.data, 1)[1] # Total number of labels total += len(labels) # Total correct predictions correct += (predicted == labels).sum() accuracy = 100 * correct / float(total) # store loss and iteration loss_list.append(loss.data) iteration_list.append(count) accuracy_list.append(accuracy) if count % 500 == 0: # Print Loss print('Iteration: &#123;&#125; Loss: &#123;&#125; Accuracy: &#123;&#125; %'.format(count, loss.data[0], accuracy)) 使用 torch.nn 包可以进行神经网络的构建，而nn建立在autograd的基础上来进行模型的定义和微分。 nn.Module中包含着神经网络的层，同时forward(input)方法能够将output进行返回。 autograd 包提供Tensor所有操作的自动求导方法。 autograd.Variable 这是这个包中最核心的类。 它包装了一个Tensor，并且几乎支持所有的定义在其上的操作。一旦完成了你的运算，你可以调用 .backward()来自动计算出所有的梯度。 你可以通过属性 .data 来访问原始的tensor，而关于这一Variable的梯度则集中于 .grad 属性中。 还有一个在自动求导中非常重要的类 Function，Variable 和 Function 二者相互联系并且构建了一个描述整个运算过程的无环图。每个Variable拥有一个 .creator 属性，其引用了一个创建Variable的 Function。 注意: torch.nn 只接受小批量的数据整个torch.nn包只接受那种小批量样本的数据，而非单个样本。 例如，nn.Conv2d能够结构一个四维的TensornSamples x nChannels x Height x Width。如果你拿的是单个样本，使用input.unsqueeze(0)来加一个假维度就可以了。 3.2使用gpu训练模型就像你把Tensor传递给GPU进行运算一样，你也可以将神经网络传递给GPU。这一过程将逐级进行操作，直到所有组件全部都传递到GPU上。 记住，每一步都需要把输入和目标传给GPU。 参考 PyTorch深度学习：60分钟入门(Translation) 原文]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDM下载工具]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2018%2F09%2F05%2FIDM%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[IDM安装及使用 简介Internet Download Manager（简称“IDM”）是一种将下载速度提高5倍的工具，支持断点下载和批量下载。Internet Download Manager支持代理服务器，ftp和http协议，防火墙，重定向，Cookie，授权，MP3音频和MPEG视频内容处理。 安装及破解（1）修改C:\Windows\System32\drivers\etc\host目录下的host文件，添加这几项，将IDM的认证服务器域名屏蔽了。 127.0.0.1 tonec.com127.0.0.1 www.tonec.com127.0.0.1 registeridm.com127.0.0.1 www.registeridm.com127.0.0.1 secure.registeridm.com127.0.0.1 internetdownloadmanager.com127.0.0.1 www.internetdownloadmanager.com127.0.0.1 secure.internetdownloadmanager.com127.0.0.1 mirror.internetdownloadmanager.com127.0.0.1 mirror2.internetdownloadmanager.com127.0.0.1 mirror3.internetdownloadmanager.com （2）开始 -&gt; 运行 -&gt; 输入cmd -&gt; 在CMD窗口输入 ipconfig /flushdns 刷新DNS解析缓存，使之生效。 （3）打开IDM，输入序列号，断网，确定，当工具栏注册变灰色即破解成功。 或者使用破解插件链接： 下载神器 Internet Download Manager v6.31 Build 3 中文破解版 集成到浏览器IDM 默认可以集成到 Internet Explorer, Opera, MSN Explorer, AOL, Netscape, Mozilla, Mozilla Firebird, Mozilla Firefox, MyIE2, Avant Browser, NetCaptor, GoSurf, Fast Browser, SlimBrowser, 和其它更多受欢迎的浏览器。 （1）菜单栏帮助—–&gt;检测更新 （2）打开chrome浏览器扩展工具，将IDM安装目录下的IDMGCExt.crx文件拖入来安装扩展 具体教程参考：链接 ## 使用技巧因为IDM只能下载HTTP HTTPS FTP连接，不能下载ED2K,种子,迅雷,磁力等等其他。 如果要下载以上连接，需要先用支持离线功能的网盘（(百度离线、115离线、迅雷离线、等等)，再用IDM通过网盘链接下载到本地。 OS5HG-K90NH-SXOGT-7JYEZR2C1T-O0KQO-JAVU2-4MMYPM2A16-47AAW-6NLYP-V1E0JIZO7M-360FW-QY1XP-AWLPN46YFS-S9G7H-QZFWI-QQBQBTUTR2-I2NHO-GQBC6-ZECWH BFBND-FXJ4C-LW18E-WP2H3YRB4C-X2GT3-WU781-UKHN506NWL-EHOER-DZ12V-9IMMC4UWOB-RHE7H-6IET0-ECUOGCUFNR-D4R3C-UKPH6-GD4A1 参考（1）IDM破解 （2）比迅雷好用的下载软件IDM图文教程（5.12有更新）]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R操作MySQL数据库]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2018%2F08%2F25%2FR%E6%93%8D%E4%BD%9CMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[R操作MySQL数据库 RMySQL操作MySQL数据库 连接MySQL数据库 conn &lt;- dbConnect(MySQL(), dbname=&quot;r_data&quot;, username=&quot;root&quot;, password=&quot;root&quot;, host=&quot;127.0.0.1&quot;, port=3306) summary(conn) 查看数据库信息 dbGetInfo(conn) 查看数据库表格列表 dbListTables(conn) 从R导出数据到数据库 dbWriteTable函数用来将R中的数据导入MySQL数据库，其包括创建新的表格，覆盖已有的表格，追加数据到表格。用法为dbWriteTable(MySQL连接对象名，表格名，R数据框名)(row.names=FALSE不插入row.names字段) (1) 创建 &gt; dbWriteTable(conn,&quot;test&quot;,cars，row.names=FALSE) [1] TRUE &gt; dbListTables(conn) [1] &quot;test&quot; （2） 覆盖 dbWriteTable(conn,&quot;test&quot;,cars2,row.names=FALSE,overwrite = TRUE) （3）追加 dbWriteTable(conn,&quot;test&quot;,cars3,row.names=FALSE,append = TRUE) 尽量避免使用WriteTable()函数，因为它会删除你原来定义的表结构，创建新的表结构再插入 （4）删除表格 dbRemoveTable(con,&quot;test&quot;) 导出数据到R数据框 dbReadTable()函数用来从MySQL数据库提取整个表格（前提是表格数据量不是很大）。 dbReadTable(conn,&quot;test&quot;) 获取表格字段列表 dbListFields(conn,&quot;test&quot;) 查询语句使用 dbGetQuery()函数用来提取表格中指定的行(使用LIMIT查看前几行) dbGetQuery(conn,&quot;SELECT * FROM test LIMIT 5;&quot;) 另一种方式是使用dbSendQuery()查询数据库，然后使用dbFetch()获取数据 dbSendQuery(conn,&quot;SET NAMES gbk&quot;) ##若表格中含有中文需要先设置字符集gbk query &lt;- dbSendQuery(conn,&quot;SELECT * FROM test;&quot;) data &lt;- dbFetch(query,n=5) ## data &lt;- dbFetch(query,n=-1)获取所有查询到的数据 dbGetInfo()函数也可以查看query对象的信息 dbGetInfo(query) dbGetStatement()函数用于返回query的MySQL查询语句 &gt; dbGetInfo(query) $`statement` [1] &quot;SELECT * FROM test;&quot; dbGetRowCount()函数用于返回dbFetch对象查询到的数据行数 &gt;dbGetRowCount(data) 5 dbColumnInfo()函数用于查看query对象的列信息 &gt; dbColumnInfo(query) name Sclass type length 1 row_names character BLOB/TEXT 65535 2 speed double DOUBLE 22 3 dist double DOUBLE 22 dbClearResult()函数释放dbSendQuery()函数的数据库资源 dbClearResult(query) 检查数据类型 &gt; dbDataType(RMySQL::MySQL(),&quot;A&quot;) [1] &quot;text&quot; &gt; dbDataType(RMySQL::MySQL(),1:5) [1] &quot;bigint&quot; &gt; dbDataType(RMySQL::MySQL(),1.5) [1] &quot;double&quot; 断开数据库连接 dbDisconnect(conn)]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R数据整合函数包小结]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2018%2F08%2F23%2FR%E6%95%B0%E6%8D%AE%E6%95%B4%E5%90%88%E5%87%BD%E6%95%B0%E5%8C%85%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[R数据整合函数包小结 Do Faster Data Manipulation using These 7 R Packages（推荐） R语言数据整合常用包列表 dplyr data.table ggplot2 reshape2 readr tidyr lubridate apply函数 &emsp;&emsp;在使用R时，不要用循环，效率特别低，要用向量计算代替循环计算。原因在于R的循环操作for和while，都是基于R语言本身来实现的，而向量操作是基于底层的C语言函数实现的，从性能上来看，就会有比较明显的差距了。那么如何使用C的函数来实现向量计算呢，就是要用到apply的家族函数。 apply函数本身就是解决数据循环处理的问题，为了面向不同的数据类型，不同的返回值，apply函数组成了一个函数族，包括了8个功能类似的函数。 &emsp;&emsp;apply函数是这三个函数的精髓，lapply是它的变种，sapply是lapply的精华简洁版本。apply函数的基本命令格式是：apply(数据，向量，函数)。 数据可以是矩阵，数据框，数组（二维或者多维） 向量指的是矩阵的行或列，通俗的说，向量为1的时候横着算，向量为2的时候竖着算。 函数作用对象区分多元素和单元素：例如sum函数它必须应用在多个元素（数值）上，此时可利用apply(matrix,1,sum)对矩阵列求和；又例如sqrt函数它只作用于单个数值，此时apply(matrix,1,sqrt)表示对每个元素求平方根，每一列的运算结果变成新的一行；而apply(matrix,2,sqrt)表示对每个元素求平方根，每一列的运算结果变成新的一列。 使用自定义函数：apply(matrix,1,function(x),MyFunction(x)) (单个自变量x, 当这个函数应用在我们数据上的时候，就默认是对数据矩阵的每一个元素（数值）进行运算。) 多自变量函数function (y) MyFunction(x,y) 从这个写法上可以看出，function定义了，在多元函数情况下，数据矩阵的自变量对应位置，此时为y &emsp;&emsp;lapply的特殊之处在于，它的输出形式为列表（list），并且每一个运算结果（数值）都是一个单独的列表。这就是说，如果运算结果有六个数值，lapply就会输出六个列表，每一个列表里为一个数值。(根据运算顺序(按列)将结果输出为列表。)在执行lapply的时候即可以预先对结果输出形式进行设计。比如说，合并列表做个矩阵啊（matrix）或者数据框（data frame） 合并成矩阵： do.call(rbind,lapply(matrix,sqrt)) 原始matrix为3x2的矩阵，处理后变为6行一列矩阵；do.call(cbind,lapply(matrix,sqrt))处理后变为1行6列的矩阵 合并成数据框：data.frame(lapply(matrix,sqrt)) 处理后成为1行6列的数据框 dplyr函数包&emsp;&emsp;首先需要安装dplyr包，install.packages(“dplyr”)。dplyr包是“方便应用”型包，主要组成不是计算类函数，而是快速加工数据的函数。dplyr包系列的命令大部分可以在一个函数内包含多个条件，各个条件之间用逗号连接；不同分类的条件可以在同一个函数中混合运用；多个函数之间可以用包内的串串函数（函数名：pipe，函数写法：%in%）连接在一起；dplyr包在处理大样本量的复杂数据时极为好用。 接下来介绍dplyr包中七个基础函数的使用方法: 其中weight和Time为numeric类型；Chick和Diet为factor类型 dplyr系列命令的通用格式：函数名称（应用数据集，条件） count是计数命令，专门来数某一项内容的细分组里分别有多少样本 count(ChickWeight,Diet) 对Diet中每一组的样本量进行分组计数 summarise是总结命令，它可以对1个或多个列进行总结（求最小值，最大值，均值等等） summarise(CheckWeight,mean(weight,na.rm=TRUE)) 对weight列移除NA值后求均值summarise(CheckWeight,mean(weight,na.rm=TRUE),min(weight)) 对weight列移除NA值后求均值并求最小值 dplyr这个包中很重要的一个点：在一个命令中可以有多个执行条件，每个条件以逗号隔开。 group_by是分组命令，它可以把整个数据集按照某项内容分组。 summarise(group_by(ChickWeight,Diet),mean(Time,na.rm=TRUE)) 针对Diet的分组，求Time的均值 filter命令是筛选数据内容的命令 filter(ChickWeight,weight&gt;=40)筛选特定数值 filter(ChickWeight,weight &gt;=40,Time&gt;=2)两个数值筛选条件中间用,号隔开 filter(ChickWeight,Diet == 1) 字符数据的是否判定用的是双等号== filter(ChickWeight,Diet %in% c(1,3)) 在筛选字符数据时，我们可以设定两项或多项条件，在这一情况下，逗号就不再适用了，我们需要连用集合c()和%in% filter(ChickWeight,Chick ==2, Diet == 1) 同时筛选两列字符数据 filter(ChickWeight,weight&gt;=40,Chick == 2) 同时进行数值数据筛选和字符数筛选 select命令能够选择某一列或某几列，以及排除某一列或某几列。容易和filter混淆的select命令来啦。之前我们说，filter筛选的是内容，select选的是“列”。 select(ChickWeight,weight,Diet)筛选出weight和Diet两列 select(ChickWeight,-weight)排除weight列 select(ChickWeight,-weight,-Diet)排除weight列和Diet列 select(ChichWeight,Time:Diet) 从Time列到Diet列都要 处理数据的时候我们时不时会遇到需要添加一列，列的内容是行中某项数据的处理结果， mutate命令可以帮助我们很方便的进行这一操作。 mutate(ChickWeight,Diff=(weight-mean(weight)))在原始数据后面加一列，列名为Diff,列的内容荣是该行weight的值weight均值之差 pipe，在R中的表达方式为%in%。请大家注意这两者是不同的，之前我们列举的六个函数都是名称与表达方式相同，但串串函数是个特例。串就是羊肉串的串，作用一模一样，只不过串起来的是“函数命令”，目的是将一系列函数连续使用，减少代码量，减少中间数据，直接得到最终运算结果。 CW_p1 &lt;- ChickWeight%&gt;% filter(Chick!=c（15,18,20,17）) %&gt;% #第一步函数 group_by(Diet)%&gt;% # 第二步函数 summarise(mean(Time,na.rm=TRUE)) #第三步函数 每一步都是根据上一步的结果进行运算，最后的结果是对最新的数据进行Time项的总结（求均值） 数据框关联的函数（类似merge()函数） inner_join(x, y, by = NULL, copy = FALSE, suffix = c(“.x”, “.y”), …) #内连接，merge x,y两个数据框，仅保留都匹配上的 left_join(x, y, by = NULL, copy = FALSE, suffix = c(“.x”, “.y”), …) #左连接，在x数据框上加上y数据框匹配上的 right_join(x, y, by = NULL, copy = FALSE, suffix = c(“.x”, “.y”), …) #右连接，在y数据框上加上x数据框匹配上的 full_join(x, y, by = NULL, copy = FALSE, suffix = c(“.x”, “.y”), …) #全连接，跟内连接的区别在于其保留x,y数据框的所有行 semi_join(x, y, by = NULL, copy = FALSE, …) #返回x数据框中能与y数据框匹配上的行 anti_join(x, y, by = NULL, copy = FALSE, …) #返回x数据框中不能与y数据框匹配上的行 plyr 包plyr包可以进行类似于数据透视表的操作，将数据分割成更小的数据，对分割后的数据进行些操作，最后把操作的结果汇总。 reshape2包 宽数据:每一列为一个变量，每一行为变量所对应的值 长数据:一列包含了所有的变量，而另一列则是与之相关的值(长数据不一定只有两列) reshape2 用得比较多的是melt和cast两个函数。 melt函数对宽数据进行处理，得到长数据 cast函数对长数据进行处理，得到宽数据 melt公式： melt(data,id.vars,measure.vars,variable.name=’variable’,…,na.rm=FALSE,value.name=’value’,factorAsStrings=TRUE) （1）只带有data参数的情况 我们可以看到如果id.vars和measure.vars都没有设置，默认会使用所有的因子变量和字符变量作为ID变量，使用所有的非因子和非字符变量作为测量变量 （2）使用id.vars参数的情况 指定ID variables就是那些能够区分不同行数据的变量，个人感觉类似于数据库中的主键。 （3）使用variable.name和value.name的情况，宽数据转长数据的同时修改列名(长数据有一列数据是变量的类型，有一列是变量的值) aql &lt;- melt(airquanlity,id.vars = c(&quot;month&quot;,&quot;day&quot;)), variable.name = &quot;climate_variable&quot;, value.name =&quot;climate_value&quot;) dcast公式: dcast(data, formula, fun.aggregate = NULL, ..., margins = NULL,subset = NULL, fill = NULL, drop = TRUE,value.var = guess_value(data)) dcast借助于公式来描述数据的形状，左边参数表示”ID variables”，而右边的参数表示measured variables。 （1）aqw &lt;- dcast(aql,month + day ~ variable) tidyr包- reshape2包的进化版Tidy data的原则： 每一列：代表一个变量（vairable） 每一行：代表一次观测（observation） &emsp;&emsp;要实现转换结果，在Geneid一定的情况下，我们可以把每一个样品和其对应的基因表达量看做一个键-值对（key-value pair）。比如：在GeneID为gene1时，sample1对应的表达量是3，sample2对应的表达量是4。因此，我们在转换数据时，只需按照上述规则，并指定要转换的列即可。使用tidyr包中的gather函数即可实现转换。 # gather()命令转换说明：# gather（data=数据框名，key=&quot;key名&quot;，value=&quot;value名&quot;，要转换的列1，列2，列3） &gt; gene_exp_tidy &lt;- gather(data = gene_exp, key = &quot;sample_name&quot;, value = &quot;expression&quot;, Sample1, Sample2, Sample3) # 在指定要转换的列时，也可不用列名，直接指定列的编号即可 &gt; gene_exp_tidy &lt;- gather(data = gene_exp, key = &quot;sample_name&quot;, value = &quot;expression&quot;, 2:4) # 在指定要转换的列时，也可指定不需转换的列，其他列参与转换 &gt; gene_exp_tidy &lt;- gather(data = gene_exp, key = &quot;sample_name&quot;, value = &quot;expression&quot;, -GeneId) 使用spread()函数将Tidy格式数据还原 spread(data = gene_exp_tidy, key = &quot;sample_name&quot;, value = &quot;expression&quot;) 有时，在数据处理时，我们会遇到下面这种更加复杂的情况，在GeneId一定的情况下，每一样品还对应不同的温度： 处理策略： 先使用gather()函数，按列进行转换 再使用spread()函数，将Sample和温度分开 gene_exp3_tidy &lt;- gather(gene_exp3, key, Expression, -GeneId) 3.使用seprate()函数，对key这一列进行分割 gene_exp3_tidy2 &lt;- separate(gene_exp3_tidy, col = key, into = c(&quot;SampleName&quot;,&quot;Temperature&quot;)) data.table包&emsp;&emsp;如果你的数据量比较大，1GB，10GB，甚至有100GB，对于这种规模比较大的数据集，apply的计算方式就不太能满足计算性能的要求了。你依然可以用data.table包, bigmemory包, ff包等，或者并行计算的包加速R语言在单机上的计算的性能。 &emsp;&emsp;data.table包是一个data.frame的扩展工具集，可以通过自定义keys来设置索引，实现高效的数据索引查询、快速分组、快速连接、快速赋值等数据操作。data.table主要通过二元检索法大大提高数据操作的效率，它也兼容适用于data.frame的向量检索法。同时，data.table对于大数据的快速聚合也有很好的效果，官方介绍说对于 100GB规模内存数据处理，运行效率还是很好的。 &emsp;&emsp;由于data.table对用户使用上是希望和data.frame的操作尽量相似，所以适用于data.frame的查询方法基本都适用于data.table，同时data.table自己具有的一些特性，提供了自定义keys来进行高效的查询。 R for Data Science(推荐) 该书github地址：hadley/r4ds 参考（1）掌握R语言中的apply函数族 （2）R语言的plyr包简介 （3）利用reshape2包进行数据逆透视和数据透视 （4）reshape2包的进化版—tidyr包 （5）超高性能数据处理包data.table]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kaggle]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2018%2F05%2F13%2FKaggle%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[kaggle简介及数据竞赛相关平台 国内外数据竞赛平台国际 Kaggle：是一个流行的数据科学竞赛平台，已被谷歌收购。与 GitHub 不同的地方在于，Kaggle 为其社区提供了一整套服务。其中最有名的是它的招聘服务以及名为 Kaggle Kernels的代码分享工具。 KDD CUP： 自1997年以来，KDD举办了年度预测建模竞赛，KDDCup。SIGKDD是Data Mining领域的顶会。KDD Cup是其下的一个比赛。含金量很高。每年都会有比较有意思的题目。不过个人感觉难度还是有的，因而全世界的DM、ML大牛、小牛都可能在做这个。 Topcoder：已经有近15年的历史，拥有主要的企业合作伙伴，并且在竞争性编程领域与Kaggle（竞争数据科学网站）最为接近。 国内 天池：由国内科技巨头阿里举办，应该算是国内一流的数据挖掘类型的比赛了。由于是阿里举办，所以比赛获得不错名次的可以获得阿里校招直通车的权利，题目难度的话，个人觉得不算难，与kaggle相仿。 SODA上海开放数据创新应用大赛 首页-DataCastle大数据竞赛平台 kaggle比赛类型 课业比赛InClass: 课业比赛 InClass 是学校教授机器学习的老师留作业的地方，这里的竞赛有些会向public开放参赛，也有些仅仅是学校内部教学使用。 入门比赛 Getting Started: 入门比赛 Getting Started 给萌新们一个试水的机会，没有奖金，但有非常多的前辈经验可供学习。很久以前Kaggle这个栏目名称是101的时候，比赛题目还很多，但是现在只保留了9个最经典的入门竞赛：手写数字识别、沉船事故幸存估计、脸部识别、Julia语言入门。 训练场 Playground: 训练场 Playground里的题目以有趣为主，比如猫狗照片分类的问题。现在这个分类下的题目不算多，但是热度很高。 研究项目(少奖金) Research: 研究型 Research 竞赛通常是机器学习前沿技术或者公益性质的题目。竞赛奖励可能是现金，也有一部分以会议邀请、发表论文的形式奖励。 人才征募 Recruitment: 人才征募 Recruitment 竞赛是赞助企业寻求数据科学家、算法设计人才的渠道。只允许个人参赛，不接受团队报名。 大型组织比赛(大奖金) Featured : 推荐比赛 Featured 是瞄准商业问题带有奖金的公开竞赛。如果有幸赢得比赛，不但可以获得奖金，模型也可能会被竞赛赞助商应用到商业实践中呢。 入门kaggle 数据科学之旅（博客） 文森特·费尔曼西亚 Python Machine Learning: Scikit-Learn Tutorial Kaggle 入门指南（推荐） Machine Learning &amp; Kaggle Competition 数据科学的完整学习路径—Python版 特征工程到底是什么？ kaggle Hands-On Data Science Education kaggle in class Data Science 101 UC Irvine Machine Learning Repository kaggle入门竞赛1.Titanic（泰坦尼克之灾） 中文教程： 逻辑回归应用之Kaggle泰坦尼克之灾 &emsp;&emsp; 英文教程：An Interactive Data Science Tutorial 2.House Prices: Advanced Regression Techniques（房价预测） 中文教程：Kaggle竞赛 — 2017年房价预测 &emsp;&emsp; 英文教程：How to get to TOP 25% with Simple Model using sklearn 3.Digital Recognition（数字识别） 中文教程：大数据竞赛平台—Kaggle 入门 &emsp;&emsp; 英文教程：Interactive Intro to Dimensionality Reduction bioninformatics competitions Critical Assessment of Function Annotation ：给定一个基因序列，你可以开发一个软件工具，可以预测基因编码的功能。基本上，你开发一个工具并预测一些未注释基因的功能。在几个月内，这些基因中的一些将被注释，并且这些新注释的基因可以用来衡量你的工具的准确性。这与过去几年ISMB一起举行。 CASP：类似的概念。给定一个基因序列，你能预测它编码的蛋白质的结构（假设它编码一种蛋白质）。 Critical Assessment of Prediction of Interactions ：类似的概念。鉴于蛋白质，你能预测这种蛋白质可以与哪些蛋白质相互作用。 Assemblathons：Genome 10K项目的一个分支，主要由加州大学戴维斯分校基因组中心组织，Assemblathons是评估基因组组装领域最先进的方法的比赛。 Project Data Sphere：该项目数据球球平台可与生命科学公司，医院和机构，以及独立的研究人员研究人员所。任何对癌症研究感兴趣的人都可以申请成为授权用户。 American Epilepsy Society Seizure Prediction Challenge Dream ChallengesDREAM挑战是众包挑战，考察生物学和医学问题 开放挑战 梦想挑战参与者出版物 挑战算法：竞赛报告及算法源码 Kaggle历年真题解析历年竞赛前3名的解决方案源代码：链接Kaggle 中文文档：链接比赛收集平台：链接Kaggle 入门操作指南：链接GitHub 入门须知：链接 参考（1）机器学习系列(3)_逻辑回归应用之Kaggle泰坦尼克之灾 （2）Titanic: Getting Started With R （3）初学者应该参加哪些Kaggle比赛？ （4）计算机科学领域有哪些竞争平台？ （5）参加kaggle竞赛是怎样一种体验？ （6）生物信息学和基因组学中的一些公开竞争是什么？ （7）What are the best universities to study bioinformatics? （8）Question: Bioinformatic Algorithms Books]]></content>
      <categories>
        <category>数据竞赛</category>
      </categories>
      <tags>
        <tag>数据竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[k_means聚类算法python实现]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2018%2F05%2F09%2Fk-means%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95python%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[k_means聚类算法python实现，并对50个基因表达量聚类 k means 聚类思路K-means算法以k为参数，把n个对象分为k个簇，使簇内具有较高的相似度，而簇间的相似度较低。 随机选择K个点作为初始的聚类中心 对于剩下的点，根据其与聚类中心的距离，将其归入最近的簇 对每个簇，计算所有点的均值作为新的聚类中心 重复步骤2,3直到聚类中心不再变化 K_meas_cluster.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# -*- coding: UTF-8 -*-import numpy as npimport math,os,randomos.chdir(r'F:\pycharm_project\cluster')data = pd.read_csv(r'.\microarray_gcrma_diff_TOP50.csv',nrows = 51,header=None)Exp_matrix = np.array(data.iloc[1:51,1:3],dtype =np.float64)def random_k_start(A,k): k_point_list = [] for i in range(0,k): random_index = random.randint(0, A.shape[0]) k_point_list.append(A[random_index]) return k_point_listdef Euclidean_Distances(a,b): d = math.sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) return ddef classify_points(A,center): classified_list = [] for j in range(0, len(center)): names = locals() names['point_list%s' % j] = [] for i in range(0,A.shape[0]): dis_list = [] for j in range(0,len(center)): dis = Euclidean_Distances(A[i],center[j]) dis_list.append(dis) min_dis_index =dis_list.index(min(dis_list)) names['point_list%s' % min_dis_index].append(A[i]) for j in range(0,len(center)): classified_list.append(names['point_list%s' % j]) return classified_listdef creat_new_center(mylist): center_new = [] for i in range(0,len(mylist)): point_x_sum = 0 point_y_sum = 0 for j in range(0, len(mylist[i])): point_x_sum += mylist[i][j][0] point_y_sum += mylist[i][j][1] point_pos = [point_x_sum/len(mylist[i]),point_y_sum/len(mylist[i])] center_new.append(point_pos) return center_newdef k_mens_loop(A,k): start = random_k_start(A,k) classified_list = classify_points(A, start) center_new = creat_new_center(classified_list) classified_list = classify_points(A, center_new) center_new_next = creat_new_center(classified_list) while center_new != center_new_next: center_new = creat_new_center(classified_list) classified_list = classify_points(A, center_new) center_new_next= creat_new_center(classified_list) return classified_listresult_k_means_cluster = k_mens_loop(Exp_matrix,3)print(result_k_means_cluster)def format_cluster_result(mylist): for i in range(0,len(mylist)): print("The "+ str(i+1)+" class include this points "+str(mylist[i]))format_cluster_result(result_k_means_cluster) 结果123456The 1 class include this points [array([ 4.93486944, 13.14640868]), array([ 9.44642109, 13.35037465]), array([ 2.49151711, 10.83512875]), array([ 9.8840153 , 12.83855873]), array([ 6.00091999, 11.32824297]), array([ 7.80347201, 11.06602904]), array([ 6.68408837, 11.29720113]), array([6.13240771, 8.75948733]), array([ 7.41177163, 11.46909421]), array([ 5.81649515, 12.38062477]), array([ 7.99449013, 10.8097551 ]), array([ 7.15714487, 11.575675 ]), array([ 6.45817254, 10.02135377]), array([ 8.17631453, 10.85800827]), array([ 7.90910338, 11.01532861]), array([ 8.02190753, 13.19604362]), array([6.47480105, 9.0377897 ]), array([ 8.97900038, 11.21312381]), array([6.12469976, 9.84061508]), array([ 7.380284 , 12.1630906]), array([6.01540939, 9.75805721])]The 2 class include this points [array([2.50308546, 5.91300188]), array([2.24197899, 9.8390274 ]), array([5.33573424, 8.07922933]), array([5.64747242, 3.61139246]), array([5.35174955, 7.57523097]), array([6.91440679, 3.1232664 ]), array([2.71849667, 4.76027382]), array([3.97446062, 8.03512416]), array([6.45228078, 2.44931761]), array([4.5782664 , 7.51644097]), array([3.99185391, 6.05134528]), array([4.06301573, 7.63789036]), array([3.89376658, 6.12632702]), array([3.09482821, 9.36668278]), array([5.30726995, 8.56688374]), array([4.33465033, 8.58483349]), array([2.64882616, 4.71169159]), array([2.23241425, 6.36768551])]The 3 class include this points [array([14.23058515, 12.21441832]), array([10.21858224, 7.9990988 ]), array([9.07154372, 6.73460898]), array([11.34847715, 8.99124024]), array([12.4881844, 10.2497519]), array([9.97529373, 6.69985229]), array([10.97051098, 8.08711864]), array([9.90668681, 7.8113881 ]), array([9.37065246, 4.70014833]), array([8.6836169 , 6.10392713]), array([9.2391499 , 6.50016246])]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[层级聚类算法python实现]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2018%2F05%2F07%2F%E5%B1%82%E7%BA%A7%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95python%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[python实现对50个基因表达量层级聚类算法 聚类算法python实现层级聚类Hierarchical_Clustering.py思路 通过50行基因，实验组和对照组两列，每组各3个重复的平均表达量，根据欧式距离计算距离矩阵DE 对距离矩阵进行层级聚类 层级聚类算法伪代码： Hierarchical_Clustering（d,n） 形成n个类，每个类含有一个元素 构建树型图，为每个类分配一个单独的顶点 while 存在多于一个类 找到最近的两个雷C1和C2 将C1和C2合并成一个新的类C,Chanyou |C1|+|C2|个元素 计算C与其他各类的距离 在树形图中增加一个顶点C,且与C1和C2相连 在距离矩阵中删除与C1和C2相对应的行和列 在距离矩阵中为新类增加一行一列 return T 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697# -*- coding: UTF-8 -*-import pandas as pdimport numpy as npimport math,osos.chdir(r'F:\pycharm_project\cluster')data = pd.read_csv(r'.\microarray_gcrma_diff_TOP50.csv',nrows = 51,header=None)Exp_matrix = np.array(data.iloc[1:51,1:3],dtype =np.float64)def Euclidean_Distances(A): n = A.shape[0] mydist = np.zeros((n, n)) for i in range(0,50): for j in range(0,50): d = math.sqrt((A[i][0]-A[j][0])**2+(A[i][1]-A[j][1])**2) mydist[i,j] = ("%.2f" % d) return mydistDE = Euclidean_Distances(Exp_matrix)#print(DE)def find_min_index_list(A): if 0 in A: mask = A ==0 A[mask == True] =np.inf else: pass dis_min = A.min() dis_min_pos = np.where(A ==dis_min) pos_list = [] for i in range(0,len(dis_min_pos[0])): for j in range(0, len(dis_min_pos[0])): if i &gt; j: pos_list.append([dis_min_pos[0][i],dis_min_pos[1][i]]) else: pass return pos_list#min_index_list = find_min_index(DE)#print(min_index_list)def delete_list(mylist,index_list): for i in range(0,len(index_list)): if i == 0: del mylist[index_list[i]] else: del mylist[index_list[i]-1] return mylistdef class_Euclidean_min_Distances(min_index,A): #calculate class distance min_row1 = A[min_index[0],] min_row2 = A[min_index[1],] class_dis_to_other = np.fmin(min_row1,min_row2) #delete distance list element mylist = list(class_dis_to_other) mylist_del = delete_list(mylist,list(min_index)) #delete distance matrix A_del_row = np.delete(A, [min_index[0], min_index[1]], 0) A_del_column = np.delete(A_del_row, [min_index[0], min_index[1]], 1) #add distance list A_add_row = np.row_stack((A_del_column,mylist_del)) mylist_del.append(np.inf) A_add_column = np.column_stack((A_add_row,mylist_del )) return A_add_column#min_index = split_min_index(min_index_list)#DE_new = class_Euclidean_min_Distances(min_index,DE)#print(DE_new)#min_index_list = find_min_index(A)#min_index = split_min_index(min_index_list)#A = class_Euclidean_min_Distances(min_index[0],A)#A = class_Euclidean_min_Distances(min_index[1],A)#print(A)def hierarchical_clustering(A,N): n_class = len(A) n_layer = 1 while n_class &gt; N: min_index_list = find_min_index_list(A) for i in range(0,int(len(min_index_list))): A = class_Euclidean_min_Distances(min_index_list[i], A) result = "the " + str(n_layer) + " layer class process is " + "&#123;g" + str( min_index_list[i][0]) + "," + "g" + str(min_index_list[i][1]) + "&#125;" + "---&gt;" + "g" + str(n_class-1) n_class = n_class - 1 print(result) n_layer +=1 return A A = hierarchical_clustering(DE,1) Hierarchical_Clustering输出结果及解释12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849the 1 layer class process is &#123;g38,g17&#125;---&gt;g49the 2 layer class process is &#123;g48,g16&#125;---&gt;g48the 3 layer class process is &#123;g47,g15&#125;---&gt;g47the 4 layer class process is &#123;g46,g14&#125;---&gt;g46the 5 layer class process is &#123;g45,g13&#125;---&gt;g45the 6 layer class process is &#123;g44,g12&#125;---&gt;g44the 7 layer class process is &#123;g43,g11&#125;---&gt;g43the 8 layer class process is &#123;g42,g10&#125;---&gt;g42the 9 layer class process is &#123;g41,g9&#125;---&gt;g41the 10 layer class process is &#123;g40,g8&#125;---&gt;g40the 11 layer class process is &#123;g39,g7&#125;---&gt;g39the 12 layer class process is &#123;g38,g6&#125;---&gt;g38the 13 layer class process is &#123;g37,g5&#125;---&gt;g37the 14 layer class process is &#123;g36,g4&#125;---&gt;g36the 15 layer class process is &#123;g35,g3&#125;---&gt;g35the 16 layer class process is &#123;g34,g2&#125;---&gt;g34the 17 layer class process is &#123;g33,g1&#125;---&gt;g33the 18 layer class process is &#123;g32,g0&#125;---&gt;g32the 19 layer class process is &#123;g31,g0&#125;---&gt;g31the 20 layer class process is &#123;g30,g0&#125;---&gt;g30the 21 layer class process is &#123;g29,g0&#125;---&gt;g29the 22 layer class process is &#123;g28,g0&#125;---&gt;g28the 23 layer class process is &#123;g27,g0&#125;---&gt;g27the 24 layer class process is &#123;g26,g0&#125;---&gt;g26the 25 layer class process is &#123;g25,g0&#125;---&gt;g25the 26 layer class process is &#123;g24,g0&#125;---&gt;g24the 27 layer class process is &#123;g23,g0&#125;---&gt;g23the 28 layer class process is &#123;g22,g0&#125;---&gt;g22the 29 layer class process is &#123;g21,g0&#125;---&gt;g21the 30 layer class process is &#123;g20,g0&#125;---&gt;g20the 31 layer class process is &#123;g19,g0&#125;---&gt;g19the 32 layer class process is &#123;g18,g0&#125;---&gt;g18the 33 layer class process is &#123;g17,g0&#125;---&gt;g17the 34 layer class process is &#123;g16,g0&#125;---&gt;g16the 35 layer class process is &#123;g15,g0&#125;---&gt;g15the 36 layer class process is &#123;g14,g0&#125;---&gt;g14the 37 layer class process is &#123;g13,g0&#125;---&gt;g13the 38 layer class process is &#123;g12,g0&#125;---&gt;g12the 39 layer class process is &#123;g11,g0&#125;---&gt;g11the 40 layer class process is &#123;g10,g0&#125;---&gt;g10the 41 layer class process is &#123;g9,g0&#125;---&gt;g9the 42 layer class process is &#123;g8,g0&#125;---&gt;g8the 43 layer class process is &#123;g7,g0&#125;---&gt;g7the 44 layer class process is &#123;g6,g0&#125;---&gt;g6the 45 layer class process is &#123;g5,g0&#125;---&gt;g5the 46 layer class process is &#123;g4,g0&#125;---&gt;g4the 47 layer class process is &#123;g3,g0&#125;---&gt;g3the 48 layer class process is &#123;g2,g0&#125;---&gt;g2the 49 layer class process is &#123;g1,g0&#125;---&gt;g1 &emsp;&emsp;层级聚类过程为：例如{g38,g17}—&gt;g49 表示原50个基因列表中第38个基因和第17个基因聚为一类，插入到剩下48个基因的末尾，作为新的第49个“基因”。以此类推，每次对两个基因聚为一类，插到剩下基因的末尾。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hisat2构建GRCH38转录组index内存不足]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2018%2F04%2F19%2Fhisat2%E6%9E%84%E5%BB%BAGRCH38%E8%BD%AC%E5%BD%95%E7%BB%84index%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%2F</url>
    <content type="text"><![CDATA[hisat2构建GRCH38转录组index内存不足 报错Ran out of memory; auhisat2 tomatically trying more memory-economical parameters 解决首先查看hisat2官网的manual,可以看到这样一句话： If you use –snp, –ss, and/or –exon, hisat2-build will need about 200GB RAM for the human genome size as index building involves a graph construction.Otherwise, you will be able to build an index on your desktop with 8GB RAM. 同时注意到参数–known-splicesite-infile: With this mode, you can provide a list of known splice sites, which HISAT2 makes use of to align reads with small anchors. You can create such a list using python hisat2_extract_splice_sites.py genes.gtf &gt; splicesites.txt, where hisat2_extract_splice_sites.py is included in the HISAT2 package, genes.gtf is a gene annotation file, and splicesites.txt is a list of splice sites with which you provide HISAT2 in this mode. Note that it is better to use indexes built using annotated transcripts (such as genome_tran or genome_snp_tran), which works better than using this option. It has no effect to provide splice sites that are already included in the indexes. 所以有两种解决方式：第一种可以申请更多的内存资源重新建索引；第二种，可以在建索引的时候不加可变剪切位点，在比对的时候提供，但效果不如第一种好。 查看节点可用内存使用top命令查看： 如果出于习惯去计算可用内存数，这里有个近似的计算公式：第四行的free + 第四行的buffers + 第五行的cached，按这个公式此台服务器的可用内存：530668+79236+4231276 = 4.7GB]]></content>
      <categories>
        <category>NGS</category>
      </categories>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任务提交系统使用]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2018%2F04%2F05%2F%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[任务提交系统使用 什么是批处理作业调度程序？&emsp;&emsp;大多数现有的高性能计算集群都由作业调度程序管理; 也称为批量调度程序，工作负载管理器，排队系统或负载均衡器。调度程序允许多个用户公平地共享计算节点，允许系统管理员控制资源如何提供给不同用户组。所有调度程序都设计用于执行以下功能： 允许用户向集群提交新作业 允许用户监视其排队和正在运行的作业的状态 允许用户和系统管理员控制正在运行的作业 监控受管资源的状态，包括系统负载，可用内存等 &emsp;&emsp;当用户提交新作业时，群集调度程序软件将分配计算核心和内存以满足作业要求。如果合适的资源不可用于运行作业，则调度程序会将作业添加到队列中，直到有足够的资源可用于作业运行。您可以配置调度程序来控制如何从队列中选择作业并在集群节点上执行作业，包括自动准备节点以运行并行MPI作业。作业完成运行后，调度程序将作业使用的资源返回到可用资源池，准备运行其他用户作业。 计算作业的类型用户可以通过集群调度程序运行多种不同类型的作业，其中包括： 批量作业 ; 单线程应用程序只能在一个计算核心上运行 阵列作业 ; 为方便起见，将两个或多个类似的批处理作业一起提交 SMP或多线程的工作; 在同一个计算节点上的两个或多个计算核心上运行的多线程应用程序 并行作业 ; 多线程应用程序利用MPI库在分布在一个或多个计算节点上的多个内核上运行 &emsp;&emsp;集群作业调度程序负责查找集群中的计算节点以运行所有这些不同类型的作业。它会跟踪可用资源并将作业分配给各个节点组，确保不会过度提交CPU和内存。以下示例显示了作业调度程序如何将不同类型的作业分配给一组8-CPU核心计算节点： 交互式和批处理作业用户通常通过运行交互式或批处理（也称为非交互式）作业与计算集群进行交互。 交互式作业是用户通过图形界面或通过在命令提示符处键入来直接控制的作业。 通过编写传递给计算节点的指令列表来运行批处理作业，以便将来在某个时刻运行。 为什么在个人群集上使用作业调度程序？&emsp;&emsp;在共享的多用户群集上，作业调度程序通常用作控制机制，以确保用户不会不公平地垄断有价值的计算资源。在极端情况下，系统管理员可能会使用调度程序强制在共享环境中执行“良好行为”，并且可能感觉像对集群用户进行强制操作。 通过您自己的个人群集，您可以直接控制可用于工作的资源 - 不需要工作调度程序来限制您的使用。 然而 - 有很多原因可以使你自己的作业调度程序在你的群集中仍然是一个有用的工具： 它可以帮助您组织多阶段工作流程，批量作业在定义的过程中启动后续作业。 它可以自动启动MPI作业，找到可用的节点来运行应用程序。 它可以帮助防止意外地过度分配CPU或内存，这可能会导致节点故障。 它可以帮助将纪律带入环境，提供一致的方法来复制不同环境中的作业运行。 在调度程序中排队的作业可以用来触发扩大您的群集的大小，在没有作业运行时从群集中释放计算节点，为您节省成本。 可用的群集作业调度程序 开放网格调度器（SGE） - 一种开源的作业调度器，由最初的Sun Grid Engine（SGE）代码库构建而成， OpenLava调度程序（类似于IBM LSF） 转矩调度器 PBS Pro调度程序 作业调度系统 SLURM（简单Linux资源管理实用程序）是全球超级计算机中心采用的可扩展工作负载管理器。它是免费的并且是开源的，在通用公共许可证下发布。 IBM®Platform™LSF®是一款功能强大的工作负载管理平台，适用于要求苛刻的分布式HPC环境。它提供了一套全面的智能策略驱动调度功能，使您能够利用所有计算基础架构资源并确保最佳的应用程序性能。 LSF作业调度系统用户使用常见问题（推荐） SLURM作业调度系统常用命令SLURM manual sinfo 查看各个节点的状态，资源是否充足，当前有多少正在执行的任务 &emsp;&emsp;使用 sinfo 可粗略查看所有分区的节点信息，注意 ‘‘STATE’’ 一栏的输出 若为 ‘‘idle’’ 表示该节点处于闲置状态，若为 ‘‘alloc’’ 表示该节点已经没有多余的 资源了，若为 ‘‘mix’’ 表示该节点有人在占用，但是仍然有剩余资源。 作业提交完毕后，可使用 squeue 命令查看任务状态 squeue -l: 以长列表显示更多信息。 squeue -u username: 仅显示属于用户 username 的任务。 squeue -t state: 仅显示处于 state 状态的任务。 &emsp;&emsp;ps: ST 表示当前状态，R是Runing的简写 salloc [申请资源] salloc -N 1 –cpus-per-task=4 或者 srun -N1 -n1 hostname squeue 查看任务情况，获取分配节点，然后使用ssh 节点进行切换 OpenLava调度程序常用命令openlava manual 该OpenLava集群作业调度是一个开源平台的IBM兼容LSF作业调度程序。 运行交互式作业 bsub -Is bash -Is：Submits an interactive job and creates a pseudo-terminal when the job starts bash：Choose the shell type to use when creating the interactive job 提交批处理作业 bsub -o $HOME/jobout.txt &lt; simplejobscript.sh #jobout.txt 用于记录任何job输出 -J JOB_name 设置任务名 -n number of cores simplejobscript.sh 1234#!/bin/bash -lecho "Starting running on host $HOSTNAME"sleep 120echo "Finished running - goodbye from $HOSTNAME" 查看和控制排队任务 bjobs 查看任务的状态和排队情况，显示RUN（在运行）或者PEND(等待) bkill JOBID 杀任务，无论任务处在运行或者排队状态 bhosts查看计算节点的状态, -l查看更详细的信息 运行多线程作业 如果用户想要在计算节点上使用多个内核来运行多线程应用程序，可以使用 -n number of cores &emsp;&emsp;ps: 之前都是ssh node命令切换到计算节点再跑流程，有了集群作业调度程序就可以在登陆节点提交任务，其将自动分配计算节点资源，不包括登陆节点。 参考（1）bsub更多使用例子 （2）[OpenLava Installation Procedure](http://docplayer.net/35369468-Openlava-installation-procedure.html （3）工作站使用指南（推荐） （4）SLURM作业调度系统（推荐） （5）交大高性能计算中心 （6）PBS 作业管理系统]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HMM与viterbi算法]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2018%2F04%2F03%2FHMM%E4%B8%8Eviterbi%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[维特比算法python实现 介绍&emsp;&emsp;维特比算法是一种动态规划算法用于寻找最有可能产生观测事件序列的-维特比路径-隐含状态序列，特别是在马尔可夫信息源上下文和隐马尔可夫模型中。 python实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091seq = 'THHTHTTTHHHHHTTTHHHHHHHTHHTHHH'coins = ('F','B')coin_start_probability = &#123; 'F' : 1, 'B' : 0&#125;dealer_switch_probability = &#123; 'F' : &#123;'F': 0.99, 'B': 0.01&#125;, 'B': &#123;'F' : 0, 'B': 0.95&#125;&#125;flip_probability = &#123; 'F' : &#123;'H':0.5, 'T':0.5&#125;, 'B' : &#123;'H':0.8, 'T':0.2&#125;&#125;trace_F_way = &#123; '0' : 'FF', '1' : 'BF'&#125;trace_F_list = []trace_B_way = &#123; '0' : 'FB', '1' : 'BB'&#125;trace_B_list = []def path_traceback(trace_F_list,trace_B_list): trace = ['B',] trace_reverse = ['F',] N = 0 for i in range(len(trace_F_list)-1,0,-1): if trace_B_list[i][0] != trace_F_list[i-1][1]: trace.append(trace_B_list[i-1][0]) else : N = i break for i in range(N,0,-1): trace.append('F') for j in range(len(trace)-1,-1,-1): trace_reverse.append(trace[j]) return trace_reversepath_max = 1path_min = 1for i in range(1,len(seq)): print(seq[i]) trans_FF = dealer_switch_probability['F']['F']*flip_probability['F'][str(seq[i-1])] trans_BF = dealer_switch_probability['B']['F']*flip_probability['B'][str(seq[i-1])] if i == 1: path_F = max(trans_FF*coin_start_probability['F'],trans_BF*coin_start_probability['B']) else: path_F = max(trans_FF*path_max,trans_BF*path_min) trace_F = [trans_FF*path_max,trans_BF*path_min].index(path_F) print(trace_F_way[str(trace_F)]) trace_F_list.append(trace_F_way[str(trace_F)]) trans_FB = dealer_switch_probability['F']['B']*flip_probability['F'][str(seq[i-1])] trans_BB = dealer_switch_probability['B']['B']*flip_probability['B'][str(seq[i-1])] if i == 1: path_B = max(trans_FB*coin_start_probability['F'], trans_FB*coin_start_probability['B']) else: path_B = max(trans_FB*path_max, trans_BB*path_min) trace_B = [trans_FB*path_max,trans_BB*path_min].index(path_B) print(trace_B_way[str(trace_B)]) trace_B_list.append(trace_B_way[str(trace_B)]) path_max = max(path_F,path_B) path_min = min(path_F,path_B) print(path_F) print(path_B) print(path_max) print() print(trace_F_list)print(trace_B_list)print(path_traceback(trace_F_list,trace_B_list)) 输出123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207HFFFB0.4950.0050.495HFFBB0.2450250.00380.245025TFFBB0.121287374999999990.0028880.12128737499999999HFFFB0.0600372506250.0006064368750.060037250625TFFBB0.0297184390593749970.000460892024999999970.029718439059374997TFFFB0.0147106273343906230.0001485921952968750.014710627334390623TFFFB0.0072817605305233597.355313667195311e-050.007281760530523359HFFFB0.00360447146260906233.64088026526168e-050.0036044714626090623HFFBB0.00178421337399148582.7670690015988765e-050.0017842133739914858HFFBB0.00088318562012578542.1029724412151462e-050.0008831856201257854HFFBB0.00043717688196226381.5982590553235112e-050.0004371768819622638HFFBB0.000216402556571320591.2146768820458686e-050.00021640255657132059TFFBB0.000107119265502803699.231544303548602e-060.00010711926550280369TFFBB5.3024036423887824e-051.7539934176742344e-065.3024036423887824e-05TFFBB2.6246898029824473e-053.3325874935810454e-072.6246898029824473e-05HFFFB1.2992214524763114e-051.3123449014912237e-071.2992214524763114e-05HFFBB6.431146189757741e-069.9738212513333e-086.431146189757741e-06HFFBB3.183417363930082e-067.580104151013309e-083.183417363930082e-06HFFBB1.5757915951453906e-065.760879154770115e-081.5757915951453906e-06HFFBB7.800168395969683e-074.3782681576252876e-087.800168395969683e-07HFFBB3.861083356004993e-073.3274837997952185e-083.861083356004993e-07HFFBB1.9112362612224716e-072.528887687844366e-081.9112362612224716e-07TFFBB9.460619493051234e-081.9219546427617182e-089.460619493051234e-08HFFBB4.683006649060361e-083.6517138212472648e-094.683006649060361e-08HFFBB2.3180882912848787e-082.7753025041479213e-092.3180882912848787e-08TFFBB1.147453704186015e-082.10922990315242e-091.147453704186015e-08HFFBB5.679895835720774e-094.0075368159895986e-105.679895835720774e-09HFFBB2.811548438681783e-093.045727980152095e-102.811548438681783e-09HFFBB1.3917164771474826e-092.3147532649155923e-101.3917164771474826e-09['FF', 'FF', 'FF', 'FF', 'FF', 'FF', 'FF', 'FF', 'FF', 'FF', 'FF', 'FF', 'FF', 'FF', 'FF', 'FF', 'FF', 'FF', 'FF', 'FF', 'FF', 'FF', 'FF', 'FF', 'FF', 'FF', 'FF', 'FF', 'FF']['FB', 'BB', 'BB', 'FB', 'BB', 'FB', 'FB', 'FB', 'BB', 'BB', 'BB', 'BB', 'BB', 'BB', 'BB', 'FB', 'BB', 'BB', 'BB', 'BB', 'BB', 'BB', 'BB', 'BB', 'BB', 'BB', 'BB', 'BB', 'BB']['F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B'] 参考（1）Hidden Markov Model inference with the Viterbi algorithm: a mini-example（推荐） （2）viterbi算法：利用动态规划寻找最短路径（推荐） （3）一文搞懂HMM （4）隐马尔可夫模型的三大问题及求解方法 （5）维特比算法 （6）维特比算法wiki （7）StephHippo/viterbi]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划求序列最大得分连续子序列]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2018%2F03%2F25%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B1%82%E5%BA%8F%E5%88%97%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[动态规划求序列最大得分连续子序列（MSS） Given the single-letter scoring system and sequence shown below: A = +2, C = -1, G = -4, T = +2 TTACTGCGCCTTATAGCTATACGCTGTCGATCTGCGCAATTCCCCCCAATATCCCTCGGTTGATATTAC A. What is the maximum segment score?B. What are the start and end points of the maximum-scoring segment(MSS)? calculateMaxSumOfSubArray.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455def letter2arr(mystr): score_matrix = &#123;'A': 2,'C': -1,'G': -4,'T': 2,&#125; arr_list = [] sum = 0 for i in list(mystr): arr_list.append(score_matrix[i]) sum += score_matrix[i] print("str score sum is :",sum) return arr_listmystr='TTACTGCGCCTTATAGCTATACGCTGTCGATCTGCGCAATTCCCCCCAATATCCCTCGGTTGATATTAC'print("arr:",letter2arr(mystr)) def calculateMaxSumOfSubArray(arr): flag = 0 for i in arr: if i &gt; 0: flag +=1 if flag == 0: print("start_pos (base from 0):",arr.index(max(arr)),"start:",max(arr)) print("end_pos (base from 0)",arr.index(max(arr)),"end:",max(arr)) return max(arr) else: l = g = -100000 g_max = -100000 sum = 0 sum_min = 0 start = 0 end = 0 for i in range(0,len(arr)): l = max(arr[i],l+arr[i]) g = max(l,g) sum +=arr[i] if sum &lt; sum_min: sum_min = sum start = arr[i+1] start_pos = i + 1 if g &gt; g_max: g_max = g end = arr[i] end_pos = i print("start_pos (base from 0):",start_pos,"start:",start) print("end_pos (base from 0)",end_pos,"end:",end) return garr = letter2arr(mystr)print("max sum is:", calculateMaxSumOfSubArray(arr))#after you get start and end start = 37end = 67print("maximum-scoring segment(MSS) is:",mystr[start:end+1])print("maximum-scoring segment(MSS) score is added by:",letter2arr(mystr[start:end+1])) 输出123456789str score sum is : 6arr: [2, 2, 2, -1, 2, -4, -1, -4, -1, -1, 2, 2, 2, 2, 2, -4, -1, 2, 2, 2, 2, -1, -4, -1, 2, -4, 2, -1, -4, 2, 2, -1, 2, -4, -1, -4, -1, 2, 2, 2, 2, -1, -1, -1, -1, -1, -1, 2, 2, 2, 2, 2, -1, -1, -1, 2, -1, -4, -4, 2, 2, -4, 2, 2, 2, 2, 2, 2, -1]str score sum is : 6start_pos (base from 0): 37 start: 2end_pos (base from 0) 67 end: 2max sum is: 14maximum-scoring segment(MSS) is: AATTCCCCCCAATATCCCTCGGTTGATATTAstr score sum is : 14maximum-scoring segment(MSS) score is added by: [2, 2, 2, 2, -1, -1, -1, -1, -1, -1, 2, 2, 2, 2, 2, -1, -1, -1, 2, -1, -4, -4, 2, 2, -4, 2, 2, 2, 2, 2, 2] 第一个if判断考虑序列对应的arr全为负值的情况 动态规划最关键的动态规划思想体现在： l = max(arr[i],l+arr[i]) g = max(l,g) 先求局部最大值，而全局最大值出自局部最大值 MSS对应的start位置sum从第一个碱基开始累加求和，当sum到达最小值时，对应的下一个碱基即为MSS的start起始位置 MSS对应的end位置g第一次达到全局最大值时对应的碱基即为MSS的end位置 参考（1）最大连续子序列和（算法） （2）Maximum Subarray 最大连续子串python实现【medium】 （3）最大子数组和（最大子序列和 | 连续子数组最大和）]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lncRNApipe安装及使用]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2018%2F03%2F12%2FlncRNApipe%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[lncRNApipe安装及使用 lncRNApipe介绍biocoder/Perl-for-Bioinformatics 对应文献：Methods for distinguishing between protein-coding and long noncoding RNAs and the elusive biological purpose of translation of long noncoding RNAs lncRNApipe安装perl lncRNApipe –setup –setup-compiler CC=g++ Perl-for-Bioinformatics-master.zip —–325M 报错：gcc:error:unrecognized command line option ‘-fstack-protector-strong’ ‘-fstack-protector-strong’ 选项是gcc4.9以后的版本才加入的，也就是说需要安装gcc4.9以后的版本才可以编译通过 How to install XML::Parser without expat-devel? Download from: http://sourceforge.net/projects/expat/files/expat/ 1234567891011121314151617181920install_dir=/home/wangdong/localmkdir -p $install_dir/expattar zxf /[where-ever]/expat-2.1.0.tar.gz -C $install_dir/expatcd $install_dir/expat/expat-2.1.0perl ./configure --prefix=$install_dir/expat LDFLAGS=-L/$install_dir/expat/lib makemake installhttp://search.cpan.org - search for and download - XML::Parserinstall_dir=/home/wangdong/localmkdir -p $install_dir/XML-parserwget http://search.cpan.org/CPAN/authors/id/T/TO/TODDR/XML-Parser-2.44.tar.gztar zxf XML-Parser-2.44.tar.gz -C $install_dir/XML-parsercd $install_dir/XML-parser/XML-Parser-2.44perl ./Makefile.PL EXPATLIBPATH=$install_dir/expat/lib EXPATINCPATH=$install_dir/expat/includemakemake testmake install libexpat/libexpat（会报错） lncRNApipe使用time perl $lncRNApipe --run $merge/lncRNApipe \ --cuffcmp &apos;-r &apos;$ref_mRNA_gtf&apos; -s &apos;$ref_hg38&apos; &apos;$merge&apos;/All_sample_assemble_merge.gtf&apos; \ --cat-ncRNAs &apos;-sample-names &quot;All_sample&quot; -ov 80 -fpkm 2 -len 200 -max-len 10000 -min-exons 1 -antisense&apos; \ --get-uq-feat &apos;-sf &apos;$lncRNA_bed&apos;&apos; \ --fetch-seq &apos;-db hg38&apos; \ --cpc \ --rna \ --cpu 16 \ --inf &amp;&gt;$merge/lncRNApipe.run.log 通过以上方法安装该软件过于麻烦，如果只是使用该软件的鉴定lncRNA过程的相关脚本（cuffcompare, categorize_ncRNAs.pl, get_unique_features.pl, fetch_seq_from_ucsc.pl, RNAfold, Infernal and Coding Potential Calculator (CPC)），其实可以只有安装一些perl模块和软件即可。 需要安装的软件或者模块 cuffcompare在cufflinks软件里 Perl脚本categorize_ncRNAs.pl，get_unique_features.pl, fetch_seq_from_ucsc.pl需要的模块在脚本开头都已经指明，用cpan安装即可，需要注意的是唯有一个该包自定义的perl模块需要手动安装 git clone https://github.com/biocoder/Perl-for-Bioinformatics.gitcd IO-Routineperl Makefile.PL PREFIX=/home/wangdong/perl/lib/site_perl/5.26.1/x86_64-linux LIB=/home/wangdong/perl/lib/site_perl/5.26.1/x86_64-linuxmakemake install refGene.txt数据下载及处理wget http://hgdownload.cse.ucsc.edu/goldenPath/hg38/database/refGene.txt.gzungz refGene.txt.gzcat refGene.txt|awk ‘BEGIN{FS=”\t”;OFS=”\t”}{print $2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16}’&gt;hg38_refGene.txt ps:lncRNApipe也没有说清楚refGene.txt的具体格式是什么，只说是Gene Prediction format，原因是refGene_to_bed.pl脚本有说明，该脚本需要从refGene.txt提取chrom strand txStart txEnd name2这些列转换为bed文件]]></content>
      <categories>
        <category>NGS</category>
      </categories>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gcc5.2编译安装]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2018%2F02%2F13%2Fgcc5.2%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[gcc5.2编译安装 安装过程cd /home/wangdong/local wget http://www.netgull.com/gcc/releases/gcc-5.2.0/gcc-5.2.0.tar.gz tar xzf gcc-5.2.0.tar.gz cd gcc-5.2.0 ./contrib/download_prerequisites cd .. mkdir objdir cd objdir $PWD/../gcc-5.2.0/configure --prefix=$HOME/gcc-5.2.0 --enable-languages=c,c++,fortran,go --disable-multilib make make install echo &apos;export PATH=~/gcc-5.2.0/bin:$PATH&apos;&gt;&gt;~/.bashrc echo &apos;export LD_LIBRARY_PATH=~/gcc-5.2.0/lib:$LD_LIBRARY_PATH&apos;&gt;&gt;~/.bashrc echo &apos;export LD_LIBRARY_PATH=~/gcc-5.2.0/lib64:$LD_LIBRARY_PATH&apos;&gt;&gt;~/.bashrc source ~/.bashrc cc与gcccc、gcc、g++、CC的区别概括 gcc是C编译器；g++是C++编译器；linux下cc一般是一个符号连接，指向gcc；gcc和g++都是GUN（组织）的编译器。cc来自于昂贵的Unix系统，cc是商业软件。 对于cc设置软连接：ln -s gcc cc ps在脚本./contrib/download_prerequisites中自动在gcc安装目录内安装了 MPFR=mpfr-2.4.2 GMP=gmp-4.3.2 MPC=mpc-0.8.1 isl=isl-0.14等依赖，并设置了软连接，如果安装过程ftp连接不上，可以自行下载这四个包，放在gcc-5.2.0目录下，注释掉./contrib/download_prerequisites脚本内的wget 行即可 多核处理器下提高make的效率make的-j参数可以使make进行并行编译。make该参数的帮助如下： -j [N], –jobs[=N] Allow N jobs at once; infinite jobs with no arg虽然-j 可以大大缩短gcc编译时间,但注意：make -j命令并不是任何情况下都可以用的，在存在编译依赖的情况下，单核编译还是一种比较稳妥的方案。 参考（1）Installing GCC without Root Privileges（推荐） （2）Install gcc-5.2.0 without root （3）Install Latest version of gcc and gcc-c++ on CentOS 6.7 from source code （4）一文解决C程序的编译问题（推荐）]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RNA-seq鉴定LncRNA概述]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2018%2F02%2F05%2FRNA-seq%E9%89%B4%E5%AE%9ALncRNA%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[RNA-seq鉴定LncRNA概述：lncRNA简介，分析pipline，分析软件，结果评估指标 lncRNA简介&emsp;&emsp;人类细胞中仅有少数转录生成的RNAs可作为蛋白质合成的模板。其余的RNA被称为非编码RNAs (ncRNAs)，它们位于编码蛋白的基因之间，其中长度超过200nt的ncRNAs称为lncRNAs(Long non-coding RNAs) &emsp;&emsp;LincRNA序列的获取有以下两种途径：①可参考LncRNA (Long non-coding RNA)序列的获取，只是在获得LncRNA的序列后需确认该LncRNA为LincRNA；②通过检索LincRNA的研究论文获取其序列，很多LincRNA的序列会在附件中包含或者文章提供链接地址。 即lncRNA是一大类，长度超过200nt的称为LncRNA，位于基因间区的称为LincRNA. lncRNA特点 lincRNA典型的表现出显著的组织和细胞特异性表达 lincRNA可能与其共表达的蛋白编码基因具有共同的生物学功能 lincRNA能折叠成热力学稳定的二级或者更高级的结构，这是其发挥功能的基础 相当大比例的lncRNA是编码基因的反义转录本或者与编码基因的外显子区正义方向部分重叠。 RNA-seq分析pipline RNA-Seq guide (RNA-seqlopedia) 转录组内的RNA，按照polyA形态： 带polyA的RNA(mRNA和大部分的lncRNA) 不带polyA的RNA(小RNA和小部分的lncRNA) 取样实例：晚期肝癌病人的肝组织（共四个） 癌旁组织（N） 原发灶（P） 转移灶（M） 门脉血栓转移灶（V） twbattaglia/RNAseq-workflow griffithlab/rnaseq_tutorial,&emsp;&emsp;文章 ,&emsp;&emsp; Lectures Expression 重复文章 “RNA-seq的转录水平表达分析” 该流程不适用小样本数据：For small sample sizes (n &lt; 4 per group), it is often better to perform regularization. This can be done using the limma package in Bioconductor RNACocktail：A comprehensive framework for accurate and efficient RNA-Seq analysis， 文章 RNA-seq workshops and online tutorials LncRNA注释GTF文件及fasta文件 参考基因组fa及GTF文件下载：链接 Homo_sapiens.GRCh38.dna.primary_assembly.fa Homo_sapiens.GRCh38.92.gtf 参考基因组建立索引： which hisat2_extract_exons.py $known_coding_gtf &gt; genome.exonwhich hisat2_extract_splice_sites.py $known_coding_gtf &gt; genome.sstime hisat2-build -p 8 $ref_hg38 –ss genome.ss –exon genome.exon genome_tran GENCODE &emsp;&emsp; 2. NONCODE ps: NONCODE has updated to NONCODEv5. NONCODE2016 website has been moved to http://www.bioinfo.org/NONCODE2016 lncRNA建立索引： which hisat2_extract_exons.py $lncRNA_gtf &gt; NONCODE2016_human.exonwhich hisat2_extract_splice_sites.py $lncRNA_gtf &gt; NONCODE2016_human.sstime hisat2-build -p 8 $lncRNA_ref –ss NONCODE2016_human.ss –exon NONCODE2016_human.exon NONCODE2016_index &emsp;&emsp;ENCODE计划揭示了大约76%的人类基因组转录产生非编码蛋白的RNA分子，其中包括大约10000lincRNAs。NOCODE最新版数据库收录了&gt;30000个人的lincRNAs和 &gt;20000 小鼠的lincRNA。 RNA-seq分析软件 RNA-Seq analysis common tools 推荐文献：Gaining comprehensive biological insight into the transcriptome by performing a broad-spectrum RNA-seq analysis 基因组和转录组比对基因水平定量官网：HTSeq: Analysing high-throughput sequencing data with Python 使用：使用HTSeq进行有参转录组的表达量计算（推荐） 扩展阅读： featureCounts or htseq-count? htseq-counts跟bedtools的区别 stringTieNCBI-Hackathons/RNA_mapping &emsp;&emsp;RNA-Seq基因组比对工具HISAT2：HISAT2是TopHat2/Bowti2的继任者，使用改进的BWT算法，实现了更快的速度和更少的资源占用，作者推荐TopHat2/Bowti2和HISAT的用户转换到HISAT2。官网 gene annotation 一般选择 RefSeq 或者 Ensembl，这里，我们的参考基因组fasta文件和基因注释文件都选择 Ensembl的hg38版本（release-91），其ftp地址为：http://asia.ensembl.org/info/data/ftp/index.html wget ftp://ftp.ensembl.org/pub/release-91/fasta/homo_sapiens/dna/Homo_sapiens.GRCh38.dna.primary_assembly.fa.gz wget ftp://ftp.ensembl.org/pub/release-91/gtf/homo_sapiens/Homo_sapiens.GRCh38.91.chr.gtf.gz tophat(基于python2.*)tophat 一些小错误 #genome index samtools faidx Homo_sapiens.GRCh38.dna.primary_assembly.fa bowtie2-build Homo_sapiens.GRCh38.dna.primary_assembly.fa hg38_genome #transcriptome-index tophat -G $ref_mRNA_gtf –transcriptome-index=$tophat_transcriptome_index $bowtieGenomeIndex PS: Please note that it is highly recommended that a FASTA file with the sequence(s) the genome being indexed be present in the same directory with the Bowtie index files and having the name .fa. If not present, TopHat will automatically rebuild this FASTA file from the Bowtie index files 比对质量评估 RSeQC: An RNA-seq Quality Control Package pip2.7 install RSeQC 转录本重构 转录本构建效果评估—评价指标： 多外显子比率 转录本长度 转录本的可变剪切数目 对已知基因的覆盖程度 基因数目 转录本数目 多外显子比率 多外显子转录本数目 5-8万 &gt;10万 30%-50% 5万 对已知编码基因的覆盖程度：&gt;60% 使用StringleTie的-个G模式构建转录本的输出文件主要有： .gtf文件:记录组装的转录本信息 gene_abundances.tsv文件：以tab键分割的记录基因丰度信息 在使用-B 参数下，生成*.ctab文件：用于下游Ballgown软件做差异表达分析的输入文件 输出结果具体解释可查看StringTie官网的output部分 合并转录本cole-trapnell-lab/cufflinks 可以直接下载解压预编译好的版本，省去安装 Boost C++ libraries的麻烦。在一下链接中选择linux版即可：cufflinks 事实上，对于多个样本构建的多套转录本，如何得到统一的一套转录本，有下面三种方法： 1 在转录本拼接之前，把各样本的比对bam文件合并，然后用合并的bam跑cufflinks 2 每个样本的比对bam文件分别单独跑cufflinks，各样本的转录本构建后，再用cuffcompare合并为一套转录本。 3 每个样本的比对bam文件分别单独跑cufflinks，各样本的转录本构建后，再用cuffmerge合并为一套转录本。 这三种做法区别在于： 第一种方法流程相对简单，所有的工作都抛给cufflinks一人完成，你都不需要知道cuffmerge、cuffcompare的用法。貌似是种完美解决方案。但很大的问题是：cufflinks能处理得了最终合并的bam吗？对于小物种的样本还可以，但对于人，若是7，8个样本合成的bam，cufflinks吃不销！ 第二和三种方法是类似的，都是在保留可变剪切结构的前提下，将转录本合并。不同的是，cuffcompare只有A、B两条转录本结构相同的时候，才将A、B合并。而cuffmerge是A、B某些部分互相overlap，就将它俩合并。事实上，cuffmerge再做合并的时候，是把overlap的transfrag重新调用了cufflinks，合成一个transfrag。 第二和三种方法还有一个很大的不同是，cuffmerge可以带上参考注释有参考的进行合并，而cuffcompare不能如此。这是cuffmerge对cuffcompare的一个优势。 因此，我认为第三种方法比第二种方法是最接近于第一种方法，而第一种方法的可实现性较差，在现有条件，最完美的解决方案就是第三种方法：每个bam单独跑cufflinks，跑完的结果再用cuffmerge合并。 参考：转录组测序分析中cufflinks的使用及问题 鉴定novel lncRNA step1: 对所有样品拼接得到的转录本使用cuffcompare软件进行合并，筛除链方向不明的转录本； step2: 选择转录本长度&gt;=200bp，Exon个数&gt;=2的转录本； step3: 通过cufflinks计算每条转录本的reads覆盖度，选择至少在一个样品中覆盖度&gt;=3的转录本； step4: 若该物种存在已知lncRNA数据，首先通过cuffcompare软件，将前一步得到的转录本与已知lncRNA进行比较，得到与已知lncRNA相同的转录本。这一部分转录本直接纳入最终的lncRNA集，不再进行后续筛选。之后，通过与该物种已知非lncRNA及非mRNA类型（rRNA,tRNA,snRNA,snoRNA,pre-miRNA,pseudogenes等）的转录本进行比较，筛除那些与以上已知转录本相似或相同的转录本。若无已知lncRNA数据，则直接进行与该物种已知非lncRNA及非mRNA类型转录本的比较； step5: 通过与已知mRNA进行比较，并利用cuffcompare分析结果中的class_code(http://cole-trapnell-lab.github.io/cufflinks/cuffcompare/index.html#transfrag-class-codes)信息筛选候选lincRNA，intronic lncRNA, anti-sense lncRNA类型的转录本。 class_code Priority Code Description 1 = Complete match of intron chain 2 c Contained 3 j Potentially novel isoform (fragment): at least one splice junction is shared with a reference transcript 4 e Single exon transfrag overlapping a reference exon and at least 10 bp of a reference intron, indicating a possible pre-mRNA fragment. 5 i A transfrag falling entirely within a reference intron 6 o Generic exonic overlap with a reference transcript 7 p Possible polymerase run-on fragment (within 2Kbases of a reference transcript) 8 r Repeat. Currently determined by looking at the soft-masked reference sequence and applied to transcripts where at least 50% of the bases are lower case 9 u Unknown, intergenic transcript 10 x Exonic overlap with reference on the opposite strand 11 s An intron of the transfrag overlaps a reference intron on the opposite strand (likely due to read mapping errors) 12 . (.tracking file only, indicates multiple classifications) 转录水平本定量lincRNA鉴定及功能注释 CNCI：文献，github仓库 CPC ncFANs： 文献， github仓库 差异表达分析RNA-Seq workflow: gene-level exploratory analysis and differential expression cuffdiff -L 选项有两种写法：偶数个样本： 奇数个样本： ballgown安装需要先安装libxml2 wget http://xmlsoft.org/sources/old/libxml2-2.7.1.tar.gz untargz libxml2-2.7.1.targz cd libxml2-2.7.1 ./configure --prefix=/home/wangdong/softwares/libxml2 make &amp;&amp; make install echo &apos;export PATH=/home/wangdong/softwares/libxml2/bin:$PATH&apos;&gt;&gt;~/.bashr echo &apos;export LD_LIBRARY_PATH=/home/wangdong/softwares/libxml2/lib:$LD_LIBRARY_PATH&apos;&gt;&gt;~/.bashrc echo &apos;export PKG_CONFIG_PATH=/home/wangdong/softwares/libxml2/lib/pkgconfig:$PKG_CONFIG_PATH&apos;&gt;&gt;~/.bashrc ps:安装 dplyr包之前需要安装assertthat包 可参考：链接 使用可参考：链接 ps:pheno_data里面第一列样本名需要和ballgown下面的文件夹的样本名一样，且先后顺序保持一致，不然会报错 富集分析Gene ontology or pathway analysis for differentially expressed genes, this step is only applicable for protein coding genes 参考（1） Identification and function annotation of long intervening noncoding RNAs （2）转录组分析工具哪家强？]]></content>
  </entry>
  <entry>
    <title><![CDATA[查看R包源码及linux下编译安装R]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2018%2F01%2F28%2F%E6%9F%A5%E7%9C%8BR%E5%8C%85%E6%BA%90%E7%A0%81%E5%8F%8Alinux%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85R%2F</url>
    <content type="text"><![CDATA[查看R包源码，毕竟看优秀的源代码才能学得更快，为开发自己的R包打基础；同时由于R会将数据一次性读入内存的特性，实际分析数据时，选择linux集群将更合适，所以有必要在linux环境下编译安装R R相关资源（1）R-Forge：offers a central platform for the development of R packages, R-related software and further projects. （2）rseek：RSeek.org R-project Search Engine （3）The Yhat Blog: machine learning, data science, engineering(推荐) 查看R包函数源码&emsp;&emsp;首先，一个扩展包中定义的函数有区分公开和不公开的，会在扩展包根目录下的NAMESPACE文件中定义是否Export，如果一个函数没有Export，则为不公开的函数，只能在包内部调用。 &emsp;&emsp;lattice::qq是一个Generic Function，就像是plot，summary等函数，是由对象的class来确定实际执行的函数（例如对于data frame,执行summary时会执行summary.data.frame，对于lm会执行summary.lm等等，都不是则会执行summary.default）这是R S3 面向对象系统的设计。因此看到qq源代码时只能看到 UseMethod(“qq”)，还要看到哪些class实现了qq方法，而lattice并没有把这些实现给Export &emsp;&emsp;想要看到源代码本可以直接在Console中输入函数名称或者在RStudio中函数上按F2即可，即 lattice::qq，但是这只是看到了Generic Function的源代码，如果需要看到具体的执行函数的源代码，那么就需要获得整个包的源码。可以到CRAN的页面CRAN - Package lattice 中下载Package source那个链接，这里面包含了整个lattice的源代码：http://cran.r-project.org/src/contrib/lattice_0.20-29.tar.gz 转自知乎：任坤 链接 以pheatmap包及其函数为例（1）在Rstudio下查看 ??pheatmap 上述方法只能查到该包的Generic Function,对于不公开的内部函数只能下载源码包查看 （2）找到R CRAN的相关源码包（.tar.gz） 例如：https://cran.r-project.org/web/packages/ggplot2/ 不同包只需要更改最后包名即可 linux下源码安装R-3.4.4建议先升级gcc可参考gcc5.2编译安装，因为需要相应的动态链接库。 安装依赖的包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#新建一个文件夹，然后把需要依赖的组件安装这个路径下mkdir -p $HOME/softwares/packagescd $HOME/softwares/packages##bzip2-1.0.6 wget https://link.zhihu.com/?target=http%3A/www.bzip.org/1.0.6/bzip2-1.0.6.tar.gz untargz bzip2-1.0.6.tar.gz cd bzip2-1.0.6 修改bzip2-1.0.6的"Makefile"文件： CC=gcc -fPIC &lt;&lt; 新增 -fPIC，默认是64位编译的； AR=ar RANLIB=ranlib LDFLAGS= BIGFILES=-D_FILE_OFFSET_BITS=64 CFLAGS=-fPIC -Wall -Winline -O2 -g $(BIGFILES) # 这里也可以加上 make -f Makefile-libbz2_so make clean &lt;------------保守建议，还是clean一下 make make install PREFIX=$HOME/softwares/packages # prefix表示的安装的路径前缀## curl-7.59 wget https://curl.haxx.se/download/curl-7.59.0.zip unzip curl-7.59.0.zip cd curl-7.59.0 ./configure --prefix=$HOME/softwares/packages # 这个是之前设置的packages路径 make -j3 &amp;&amp; make install## pcre-8.41.tar.gz wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.42.tar.gz tar -xvf pcre-8.41.tar.gz cd pcre-8.42 ./configure --enable-utf8 --prefix=$HOME/softwares/packages # 这个是之前设置的packages路径，一定要设置enable-utf8; make &amp;&amp; make install## xz-5.2.3.tar.gz 下载路径：https://sourceforge.net/projects/lzmautils/files/xz-5.2.3.tar.gz/download tar xzvf xz-5.2.3.tar.gz cd xz-5.2.3 ./configure --prefix=$HOME/softwares/packages make -j3 &amp;&amp; make install## zlib-1.2.8.tar.gz wget https://www.zlib.net/fossils/zlib-1.2.8.tar.gz --no-check-certificate tar xzvf zlib-1.2.8.tar.gz cd zlib-1.2.8 ./configure --prefix=$HOME/softwares/packages make &amp;&amp; make install 设置环境变量123456echo 'export PATH=$HOME/softwares/packages/bin:$PATH'&gt;&gt;~/.bashrcecho 'export LD_LIBRARY_PATH=$HOME/softwares/packages/lib:$LD_LIBRARY_PATH'&gt;&gt;~/.bashrc echo 'export CFLAGS="-I$HOME/softwares/packages/include"'&gt;&gt;~/.bashrc echo 'export LDFLAGS="-L$HOME/softwares/packages/lib"'&gt;&gt;~/.bashrcsource ~/.bashrc 安装R3.4.41234567891011121314151617181920212223wget https://mirrors.tuna.tsinghua.edu.cn/CRAN/src/base/R-3/R-3.4.4.tar.gzuntargz R-3.4.4.tar.gzcd R-3.4.4./configure --prefix=$HOME/softwares/packages/R --enable-R-shlib --with-readline=yes --with-libpng=yes --with-x=no # --enable-R-shlib一定要设置，否则安装不上Rserve; prefix是安装路径，可以自定义；#当前解压目录下编译、安装make &amp;&amp; make install#离开解压目录，进入安装成功目录，进行检查是否成功cd /home/wangdong/R/bin./R#添加环境变量echo 'export PATH=/home/wangdong/R/bin:$PATH'&gt;&gt;~/.bashrcexport R_LIBS=/home/wangdong/R/lib64/R/library #设置R包安装路径source ~/.bashrc## R3.5.0的安装 参考链接：https://www.jianshu.com/p/10a662678cdb依赖如上，但在安装R时注意：./configure --with-cairo=yes --with-libpng=yes --with-libtiff=yes --with-jpeglib=yes --enable-R-shlib --with-readline=yes --with-x=no --prefix=/lustre/home/bioxsyy/software/R-3.5/R 使用Anaconda 安装R 与Rstudio server安装Rstudio server 链接 使用 安装packages方法一：每次安装包时指定镜像 查看所有镜像：chooseCRANmirror() 选择镜像：chooseCRANmirror(ind=36) 通过getOption(“repos”)函数知道目前的镜像网站是哪里 所有的镜像网站网址在本地的一个csv cd /home/wangdong/R/R-3.1.2/doc less CRAN_mirrors.csv install.packages(‘plyr’, repos=’http://mirrors.tuna.tsinghua.edu.cn/CRAN/‘) 方法二：修改配置文件Rprofile.site (in the directory /your-R-installation/etc/ , eg R-2.14.0/etc) cd /home/wangdong/R/R-3.1.2/etc vim repositories #set a CRAN mirror local({r &lt;- getOption(&quot;repos&quot;) r[&quot;CRAN&quot;] &lt;- &quot;http://mirrors.tuna.tsinghua.edu.cn/CRAN/&quot; options(repos=r)}) 备用镜像： http://mirror.bjtu.edu.cn/cran/ http://mirrors.ustc.edu.cn/CRAN/ http://mirrors.xmu.edu.cn/CRAN/ 安装bioconder123source("http://bioconductor.org/biocLite.R")options(BioC_mirror="http://mirrors.ustc.edu.cn/bioc/")biocLite() 如果安装bioconductor软件包安装不上，可以先update.packages()，然后选择镜像。 设置环境变量R中用.libPaths()函数查看lib路径，如果有多个lib,install.packages()默认是安装在第一个目录下 修改.bashrc文件中R lib路径的环境变量（R_LIBS）：export R_LIBS=/home/wangdong/R/lib64/R/library，就能设定自己lib的默认目录，即使使用的R是别人安装的或是集体共用的，也能拥有自己的library 终端直接调用R脚本/home/wangdong/R/bin/Rscript 或者 Rscript test.R error while loading shared libraries: libicuuc.so.50解决： 在登陆节点启动R没问题，在计算节点报上述错误，解决： ls -l /usr/lib64 | grep libicui* 找到相应文件，将其复制到自己的目录，然后设置软连接，并设置环境变量LD_LIBRARY_PATH 参考（1）R中查看函数源代码 （2）R中查看函数源代码 （3）linux下源码安装R-3.1.2.tar.gz和RStudio开发工具 （4）CentOS 下 R 的安装 （5）How to select a CRAN mirror in R （6）linux下R3.4.1的安装手册（推荐） （7）Building R on RedHat Linux 6 （8）Linux下的R安装、配置与测试 （9）configure error installing R-3.3.2 on Ubuntu: checking whether bzip2 support suffices… configure: error: bzip2 library and headers are required]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[qPCR结果分析及非参数检验]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2018%2F01%2F28%2FqPCR%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90%E5%8F%8A%E9%9D%9E%E5%8F%82%E6%95%B0%E6%A3%80%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[qPCR结果分析及非参数检验 相对表达量计算一：⊿Ct如何计算，公式推导 (1) 一般，我们都假设扩增效率为1，也就是每个循环增加一倍。 (2) 当产物量达到同一水平的时候，但Ct值不同，其原因就在于期初的模板量的差距，而当检测样本和内参基因的产物量相同的时候，找出他们模板量的比值差的话，就需要做一下除法，也就是下面这样： 二：具体例子（⊿⊿Ct计算） 一般在进行qPCR实验时，都会设计独立三次重复试验，每次作3个复孔，然后根据下列公式先分别计算试验组和对照组的ΔCt值 ΔCt试验=Ct目的基因-Ct内参基因 ΔCt对照=Ct目的基因-Ct内参基因 注：Ct目的基因和Ct内参基因是三个复孔Ct值求得的均值 ΔΔCt=ΔCt试验-ΔCt对照，相对表达量=2^(-⊿⊿Ct) &emsp;&emsp;相对表达量是指目的基因在试验组中的表达是目的基因在对照组表达的多少倍。在P&lt;0.05的情况下，如果2-ΔΔCt小于1说明目的基因在试验组中表达下调，大于1说明目的基因在试验组中表达上调。否则表达无差异。 组间差异非参数检验原始数据处理（EXCEL）： &emsp;&emsp;如果数据无法满足t检验或ANOVA的参数假设，可以转而使用非参数方法。若两组数据独立， 可以使用Wilcoxon秩和检验（更广为人知的名字是Mann-Whitney U检验）来评估观测是否是从相同的概率分布中抽得的（即，在一个总体中获得更高得分的概率是否比另一个总体要大）。调用格式为： wilcox.test(y ~ x, data，exact=FALSE) 其中的y是数值型变量，而x是一个二分变量。 Wilcoxon符号秩检验是非独立样本t检验的一种非参数替代方法。它适用于两组成对数据和无法保证正态性假设的情境。调用格式与Mann-Whitney U检验完全相同，不过还可以添加参数paired=TRUE。 绘制箱图1234567#qPCR_barplot.Rsetwd("F:/R working directory/qPCR")qPCR&lt;-read.csv("miRNA_qPCR_plot.csv",header=TRUE,check.names = FALSE)library(ggplot2)p&lt;-ggplot(data=qPCR, aes(x=miRNA,y=value))+geom_boxplot(aes(fill=sample))p + facet_wrap(~ miRNA, scales="free") 参考（1）如何分析你凌乱不堪的qPCR数据（推荐） （2）分享自己关于qPCR（RT-PCR）数据相对定量的分析方法与经验！ （3）△△CT数据处理 （4）相对荧光定量数据处理 （5）R语言可视化学习笔记之添加p-value和显著性标记（推荐） （6）添加线条来连接比较的两组，这一功能已由包ggsignif实现（推荐） （7）非参检验R语言实现 （8）Wilcoxon-Mann-Whitney秩和检验/rank sum test（或test U） （9）荧光定量PCR应用指南{推荐} （10） Mann Whitney U Test (Wilcoxon Rank Sum Test) （11）推荐：qRT-PCR相对定量计算详解]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IGV批量查看变异]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2018%2F01%2F26%2FIGV%E6%89%B9%E9%87%8F%E6%9F%A5%E7%9C%8B%E5%8F%98%E5%BC%82%2F</url>
    <content type="text"><![CDATA[IGV批量查看变异并过滤 IGV可视化准备Nature biotechnology文献：Integrative Genomics Viewer Downloads IGV ; &emsp;igvtools为一些数据可视化预处理程序 PS:igv 要求java 1.8 ,安装java1.8可参考链接 export JAVA_HOME=/home/wangdong/softwares/java1.8/jdk1.8.0_172 export JRE_HOME=/home/wangdong/softwares/java1.8/jdk1.8.0_172/jre export PATH=$PATH:/home/wangdong/softwares/java1.8/jdk1.8.0_172/bin export CLASSPATH=./:/home/wangdong/softwares/java1.8/jdk1.8.0_172/lib:/home/wangdong/softwares/java1.8/jdk1.8.0_172/jre/lib IGV可视化数据准备 不是什么数据都可以拿IGV看的，参考基因组必须为FASTA格式； IGV只是负责将比对结果可视化，并没有比对过程，所以不能直接载入reads； 需要将待比对的reads与前面指定的参考基因组用bwa进行比对； 比对后的sam文件也不能直接载入，要转bam；bam排序；bam建索引（可以一步完成）； 需要两个文件.bam文件和.bam.bai文件 IGV批量查看变异生成批量查看.bat文件IGV批量运行的.bat文件命令参数及例子：Controlling IGV through a Port ,&emsp;&emsp; a batch file example &emsp;&emsp; IGV-snapshot-automator项目 使用命令： java -Xmx1024M -jar ~/bin/igv-2.3.52/igv.jar -b IGV_screenshot.bat VNC Viewer使用&emsp;&emsp;VNC (Virtual Network Console)是虚拟网络控制台的缩写。它 是一款优秀的远程控制工具软件，由著名的 AT&amp;T 的欧洲研究实验室开发的。VNC 是在基于 UNIX 和 Linux 操作系统的免费的开源软件。VNC基本上是由两部分组成：一部分是客户端的应用程序(vncviewer)；另外一部分是服务器端的应用程序(vncserver)。Download VNC Viewer ，解压后按照README安装即可 Linux环境VNC服务安装、配置与使用 工作流程： 服务器端启动VNC Server，使用命令vncserver,之后输入密码并确认，之后获得数字1，表示vncserver创建的第一个vnc viewer用户； 在win7的客户端创建连接即可 之后点击igv.sh运行igv,在Tools的Run Batch Script，导入.bat文件即可！ 变异的过滤&emsp;&emsp;在对Func.refGene，ExonicFunc.refGene，1000g2015aug_eas等进行hard filter后，一般全外显子测序找到的突变依然还有一两百个，接下来需要通过直观的可视化，验证SNP/SNV calls和结构重排，进一步去除假阳性的结果。IGV Tutorial（推荐） 查看技巧 File—&gt;Load from Server可以加载许多tracks 在reads区右键可以选择不同的查看方式 可以同时开多个igv.sh或者将IGV_snapshots.bat文件合并，并删除掉除最后一个之外的所有exit语句 maxPanelHeight 设置很重要，默认800，但是igv截图不全，所以设置为10000 通过命令行自动截图服务器上vncserver源码下载链接,选择Generic scripts x64，然后下载即可，安装可查看README文件。具体可参考（1）vnc 源码安装； （2）linux命令：VNC服务的配置及使用 开启vncserver 设置环境变量DISPLAY: export DISPLAY=:1 (你vnc开的几就写几) 修改igv.sh中-Xmx4000m，增大igv分配内存 igv.sh -b IGV_snapshots.bat 过滤标准 高质量的SNVs和SNPs要求在所有的reas中High base qualities，并且不能在reads的末端； Good mapping quality of reads, no strand bias, allele frequency consistent with heterozygous mutation Important metrics for evaluating the validity of SNVs: Coverage Amount of support Strand bias / PCR artifacts Mapping qualities Base qualities 通过Coverage track查看比对情况，没有比对上参考基因组的碱基将在Coverage track和data panel以不同颜色高亮显示； 低质量的碱基calls是半透明的（faint,semi-transparent） 区分SNP突变和错配： SNP突变如果是杂合，会在Coverage track处显示红蓝box,当鼠标悬停在上面时显示allele counts 和frequencies。可以在此处右键，选择sort alignments by &gt; base查看，以此根据碱基的透明度确定SNP碱基call的质量； 而错配的情况在在Coverage track处是没有红蓝box的。通过在此处右键，选择shade base by quality使得用半透明颜色表示的低质量碱基全部高亮显示，方便查看；接着选择Sort alignments by &gt; read strand，然后Color alignments by &gt; read strand，以此确定是否存在stand bias。 Important metrics for evaluating SVs: Coverage Insert size Read pair orientation 具体使用可查看：IGV Lecture - Long, from Broad Institute ，也包括了查看RNA-seq比对情况的操作 vncviewer 连接上后黑屏解决参考：vnc viewer连接黑屏 （1）修改/home/wangdong/.vnc/xstartup文件 vi /home/wangdong/.vnc/xstartup ##如果使用的是gnome图像界面，则需要注释掉以下两行, #xterm -geometry 80x24+10+10 -ls -title &quot;$VNCDESKTOP Desktop&quot; &amp; #twm &amp; ##并添加以下这行： gnome-session &amp; （2）改变xstartup的权限 chmod 777 /home/wangdong/.vnc/xstartup ps: 首选在图形桌面用命令行运行igv.sh,再点击igv.sh运行 命令行下批量运行IGV 开启Xmanager - Passive 在Xshell5的Poperties—&gt;Tunneling—–&gt;Forward X11 connections to 命令行下使用igv.sh -b IGV_snapshots.bat igv命令行参数可查看：链接 ps: windows下需要提前安装好igv 参考（1）可视化工具之 IGV 使用方法 （2）IGV_Batch_Screenshots.md （3）如何使用VNC Viewer连接远程CentOS服务器 （4）Quick Visual Inspection Of Mapping Images For A List Of Regions （5）Unable to adjust image height via batch script （6）Xshell显示图形化界面]]></content>
      <categories>
        <category>NGS</category>
      </categories>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计miRNA的qPCR引物]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2018%2F01%2F24%2F%E8%AE%BE%E8%AE%A1miRNA%E7%9A%84qPCR%E5%BC%95%E7%89%A9%2F</url>
    <content type="text"><![CDATA[在线设计miRNA的qPCR引物 miRNA简介&emsp;&emsp;microRNAs(miRNAs)是指长度在20-24nt的非编码RNAs,其可通过影响转录的mRNAs的转录和稳定性，参与细胞组织的转录后基因表达调控。miRNAs由RNA聚合酶II转录为带帽子和多聚腺苷酸的初级转录物（pri-miRNA）的一部分（有的编码蛋白，有的是非编码的）。初级转录物被Drosha核糖核酸酶III切割产生大约70nt的茎环前体miRNA(pre-miRNA)，其被细胞质Dicer 核糖核酸酶裂解产生成熟的miRNA和反义miRNA star(miRNA*)。成熟的miRNA包含在RNA诱导的沉默复合物（RISC)中。通过不完全的碱基配对，其能够识别靶标mRNA的3’端，并通常导致的结果是翻译被抑制或者靶标mRNA的去稳定化。RefSeq代表预测的microRNA的茎环结构。 miRNA主要公共数据库miRBase中已经有1W多条来自不同物种的miRNA序列 miRNA检测引物设计引物有两种类型，一个是poly加尾，一个是加茎环结构。PCR荧光定量又分为探针法和染料法： Poly方法的话，引物设计简单，但是引起非特异性扩增的可能性大。 探针法特异性更高，但是价格高，不适合大批量的实验。 加Poly方法miRNA qRT-PCR Detection Kit中已提供有miRNA检测的Reverse 通用引物：“Universal adaptor PCR Primer”，Forward 检测引物需客户参考miRNA序列自行设计。因为miRNA序列长度一般都在18～24nt之间，所以其检测的Forward 检测引物一般都直接选用其miRNA序列或为增加其检测的特异性而特殊设计的序列：如有的miRNA GC含量偏高或引物易形成引物二聚体，其引物可为miRNA 3’端去除几个碱基后整理的序列。 miRNA qPCR Forward Primer 设计举例（以小鼠mmu-miR-125b-5p为例）：在miRNA Database中查找检测的miRNA序列，如下图所示：miRNA Database 如果不确定5p或者3p哪一个有功能，要么都设计，要么参考Previous IDs并查阅文献 则其Forward 检测引物可为： Name Sequences miRNA 成熟序列 ucccugagacccuaacuuguga 上游引物序列 tccctgagaccctaacttgtga （Tm：58.8） 通用序列是：5′-GCTGTCAACGATACGCTACGTAACG-3′，也就是下游引物序列，内参一般使用U6基因： U6-Control-F 5＇ -CTCGCTTCGGCAGCACA-3＇ U6-Control-R 5＇ -AACGCTTCACGAATTTGCGT-3＇ 最后，需要检测下引物对的几个参数 NCBI 的Primer-BLAST工具 在Primer Parameters 中分别输入上下游引物，在Primer Pair Specificity Checking Parameters 的Database 中选择相应模板类型（这里我选择Refseq mRNA)，将Organism 的物种改成Mus (taxid:10088)，即小鼠。然后点击左下角的Get Primers就可以得到比对结果。 结果中主要看看是否有目的基因以外的基因出现，如果其它的基因也可以扩增出来，那说明引物特异性不好，可将引物返回我们再重新设计 如果出现的非目的条带和目的条带大小相差较大，可忽略不计，因为PCR扩增程序中延伸时间的限制，这种非目的条带扩增不出来。 另外，有些非目的条带和引物之间有四五个碱基不能互补配对，一般是扩增不出来的，尤其是这种不能互补的碱基在引物的3’端时，扩增不出的可能性更大。 Tm 融链温度 这个最关键，主要还是看这个，内参基因U6的Tm值为60，所以设计的上游引物也尽量在这个温度左右。通用引物做一些优化后为GCTGTCAACGATACGCTACCTA(去掉右端的剩下22个碱基，保持与大多成熟miRNA长度一致，然后将右端第三位的G改为C，降低通用引物的Self complementarity)。 设计过程中，通过对上游引物5’端加1-3个GC碱基或者对上游引物3’端去除几个碱基使上游引物Tm值也在60左右即可！！！ GC%值 这个标准的话是45-50左右，但是主要还是服从于调整Tm值。 Self complementarity 贴吧里说的是越低越好，我有一条引物的值为9，打算让生工重新设计，但是生工的MM说了，miRNA他的要求跟别的普通的要求不一样，好吧 最重要的特异性扩增问题：miRNA是不用检测特异性的，可以直接使用的。 参考（1）miRNA命名规范 （2）miRNA用荧光定量PCR检测的流程以及汇总 [推荐] （3）如何在pubmed中设计QPCR引物？ （4）MiRNA 引物设计与合成总结]]></content>
  </entry>
  <entry>
    <title><![CDATA[批量生成与提交shell脚本]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2018%2F01%2F21%2F%E6%89%B9%E9%87%8F%E7%94%9F%E6%88%90%E4%B8%8E%E6%8F%90%E4%BA%A4shell%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[批量生成与提交shell脚本 同一分析流程的shell脚本，通过替换样本参数，批量生成每个样本单独的piplines，从而实现批量提交，批量运行，在样本多的时候适用。 批量生成shell脚本12345678910111213141516171819202122232425262728293031323334353637383940414243#creat_multi_piplines.py 1 # -*- coding: utf-8 -*- 2 #!/home/wangdong/python/python27/bin/python2.7 3 4 import argparse,os,re,sys 5 6 #import parameters 7 parser = argparse.ArgumentParser(description='manual to this script') 8 parser.add_argument('--pipline_file', type=str, default=None) 9 parser.add_argument('--info_file', type=str, default=None) 10 parser.add_argument('--result_dir', type=str, default=None) 11 args = parser.parse_args() 12 13 14 if not os.path.exists(args.result_dir): 15 &gt;---os.mkdir(args.result_dir) 16 17 sample_pair = &#123;&#125; 18 with open(args.info_file) as f1: 19 &gt;---for line in f1: 20 &gt;---&gt;---line = line.strip() 21 &gt;---&gt;---mylist = line.split('\t') 22 &gt;---&gt;---sample_pair[mylist[1]] = [mylist[0],mylist[2]] 23 24 25 for key in sample_pair: 26 &gt;---new_pip_file_name = "&#123;&#125;.sh".format(key) 27 &gt;---result_file = open(os.path.join(args.result_dir,new_pip_file_name),'w') 28 &gt;---with open(args.pipline_file,'r') as f2: 29 &gt;---&gt;---for line in f2: 30 &gt;---&gt;---&gt;---line = re.sub("MY_SAMPLE_ID_2017", str(sample_pair[key][0]), str(line)) 31 &gt;---&gt;---&gt;---line = re.sub("MY_SAMPLE_ID_2018", str(sample_pair[key][1]), str(line)) 32 &gt;---&gt;---&gt;---line = re.sub("MY_LIBRARY_ID", str(key), str(line)) 33 &gt;---&gt;---&gt;---result_file.write(line) 34 &gt;---result_file.close() 35 &gt;---chmod_commond = "chmod +x &#123;&#125;".format(os.path.join(args.result_dir, new_pip_file_name)) 36 &gt;---os.system(chmod_commond) 37 38 39 40 if __name__ == '__main__': 41 &gt;---print('well done!') 批量提交shell脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#submit_multi_work.sh 1 #################### 2 ###function### 3 #submit_multi_work 4 ####data#### 5 #20180121 6 ####use##### 7 echo "usage: ./submit_multi_work.sh tasks_list.txt " 8 9 #################### 10 #!/bin/bash 11 set -u 12 set -e 13 set -o pipefail 14 15 if [ "$1" = "" ] ; then 16 &gt;---echo "Bad command. No tasklist file been appointed. Right format: $0 tasks_list.txt" 17 &gt;---exit 1 18 fi 19 tasks_num=`cat $1|wc -l` 20 echo "total tasks founded:$tasks_num" 21 echo "Now begin running....." 22 mix_tasks=6 #set mix tasks to assign 23 cat $1|while read line 24 do 25 &gt;---tasks=`ps -u wangdong |grep -w 'sh' | wc -l` 26 &gt;---while [ $tasks -gt $mix_tasks ] 27 &gt;---&gt;---do 28 &gt;---&gt;---sleep 20 29 &gt;---&gt;---&gt;---echo "task is running" 30 &gt;---&gt;---&gt;---tasks=`ps -u wangdong |grep -w 'sh' | wc -l` 31 &gt;---&gt;---done 32 &gt;---$line # run the COMMOND in tasklist 33 &gt;---echo "running $line"~~ 34 &gt;---sleep 5 35 done~~ 36 echo "end."~#tasks_list.txt 1 nohup /home/wangdong/projects/project4/piplines/oi_capture_process_sh/oi_1.sh &gt; oi_1.logfile 2&gt;&amp;1 &amp; 2 nohup /home/wangdong/projects/project4/piplines/oi_capture_process_sh/oi_2.sh &gt; oi_2.logfile 2&gt;&amp;1 &amp; 3 nohup /home/wangdong/projects/project4/piplines/oi_capture_process_sh/oi_3.sh &gt; oi_3.logfile 2&gt;&amp;1 &amp;#run the submit_multi_work.sh ./submit_multi_work.sh tasks_list.txt &gt; batchRun.log &amp;#simple commond cat task_list.txt |while read line;do $line;done 参考（1）批量生成脚本的技巧]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ANNOVAR进行突变注释]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2018%2F01%2F20%2FANNOVAR%E8%BF%9B%E8%A1%8C%E7%AA%81%E5%8F%98%E6%B3%A8%E9%87%8A%2F</url>
    <content type="text"><![CDATA[ANNOVAR进行突变注释 ANNOVAR简介ANNOVAR Documentation &emsp;&emsp; ANNOVAR其网页版wANNOVAR Comparison between ANNOVAR and other command line tools for variant annotation Comparison between ANNOVAR and other command line tools for variant annotation &emsp;&emsp;例如对于人的外显子组测序，可以获得4百万个SNVs(单核苷酸突变)和50万个indels(insertion or deletions)突变。对于基因间区的突变，我们对其侧翼基因感兴趣，并想知道两者之间距离；对于外显子区域的变异，我们关系其对于氨基酸的改变。 &emsp;&emsp;ANNOVAR是一个perl编写的命令行工具，能对根据hg18,hg19,hg38不同版本基因组call 出来的遗传变异进行功能注释。允许多种输入文件格式，包括最常被使用的VCF格式，只需要给出chromosome, start position, end position, reference nucleotide and observed nucleotides这6个字段。输出文件也有多种格式，包括注释过的VCF文件、用tab或者逗号分隔的text文件。 &emsp;&emsp;ANNOVAR支持三种不同形式的注释： gene-based, region-based 和filter-based. 这三种注释分别针对于每一个variant的不同方面： 基于基因的注释（gene-based annotation）：SNPs或者CNV变异是否造成编码蛋白氨基酸的改变或者影响； 基于区域的注释（region-based annotation）揭示variant 与不同基因组特定区域的关系，例如：它是否与以下区域有overlap: conserved genomic elements，cytogenetic bands, microRNA target sites和Encyclopedia of DNA Elements (ENCODE)-annotated regions等 基于过滤的注释（ filter-based annotation ）则给出这个variant的一系列信息，例如是否该变异在dbSNP数据库报道过，该变异在1000genome项目，外显子组项目中的频率等，以及不同的计算机算法对变异注释的结果（SIFT/PolyPhen/LRT/MutationTaster/MutationAssessor/FATHMM/MetaSVM/MetaLR scores）等 下载（无需安转，但需要安装perl环境）最新版官网：网址 untargz annovar.latest.tar.gz echo &apos;export PATH=/home/wangdong/softwares/annovar/annovar_latest&apos;&gt;&gt;~/.bashrc 使用ANNOVAR进行突变注释时，gene definition files(例如GTF文件) 和transcript FASTA files（FASTA文件）版本需要同步对应，否则可能会出现mis-annotated variants (such as annotating SNVs asindels) 常用注释数据库下载 注释文件在ANNOVER分For gene-based annotation和For filter-based annotation以列表的形式详细介绍，链接 perl annotate_variation.pl –downdb –webfrom annovar –buildver hg19 refGene humandb/ perl annotate_variation.pl –downdb –webfrom annovar –buildver hg19 1000g2015aug humandb/ perl annotate_variation.pl –downdb –webfrom annovar –buildver hg19 exac03 humandb/ perl annotate_variation.pl –downdb –webfrom annovar –buildver hg19 clinvar_20170905 humandb/ perl annotate_variation.pl –downdb –webfrom annovar –buildver hg19 avsnp150 humandb/ perl annotate_variation.pl –downdb –webfrom annovar –buildver hg19 cosmic70 humandb/ perl annotate_variation.pl –downdb –webfrom annovar –buildver hg19 icgc21 humandb/ perl annotate_variation.pl –downdb –webfrom annovar –buildver hg19 nci60 humandb/ 这里下载的是几个通常用到的数据库的最新版： Build Table Name Explanation Date hg19 refGene FASTA sequences for all annotated transcripts in RefSeq Gene 20170601 hg19 1000g2015aug (6 data sets) The 1000G team fixed a bug in chrX frequency calculation. Based on 201508 collection v5b (based on 201305 alignment) 20150824 hg19 exac03 ExAC 65000 exome allele frequency data for ALL, AFR (African), AMR (Admixed American), EAS (East Asian), FIN (Finnish), NFE (Non-finnish European), OTH (other), SAS (South Asian)). version 0.3. Left normalization done. 20151129 hg19 clinvar_20170905 Clinvar version 20170905 with separate columns (CLINSIG CLNDBN CLNACC CLNDSDB CLNDSDBID) 20171003 hg19 avsnp150 dbSNP150 with allelic splitting and left-normalization 20170929 hg19 cosmic70 COSMIC database version 70 20140911 hg19 icgc21 International Cancer Genome Consortium version 21 20160622 hg19 nci60 NCI-60 human tumor cell line panel exome sequencing allele frequency data 20130724 ‘1000g2015aug’(version August 2015), 是2015年版，包含6个 data sets，提供千人基因组项目的替换等位基因频率等信息。 ‘exac03’(version 0.3),是0.3版外显子Exome Aggregation Consortium中报道过的variants。 ‘clinvar_20140929’ for the variants reported in the ClinVar database (version 20140929)，ClinVar数据库整合了十多个不同类型数据库、通过标准的命名法来描述疾病，同时支持科研人员将数据下载到本地中，开展更为个性化的研究。ClinVar数据库的目的在于整合这些分散的数据、将变异、临床表型、实证数据以及功能注解与分析等四个方面的信息，通过专家评审，逐步形成一个标准的、可信的、稳定的遗传变异-临床表型相关的数据库。 基于保守基因组元件注释数据文件，每一个在ANNOVAR说明文档都有详细介绍，链接地址，这里我们也只下载常用的即可。 perl annotate_variation.pl --downdb --buildver hg19 cytoBand humandb/ perl annotate_variation.pl -build hg19 -downdb gwasCatalog humandb/ ‘cytoBand’ 是每个细胞间band（cytogenetic band）的染色体坐标信息 , 注意： 1、第一个命令中不包含 ‘–webfrom annovar’ 选项, 因此是从the UCSC Genome Browser annotation database下载文件的； 2、 ‘–buildver hg19’ 选项是针对hg19这一版的基因组的； 3、运行上面命令后，在 ‘humandb/’ 目录下会多几个以 ‘hg19’为前缀的文件。 变异注释ANNOVER input fileANNOVER的输入文件要求VCF 4.0及以上，这一要求对于绝大多数call 变异的软件，如GATK何SAMtools都是满足的。VCF (Variant Call Format) specifications （包括 VCF4.0，4.1，4.2，以及BCF v2.1） 对于ANNOVAR新手，最方便使用table_annovar.pl程序table_annovar.pl example/ex1.avinput humandb/ -buildver hg19 -out myanno -remove -protocol refGene,cytoBand,exac03,avsnp147,dbnsfp30a -operation gx,r,f,f,f -nastring . -csvout -polish -xref example/gene_xref.txt 参数解释 -buildver hg19 ANNOVAR默认注释是根据hg18的，所以这里需要指定hg19。 -out myanno 输出注释结果文件myanno.hg19_multianno.txt -operation g表示gene-based；-operation gx 表示 gene-based with cross-reference annotation (from -xref argument)；-operation r 表示region-based； -operation f 表示 filter-based。如果不提供xref文件就只能指定-operation g。 -csvout使用逗号输出，如果喜欢使用tab键输出，则只需要去除 -csvout annotate_variation.pl是 ANNOVAR的核心程序使用例子： annotate_variation.pl -geneanno -dbtyep refGene -out ex1 -buildver hg19 example/ex1.avinput humandb/ annotate_variation.pl -regionanno -dbtype cytoBand -buildver hg19 example/ex1.avinput humandb/ annotate_variation.pl -filter -dbtype exac03 -buildver hg19 example/ex1.avinput humandb/ 参数解释及技术问题 –geneanno -dbtype refGene是默认的，可以省略 ncRNA above refers to RNA without coding annotation. It does not mean that this is a RNA that will never be translated. For example, BC039000 is regarded as ncRNA by ANNOVAR when using UCSC Known Gene annotation, but it is regarded as a protein-coding gene by ANNOVAR when using ENSEMBL annotation By default, the gene name is printed in the second column in the variant_function file. Sometimes, a user may want to see transcript name instead. The –transcript_function argument can be used to specify this behavior. Note that it is very likely that multiple transcript names will be printed in the output separated by comma, as each gene name typically corresponds to several transcript names 注释结果解释表头含义 各列内容及含义 Func.refGene, Gene.refGene, GeneDetail.refGene, ExonicFunc.refGene, AAChange.refGene列包含变异对基因结构的影响。其中如果Func.refGene给出注释显示该变异位于exonic/intronic/ncRNA，那么Gene.refGene列给出相应的基因名（如果是多个基因，中间用逗号分割）；如果不是，则给出该变异侧翼两个基因及与其距离。 ExAC* 等列表示在外显子组项目（Exome Aggregation Consortium）数据集中所有样本，包括亚人种中的等位基因频率。 avsnp138 列该变异在dbSNP（version 138）数据集中的SNP 的ID号 其他列包含使用多个变异功能预测软件得到的预测分数，包括SIFT scores, PolyPhen2 HDIV scores, PolyPhen2 HVAR scores, LRT scores, MutationTaster scores, MutationAssessor score, FATHMM scores, GERP++ scores, CADD scores, DANN scores, PhyloP scores and SiPhy scores等。 Func.refGene列具体含义 Value Default precedence Explanation Sequence Ontology exonic 1 variant overlaps a coding exon_variant (SO:0001791) splicing 1 variant is within 2-bp of a splicing junction (use -splicing_threshold to change this) splicing_variant (SO:0001568) ncRNA 2 variant overlaps a transcript without coding annotation in the gene definition (see Notes below for more explanation) non_coding_transcript_variant (SO:0001619) UTR5 3 variant overlaps a 5’ untranslated region 5_prime_UTR_variant (SO:0001623) UTR3 3 variant overlaps a 3’ untranslated region 3_prime_UTR_variant (SO:0001624) intronic 4 variant overlaps an intron intron_variant (SO:0001627) upstream 5 variant overlaps 1-kb region upstream of transcription start site upstream_gene_variant (SO:0001631) downstream 5 variant overlaps 1-kb region downtream of transcription end site (use -neargene to change this) downstream_gene_variant (SO:0001632) intergenic 6 variant is in intergenic region intergenic_variant (SO:0001628) The precedence defined above is used to decide what function to print out when a variant fit multiple functional categories ExonicFunc.refGene列具体含义 Value Default precedence Explanation Sequence Ontology frameshift insertion 1 an insertion of one or more nucleotides that cause frameshift changes in protein coding sequence frameshift_elongation (SO:0001909) frameshift deletion 2 a deletion of one or more nucleotides that cause frameshift changes in protein coding sequence frameshift_truncation (SO:0001910) frameshift block substitution 3 a block substitution of one or more nucleotides that cause frameshift changes in protein coding sequence frameshift_variant (SO:0001589) stopgain 4 a nonsynonymous SNV, frameshift insertion/deletion, nonframeshift insertion/deletion or block substitution that lead to the immediate creation of stop codon at the variant site. For frameshift mutations, the creation of stop codon downstream of the variant will not be counted as “stopgain”! stop_gained (SO:0001587) stoploss 5 a nonsynonymous SNV, frameshift insertion/deletion, nonframeshift insertion/deletion or block substitution that lead to the immediate elimination of stop codon at the variant site stop_lost (SO:0001578) nonframeshift insertion 6 an insertion of 3 or multiples of 3 nucleotides that do not cause frameshift changes in protein coding sequence inframe_insertion (SO:0001821) nonframeshift deletion 7 a deletion of 3 or mutliples of 3 nucleotides that do not cause frameshift changes in protein coding sequence inframe_deletion (SO:0001822) nonframeshift block substitution 8 a block substitution of one or more nucleotides that do not cause frameshift changes in protein coding sequence inframe_variant (SO:0001650) nonsynonymous SNV 9 a single nucleotide change that cause an amino acid change missense_variant (SO:0001583) synonymous SNV 10 a single nucleotide change that does not cause an amino acid change synonymous_variant (SO:0001819) unknown 11 unknown function (due to various errors in the gene structure definition in the database file) sequence_variant (SO:0001060) A unified annotation format不同的注释软件对突变注释的表示方式不统一，不利于交流，为此，多个注释软件的作者协定了一份统一的注释格式，文档链接 突变有害性注释结果选择建议（ANNOVER作者） 一般而言，建议使用one popular prediction score (such as SIFT) 和 one meta-score (such as metaSVM)预测来判断突变是否是有害的 对于 noncoding variants的有害性预测推荐使用one popular prediction score (such as PhyloP) 和 one meta-score (such as CADD) 补充vcf文件经过Annovar注释后突变个数应该相同，但对于原vcf文件类似如下情况，Annovar则会分别注释成两行 在Annovar官网的FAQ已经给出解释： 这里需要重新了解下vcf文件格式，（Annovar VCF Processing Guide）： GT：样品的基因型（genotype）。两个数字中间用’/‘分 开，这两个数字表示双倍体的sample的基因型。0 表示样品中有ref的allele； 1 表示样品中variant的allele； 2表示有第二个variant的allele VCF文件是描述位点的格式文件。尽管称作变异检出格式，但并不是为了描述变异或者基因型检出。其可以作为包含基因型检出（甚至变异）的一种选择，并且对于很多肺二倍体物种或者喝多情况（例如线粒体或者人的肿瘤），其有时候甚至不能说是包含基因型检出。但是，很多变异检出软件的目的是为了产生基因型检出；它们使用VCF作为输出文件，但是这并不意味着VCF文件是未存储变异检出而专门设计的。 因为VCF是一个位点描述文件，具有很多的结果。首先，并不是一行对应着一个变异。因为多个变异能在相同的位点，VCF文件的一行原则上可以描述多个突变（包含野生型非突变allele），和多种类型的基因型检出。例如，看下面这来自VCF文件的一行、其有8个tab键分割的列。在ALT列，具有数个逗号分割的改变的alleles。因此在单行上，数个插入和删除，以及一个单核苷酸（SNV）突变同时存在。 1 112240038 . CTTT CTTTT,CTTTTT,CTTA,CTT,CT,C . PASS AC=986,3,1249,3,127,3;AF=0.196885,0.000599042,0.249401,0.000599042,0.0253594,0.000599042 很多Annovar使用者喜欢保留VCF文件中的突变注释信息（通过INFO列）。因此对于上述这种情况，我们需要在相同行的INFO列加注释信息到所有的6个allels，并且确保使用者知道相应的注释对应相应的allele VCF可以hijack你的变异，使得SNVs变为多核苷酸突变，并且使得简单的indels变的复杂。这将对注释造成困难，举上述的 CTTT-&gt;CTTA 改变作为例子，其应该是简单的T&gt;A （SNV），但是因为deletion/insertion hijack the locus，其被写为CTTT-&gt;CTTA 而不是T-&gt;A 。考虑到单个allele频率数据库（例如千人基因组项目频率数据库）将只具有 T-&gt;A 但没有 CTTT-&gt;CTTA，然后这个变异通过注释软件注释后将被遗漏，甚至其确实在1000G中被观察到过。 同样的，CTTT-&gt;CTTTT 变异可能在数据库中没有记录，因为C&gt;CT可能是更合适的记录这个变异的方式。 目前为止还没有描述indel的普遍认同的特定方式。很多使用者偏好做left-normalization（变异开始的位置应该尽可能向左，直至不能再左，这样数目越少越好）。但是HGVS明确指明了left-normalization将被用在cDNA（mRNA）的坐标上,这意味着 right-normalization被要求使用在人的基因组一半的基因上。 在阅读了这些事实后，现在的问题时我们应该如何注释VCF文件来确保最准确的结果呢？ 因为left-normalization变得越来越流行，我的建议是是就使用left-normalization。我的第二个建议是各个VCF行仅描述一个变异，以便indel不能隐藏SNPs，以此确保1对1的和数据库匹配。 我作为ANNOVAR开发者决定去预处理所有的1000G文件，ESP6500si文件和dbSNP文件，以便一行包含一个变异，使得每个变异都采取 left-normalized。已经更新的数据再2014年的12月可以获得了。 作为使用者我们应该这样做：（1）分割VCF文件确保每一行只包含一个变异；（2）left-normalize所有的VCF文件； （3）使用ANNOVAR注释 所以使用命令： bcftools norm -m-both -o ex1.step1.vcf ex1.vcf.gz bcftools norm -f human_g1k_v37.fasta -o ex1.step2.vcf ex1.step1.vcf 第一个命令分割多allels变异检出为单独的行，第二个命令运行真正的 left-normalization。（有时候第一个命令可能出现没有变异能被分解，尽管在文件中存在这些变异，这种情况下，你可以使用vt program 代替） 目前使用left-normalized的数据集包括：avsnp138，avsnp142，clinvar_20150330 ，1000g2014oct，exac03，esp6500siv2 PS:更新（2018年12月25） 1234567perl annotate_variation.pl -downdb -buildver hg19 -webfrom annovar dbscsnv11 humandb_new/ ##剪切位点预测（splicing impact by Ada Boost and Random Forest）perl annotate_variation.pl -downdb -buildver hg19 -webfrom annovar cg46 humandb_new/## 在一个全基因组测序项目(包含46个无血缘关系的样本)中的等位基因频率 创新： 公布答案：如何根据HGVS快速定位hg19基因组位置：链接 参考（1）Genomic variant annotation and prioritization with ANNOVAR and wANNOVAR （2）每日一生信–基于保守性和规则性的预测方法SIFT和PolyPhen （3）annovar对人类基因组和非人类基因组variants注释流程 （4）ANNOVAR注释上机（推荐） （5）ANNOVAR人类各个数据库变异注释结果表格说明]]></content>
      <categories>
        <category>NGS</category>
      </categories>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RNA-seq质控]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2018%2F01%2F10%2FRNA-seq%E8%B4%A8%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[RNA-seq质控：去除低质量reads，adapter以及rRNA pipline比较值得关注的RNA-seq分析中的重要的步骤包括：实验设计，质控，read比对，表达定量，可视化，差异表达，识别可变剪切，功能注释，融合基因检测，eQTL定位等 建库质控使用Agilent 2100 Bioanalyzer，以下将简介其原理和结果如何解读 横坐标为片段长度，纵坐标为FU：arbitrary fluorescent unit 左边的峰为ladder，右边的峰为marker, ladder孔和样品孔中的marker起到对其和丁范围的校准作用。中间为样品峰。面积表示浓度。 质控（1）人类的Per sequence GC content峰值在48左右，否则就是有污染或者建库不均匀 （2）Per base N content越低越好（未识别的碱基，一般为0） （3）Illumina 下机测序长度是一定的，如果reads小于定长，就会测到Adapter，使用cutadapt去接头 （4）一般流程只保留paired-reads用于下一步比对 （去除低质量reads过程中，可能导致原来paired的reads长度不一致，当长度小于阈值时，整条reads将被去除，所以只剩下另一条reads，一般为了接下来定量分析的方便，另一条reads不用于比对） 结果分为绿色的”PASS”，黄色的”WARN”和红色的”FAIL”，其中，红色部分是我们质控的关键，以下将对红色的”FAIL”部分进行解释及用相应软件进行相对应的质控。 1. 去除低质量的reads 横轴代表位置，纵轴quality。红色水平线表示中位数，黄色柱子是25%-75%区间，触须是10%-90%区间，蓝线是平均数。 若任一位置的下四分位数低于10或中位数低于25，报”WARN”；若任一位置的下四分位数低于5或中位数低于20，报”FAIL”. 2. 检查每个tile的质量Illumina flowcells被分成一个个的tiles。为了检查低质量是否与flowcell的某些区域相关联，FASTQC对每个tile计算reads在所有位置的平均质量分数。 图中y轴表示tile的编号，x轴表示reads中的位置。 在此图中看到警告或失败的原因可能是短暂的问题，例如通过flowcell的气泡，或者可能是更持久的问题，例如在flowcell中出现的斑点或碎片，或者在tile中高密度的聚集。在这个模块中，最常见的警告原因是flowcell 被 overloaded。 建议忽略那些轻微影响一小部分tile,仅为1或2个cycles的warnings 或者 failures，并且只追求更大的影响，这些影响在分数中表现出很高的偏差，或者持续数个cycles。 3. Adapter Content对于R1： 对于R2 所以需要去接头 Per base sequence content 图的Failures 一般是由于文库污染造成的。如果一条特定的reads占了文库中的很大比例，那么这条reads将扭曲Per base sequence content图（在每个位置的碱基百分比将这条reads严重影响） 你可以使用Overrepresented sequences模块检查序列的污染情况，其列出了所有组成超过0.1%的序列，并列出其最佳匹配。上图中发现一个污染，被鉴定为Illumina的接头序列。 不去除接头污染将影响比对过程中的比对百分率 常用trimming tools的功能： 使用软件：trim_galore ,该软件通过调用FastQC进行质检，调用cutadapt去接头，同时还能去除低质量的reads。附加功能还有去除RRBS(for directional, non-directional (or paired-end) sequencing)测序文件的甲基化偏好位点。 其中去除低质量reads时最重要的两个参数是最小Phred score（1-30）和最小序列长度，不同文章对此观点不同，一般推荐Phred score 20 (90%置信区间)和最小50%-70%的序列长度。 Trim Galore!官网， Trim Galore is now also available from GitHub，具体参数使用参考User Guide。 4. GC平滑分布的锐利峰通常是特定污染物（例如适配体二聚体）的结果，这可能被过度表示的序列模块所挑选。更宽的峰可能代表不同物种的污染 5. 常见问题Question: GC content and Kmer For RNAseq datasets one typically sees failures in those modules. I should point out that FastQC is really geared toward whole-genome sequencing. We use it for all types of datasets, but many of them will have failures in various modules that can be ignored. Many overrepresented sequences in RNA-seq data. Should them be trimmed out? High sequence duplication levels in RNA-seq are normal and expected. Do not remove duplicates. This would underestimate the true expression of highly expressed genes, as it would artificially downscale the counts of these genes. n RNA-Seq libraries sequences from different transcripts will be present at wildly different levels in the starting population. In order to be able to observe lowly expressed transcripts it is therefore common to greatly over sequence high expressed transcripts, and this will potentially create large set of duplicates. This will result in high overall duplication in this test, and will often produce peaks in the higher duplication bins. This duplication will come from physically connected regions, and an examination of the distribution of duplicates in a specific genomic region will allow the distinction between over-sequencing and general technical duplication, but these distinctions are not possible from raw fastq files. 对于RRBS samples, 首先进行quality trimming，从3’端剪切掉低质量的reads；然后调用cutadapt程序从3’端去除接头，如果具体序列没有提供，其将使用标准的Illumina配对接头的前13bp （’AGATCGGAAGAGC’）序列来去除接头。给了控制去接头过程的严格程度，需要指定与接头序列最小的overlap数目，或者默认为1（即使与接头序列只有一个bp的overlap也会被剪切掉）。 agapter1=GATCGGAAGAGCACACGTCTGAACTCCAGTCACCGATGTATCTCGTATGC adapter2=AGATCGGAAGAGCGTCGTGTAGGGAAAGAGTGTAGATCTCGGTGGTCGCCGTATCATT time $trim_galore \ --quality 20 \ --stringency 5 \ --dont_gzip \ --fastqc \ --retain_unpaired \ -r1 31 -r2 31 \ --length 30 \ --output_dir $trim \ --paired \ --phred33 \ --adapter ${adapter1} \ --adapter2 ${adapter2} \ $sample_r1 $sample_r2 注：如果No overrepresented sequences，但Adapter Content未黄色警告，可以对于adapter和adapter2两个参数都可以用 –illumina 代替，表示 first 13bp of the Illumina universal adapter AGATCGGAAGAGC 使用参考：Quality Control using Trim Galore: How to run trim galore? 如果使用Trimmomatic可以参考以下命令： time java -Xmx${mythread}g -jar $Trimmomatic \ PE -phred33 \ -threads $mythread \ $sample_r1 $sample_r2 \ $trim/${sample}_paired.r1.fq.gz $trim/${sample}_unpaired.r1.fq.gz $trim/${sample}_paired.r2.fq.gz $trim/${sample}_unpaired.r2.fq.gz \ ILLUMINACLIP: $Trimmomatic/adapters/TruSeq3-PE-2.fa:2:30:10 \ LEADING:5 TRAILING:5 SLIDINGWINDOW:4:5 MINLEN:25 \ 2&gt; $trim/Trimmed.log 在Trimmomatic安装目录下有个adapter目录，其中TruSeq2适用于旧款测序仪的adapter序列的去除，而TruSeq3适用于Miseq,Hiseq等新款测序仪adapter序列的去除 做完质控后，可以使用Multiqc出报告，方便比较前后变化，特别是对于一批样本同时分析，强烈推荐MultiQC: summarize analysis results for multiple tools and samples in a single report ewels/MultiQC Using MultiQC manual 去除核糖体rRNA对于总RNA建库测序的RNA-seq实验设计，rRNA将占总数据量的95%左右，如果不去除，将严重影响比对率及下游分析。 SortMeRNA官网；SortMeRNA User Manual v2.1.pdf 建索引sortmerna_REF=/home/wangdong/miniconda3/sortmerna_db/rRNA_databases sortmerna_index=/home/wangdong/miniconda3/sortmerna_db/index indexdb_rna --ref $sortmerna_REF/silva-arc-16s-id95.fasta,$sortmerna_index/silva-arc-16s-id95 indexdb_rna --ref $sortmerna_REF/silva-arc-23s-id98.fasta,$sortmerna_index/silva-arc-23s-id98 indexdb_rna --ref $sortmerna_REF/silva-bac-16s-id90.fasta,$sortmerna_index/silva-bac-16s-id95 indexdb_rna --ref $sortmerna_REF/silva-bac-23s-id98.fasta,$sortmerna_index/silva-bac-23s-id98 indexdb_rna --ref $sortmerna_REF/silva-euk-18s-id95.fasta,$sortmerna_index/silva-euk-18s-id95 indexdb_rna --ref $sortmerna_REF/silva-euk-28s-id98.fasta,$sortmerna_index/silva-euk-28s-id98 indexdb_rna --ref $sortmerna_REF/rfam-5.8s-database-id98.fasta,$sortmerna_index/rfam-5.8s-db indexdb_rna --ref $sortmerna_REF/rfam-5s-database-id98.fasta,$sortmerna_index/rfam-5s-db 去除rRNASortMeRNA只接受一个reads输入文件，对于paired-end reads需要使用merge-paired-reads.sh脚本合并之后用于分析。 which merge-paired-reads.sh ${trim}/${sample}_paired_r1.fq ${trim}/${sample}_paired_r2.fq ${remove_rrna}/${sample}_paired_merge.fq SortMeRNA去除rRNA后，对于paired-end reads的过滤时，如果一条reads比对上rRNA，而另一条reads没有比对上rRNA，但又想保证输出到fastq文件的都是paired-end reads，则需要考虑以下两个参数： –paired-in will put both reads into the file specified by –aligned –paired-out will put both reads into the file specified by –other 第一个参数–paired-in表示所有在–other file中的reads都为non-rRNA;第二个参数–paired-out表示只有rRNA reads被输出到–aligned file。如果两个参数都不设置，则会导致输出结果的reads不配对，不利于后续分析。 time $sortmerna \ --ref $sortmerna_REF/silva-arc-16s-id95.fasta,$sortmerna_index/silva-arc-16s-id95:\ $sortmerna_REF/silva-arc-23s-id98.fasta,$sortmerna_index/silva-arc-23s-id98:\ $sortmerna_REF/silva-bac-16s-id90.fasta,$sortmerna_index/silva-bac-16s-id95:\ $sortmerna_REF/silva-bac-23s-id98.fasta,$sortmerna_index/silva-bac-23s-id98:\ $sortmerna_REF/silva-euk-18s-id95.fasta,$sortmerna_index/silva-euk-18s-id95:\ $sortmerna_REF/silva-euk-28s-id98.fasta,$sortmerna_index/silva-euk-28s-id98:\ $sortmerna_REF/rfam-5.8s-database-id98.fasta,$sortmerna_index/rfam-5.8s-db:\ $sortmerna_REF/rfam-5s-database-id98.fasta,$sortmerna_index/rfam-5s-db \ --reads ${remove_rrna}/${sample}_paired_merge.fq \ --aligned $remove_rrna/${sample}_paired_aligned_rRNA \ --other $remove_rrna/${sample}_paired_filtered_non_rRNA \ --fastx \ --sam --num_alignments 1 \ --paired_in \ --log \ -a 5 -v 接着将$remove_rrna/${sample}_paired_filtered_non_rRNA.fq文件拆分为forward reads和reserve reads两个文件，用于下游的paried-reads的比对 `which unmerge-paired-reads.sh` $remove_rrna/${sample}_paired_filtered_non_rRNA.fq \ $remove_rrna/${sample}_non_rrna_paired_r1.fq $remove_rrna/${sample}_non_rrna_paired_r2.fq 参考参考： （1） fastqc解释 （2） Quality control of NGS data（推荐） （3）qcfail.com：Articles about common next-generation sequencing problems（强烈推荐） （4）twbattaglia/RNAseq-workflow（推荐） （5）RNA-Seq analysis for differential expression in GenePattern Slides（推荐） （6）RNA-seq分析流程思维导图 （7）一个RNA-seq的反思 （8）从零开始完整学习全基因组测序数据分析：第3节 数据质控 （9） 数据过滤软件合集]]></content>
      <categories>
        <category>NGS</category>
      </categories>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GATK变异检测概述]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F12%2F26%2FGATK%E5%8F%98%E5%BC%82%E6%A3%80%E6%B5%8B%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[变异检测概述 突变发现背景介绍个体相对于参考基因组的两种突变 Germline (inherited) Somatic (cancer) 不同的突变类型 实验策略 全基因组测序 全外显子测序，或者设计目标基因的panel进行目标区域捕获测序 HTS machine processes a flowcell containing lanes;each lane cons)tutes a read group (RG) (unless multiplexed) Raw sequence的质控目的：将ASCII code转换为Phred-scale Q scores，考察测序质量（错误率） 所以phred score一般选择20即可 胚系突变snp&amp;indel分析流程 Map to reference Sort, Index Mark Duplicates &amp; Sort (Picard) Indels Realigment Base Quality Score Recalibration Variant Calling (HaplotypeCaller) Variant Filtration (Hard Filter, see GATK Best Practices) Annotation pipline:variant-call-gatk 文献：From FastQ data to high confidence variant calls: the Genome Analysis Toolkit best practices pipeline （1）Map BWA for DNA STAR for RNAseq Sequence/Binary Alignment Map (SAM/BAM) 细节：All BAM/CRAM files must satisfy the following requirements: It must be aligned to one of the references described here. It must be sorted in coordinate order (not by queryname and not “unsorted”). It must list the read groups with sample names in the header. Every read must belong to a read group. The BAM file must pass Picard ValidateSamFile validation. 具体参考：Collected FAQs about input files for sequence read data (BAM/CRAM) Add read group 对于多样本检测变异，比如mutect是必须的，否则当场一个样品处理 You only need to run FixMateInformation if you are getting errors with mate information from Picard’s ValidateSamFile， 具体参考 （2）Mark duplicates测序原理是随机打断，那么理论上出现两条完全相同的read的概率是非常低的，而且建库时PCR扩增存在偏向性，因此标出完全相同的read。这一步是为了减少duplication artifacts,从而正确评估alleles。duplicates的状态通过SAM flag来标记，但并没有去除（绝大多数的GATK tools默认忽 duplicates） duplicates来源：（1）PCR duplicates ; (2) Optical duplicates 以下两种情况不能 mark duplicates: Amplicon sequencing​ all reads start at same posi7on by design UMIAwareMarkDuplicatesWithMateCigar RNAseq allele-specific expression analysis (ASEReadCounter can disable DuplicateFilter) Duplicates = non-independent measurements of a sequenc fragment （3）Local realignment对于indel区域进行局部的重新比对，为了纠正比对错误。 Mappers对于在reads末端的indel较难检出，因为错配的罚分为-1，而open gap的罚分为-3。咋局部的indel realignment后能减少假阳性的SNPs数量。 具体过程： （1）通过RealignerTargetCreator，根据1000 Genomes Project, dbSNP等已知位点的VCF文件获取已知indels的位置区间，输出Target intervals （2）通过IndelRealigner进行realignment，输出Realigned BAM 通过–targetIntervals realigner.intervals指定indelrealignment的区间 realignment algorithm 的工作原理： （4）Base Recalibration (简称BQSR)纠正机器产生的错误，主要针对测序一产生的碱基质量分数的系统错误，BQSR纠正碱基质量分数（不是碱基本身） Base Recalibra2on steps/tools Model the error modes and compute adjustments—–》BaseRecalibrator Apply recalibra2on adjustments + write to file —–》PrintReads Make before/after plots ——-》AnalyzeCovariates （可选） BaseRecalibrator (1) java –jar GenomeAnalysisTK.jar \ –T BaseRecalibrator \ –R human.fasta \ –I realigned.bam \ –knownSites dbsnp137.vcf \ –knownSites gold.standard.indels.vcf \ –o recal.table java –jar GenomeAnalysisTK.jar –T PrintReads \ –R human.fasta \ –I realigned.bam \ –BQSR recal.table \ –o recal.bam BaseRecalibrator (2)(可选) ava –jar GenomeAnalysisTK.jar –T BaseRecalibrator \ –R human.fasta \ –I realigned.bam \ –knownSites dbsnp137.vcf \ –knownSites gold.standard.indels.vcf \ –BQSR recal.table \ –o after_recal.table java –jar GenomeAnalysisTK.jar –T AnalyzeCovariates \ –R human.fasta \ –before recal.table \ –after after_recal.table \ –plots recal_plots.pdf （5）Variant Calling根据变异来源和实验设计不同，选择不同的检测变异方案： 胚系突变检测是最容易的，对于肿瘤体细胞突变主要受肿瘤异质性和正常组织污染的影响，而拷贝数变异本质是计算reads覆盖的丰度 单个基因组是孤立的，通常并不能得出什么变异是致病性变异。一般要求家系或者群体数据，可以发现稀有变异，de novo变异，以及种族背景信息。 对于多样本或者家系的突变比较分析，可以使用HaplotypeCaller 的GVCF模式，主要目的GVCF文件输出所有的记录位点，无论其是否是变异。其目的是输出每个样本的每个位点，以便接下来的多样本联合比较分析。 但做多样本的联合分析必须注意，Similar technical generation是至关重要的，包括technology, capture, read length, depth 具体参考： Calling variants on cohorts of samples using the HaplotypeCaller in GVCF mode GVCF - Genomic Variant Call Format GenotypeGVCFs (i) also has an -allSites mode and (ii) by default pre-filters low QUAL (&lt;30) records 细节变异输出模式选择，输出模式总共有3种–output_mode / -out_mode (OUTPUT_MODE with default value EMIT_VARIANTS_ONLY) EMIT_VARIANTS_ONLY 只输出variants位点(SNPs和INDELs) EMIT_ALL_CONFIDENT_SITES 除了variants位点以外与reference一致的可靠位点也输出 EMIT_ALL_SITES 只要是能call的到的位点都输出(应该是除了没覆盖到的位点，其余位点都输出)，这个模式下会得到最多的结果 指定区间或者位点（使用-L参数）具体可参考：Collected FAQs about interval lists 对于外显子测序，可以使用.bed文件指定call变异的区间，包含三列（ ），以tab键分隔，不需要列名，chr1-chr20,chrX,chrY，并且需要根据坐标排序 也可以使用vcf文件指定位点call 变异，这对于几个样本的变异位点之间比较很有用 # Optimizing and tuning the pipelineManage the java heap memory You can control this by capping the maximum the heap memory can reach using the -Xmx{n} switch. For example, to cap at 8Gb add -Xmx8Gb （6）Variant Filtering前面提到Base Recalibration只是纠正碱基质量分数（不是碱基本身），在此Variant Filtering 便是基于Quality Score Recalibration的变异过滤。 对于Raw callsets的过滤必须平衡敏感度和准确度 Mutation calling算法设计上是宽容的 原始的高敏感度的callests包含大量的假阳性 两种过滤方法： （1）Hard-filters using binary thresholds Applicable to all BUT requires exper4se to define appropriately （2）Variant “recalibration” using machine learning ​ More powerful BUT requires well-curated known resources 但是Hard-filtering is a very blunt instrument,接下来主要讲述基于variant recalibration的过滤。 基本思想：训练已知的高置信度的位点来确定其他位点正确与否的可能性 Assume annota4ons tend to form Gaussian clusters Build a “Gaussian mixture model” from annotations of known variants in our dataset Score all variants by where their annotations lie relative to these clusters Filter base on sensiOvity to truth set 那么如何设置VQSLOD阈值呢？即设定X% of the sites in the truthset? Step 1: VariantRecalibrator（1）VariantRecalibrator builds the Gaussian mixture model Uses the variants in the input callset that overlap the training data Uses the annotations in our callset, not the resource callset java –jar GenomeAnalysisTK.jar –T VariantRecalibrator \ –R human.fasta \ –input raw.SNPs.vcf \ –resource: {see next slide} \ –an DP –an QD –an FS –an MQRankSum {…} \ –mode SNP \ –recalFile raw.SNPs.recal \ –tranchesFile raw.SNPs.tranches \ –rscriptFile recal.plots.R 输出：recal file, tranches, plots Recalibration plots show aspects of the model Tranche plots show estimated TP vs FP tradeoff (Default target Ti/Tv is for WGS and must be adapted for exomes) Tranches : slices of sensitivity threshold values Step 2: ApplyRecalibrationApplyRecalibration applies the filtering threshold Executes the desired sensitivity / specificity tradeoff by applying filters to the input callset (no new calculations) Creates a new, filtered, analysis-worthy VCF file. java –jar GenomeAnalysisTK.jar –T ApplyRecalibration \ –R human.fasta \ –input raw.vcf \ –mode SNP \ –recalFile raw.SNPs.recal \ –tranchesFile raw.SNPs.tranches \ –o recal.SNPs.vcf \ –ts_filter_level 99.0 输出变异每个突变将被注释上VQSLOD score 对于外显子数据跑VQSR的一些小建议 Smaller number of variants per sample compared to WGS -&gt; typically insufficient to build a robust recalibraOon model ​ if running on only a few samples Analyze samples jointly in cohorts of at least 30 samples If necessary, add exomes from 1000G Project or comparable 什么时候不推荐使用VQSR进行过滤呢？ Non-human organisms where known resources are unavailable or insufficiently curated RNAseq data à see RNAseq-specific filtering Cohort is too small(&lt;30) and no other samples are available for “padding” the cohort —–&gt; Use manual filtering recommendations instead 具体参考：Variant Quality Score Recalibration (VQSR) VariantRecalibrator （7） Genotype RefinementUsing additional data to improve genotype calls and likelihoods 基因型校正的重要性： 临床遗传医生需要给病人提供基因型 是否病人具有LOF mutation的两个拷贝 患病孩子的父母是否可能生出患该病更严重的孩子 群体遗传学家需要基因型数据用于关联研究 一个allele的多少拷贝能影响表型 用于基因型校正的数据： 使用高质量的数据（例如1000G）作为先验者 使用家系数据（若可以得到） 计算后验者的基因型可能性 基本方法：Bayes’s Rule 基因型校正的工作流程 CalculateGenotypePosteriors： java -jar GenomeAnalysisTK.jar \ -T CalculateGenotypePosteriors \ -R reference.fasta \ -V input.vcf \ -ped family.ped \ -supporting population.vcf \ -o output.vcf Filter low confidence GQs: java -jar GenomeAnalysisTK.jar \ -T VariantFiltration \ -R reference.fasta \ -V input.vcf \ --filterExpression “GQ&lt;20” \ --filterName “lowGQ” \ -o output.vcf Recommended threshold is GQ=20 – GQ 20 is Phred-scaled 99% confidence VariantAnnotator: java -jar GenomeAnalysisTK.jar \ -T VariantAnnotator \ -R reference.fasta \ -V input.vcf \ -A PossibleDeNovo \ -o output.vcf De Novo mutations的特点： 具体参考： （1）Genotype Refinement workflow （2）(howto) Run the genotype refinement workflow （3）Genotype Refinement workflow: mathematical details （8） Variant Evaluation基本思想：真实变异是具有代表性的，并且是可比较的 变异代表性的影响因素： 种群（Ethnicity）:Older popula+ons tend to display more heterogeneity 可以作为真实variant sets的数据来源： Sanger sequencing GeneChip/Microarrays Commonly used truth sets Recommended metrics for callset evalua+on Indels &amp; SNPs的数量，对于单个样本，WGS大约能检测到4.4M个;WES大约能检测到41k个。 如果变异是随机的，那么期望的TiTv Ratio应该为0.5，对于人类WGS测序，TiTv Ratio （Transitions/Transversions）大约为2.0-2.1；对于WES测序，TiTv Ratio大约为3.0-3.3,低的TiTv Ratio暗示可能存在高的假阳性。 Indel Ration表示insertions和deletions的比值，Common的情况Indel Ratio为1； Rare情况下为0.2-0.5。 Genotype Concordance指标则认为最准确的truth set 是对相同的样本进行genotyping chip，将自己的结果与truth相比较，没有匹配的则认为是假阳性的结果。 具体参考：Evaluating the quality of a variant callset 补充生物信息中，一旦涉及到 fastq 数据的处理，通常都要消耗大量内存、CPU 和时间。所以，在正式运行任务之前，建议先从整体数据中抽取一部分小数据进行测试。如何从 fastq 文件中随机抽取数据。使用的工具是 seqtk。 安装：conda install seqtk 使用： Usage: seqtk sample [-2] [-s seed=11] | Options: -s INT RNG seed [11]​ -2 2-pass mode: twice as slow but with much reduced memory []中的是可选参数，&lt;&gt; 中的是必需参数。[-2] 内存较小的服务器上运行时，设置此参数。[-s] 随机数的种子。如果是 Pair-end 数据，需要保证 read1 和 read2 的种子一致，才能抽到相同的raeds。默认是 11。[in.fq] 输入文件 可以输入要抽取的比例或 reads 条数。 seqtk sample -s100 read1.fastq.gz 10000 | gzip - &gt; sub1.fastq.gzseqtk sample -s100 read2.fastq.gz 10000 | gzip - &gt; sub2.fastq.gz 参考（1）从零开始完整学习全基因组测序数据分析：第4节 构建WGS主流程 （2）Exome sequencing pipeline using GATK （3）一起学NGS数据分析之检测突变：链接]]></content>
      <categories>
        <category>NGS</category>
      </categories>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GATK3.8分析环境搭建]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F12%2F26%2FGATK3.8%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[GATK3.8相关软件及文件准备 GATK官网相关栏目 Tool Documentation （包含每个工具的使用说明） Tutorials (包含具体参数和细节) GATK Best Practices （包含两个主流的分析流程） 全外显子测序call Germline SNP &amp; Indel流程图 体细胞拷贝数变异分析流程! 使用RNA-seq数据call变异 Calling variants in RNAseq Forum （提问和搜索报错解决很有用） Blog (包含历年的workshop材料，学习用得上) Presentation slides and tutorial materials - Pretoria 2017（需要翻墙才能下载） GATK3.8下载GATK=GenomeAnalysisToolkit，最新稳定版为GATK3.8 （需要注册！） &emsp;&emsp;电脑软件在投放市场前，需要有人测试一下，看看是不是有问题，在开发该软件的公司内部的由该公司内部人员测试的称为：alfa测试。alfa测试主要看有没有功能缺失或系统错误，alfa测试完后一般不会有大问题了，然后把软件拿给用户测试，称为：beta测试，主要是看用户对软件外观，使用方便等的反映。 如果beta1版用户反映有问题，拿到公司修改，改完后发布beta2版，还有不满意的地方，再改，再发布beta3版，直到用户满意，或正式版发布为止。 GATK4.Beta.5即为测试版 #解压： tar -jxvf GenomeAnalysisTK-3.8-0.tar.bz2 Getting Started（1）java版本要求大于1.8.x java -version （2）测试 java -jar /path/to/GenomeAnalysisTK.jar -h （3）设置别名 alias gatk=&quot;/home/wangdong/softwares/GATK3.8/GenomeAnalysisTK.jar&quot; （4）下载java1.7版本，解压即可（MuTect1.1.7需要） Java SE 7 Archive Downloads （5）mutect下载安装 github上mutect源码 broadinstitute/mutect(不必下载) GATK官网提供的编译好的MuTect1.1.7 How do I run MuTect?（参数详解及使用例子） （6） 其他软件及环境配置 Software packages BWA SAMtools Picard IGV RStudio IDE and R libraries ggplot2 and gsalib 参考：(howto) Install all software packages required to follow the GATK Best Practices. Reference sequence和annotation下载（请务必使用GATK resource bundle提供的参考基因组相关文件非常重要！） GATK resource bundle介绍：http://gatkforums.broadinstitute.org/discussion/1213/whats-in-the-resource-bundle-and-how-can-i-get-it GATK resource bundle FTP地址：http://gatkforums.broadinstitute.org/discussion/1215/how-can-i-access-the-gsa-public-ftp-server （1）使用Xftp5等FTP server登陆 location: ftp.broadinstitute.org/bundle username: gsapubftp-anonymous password: （2）使用浏览器登陆 ftp://gsapubftp-anonymous@ftp.broadinstitute.org/bundle/ Reference sequence ucsc.hg19.dict.gz ucsc.hg19.fasta.fai.gz ucsc.hg19.fasta.gz How can I prepare a FASTA file to use as reference? picard CreateSequenceDictionary R= hg19.fa O= hg19.dict annotation 1000G_omni2.5.hg19.sites.vcf.idx 1000G_omni2.5.hg19.sites.vcf.idx 1000G_phase1.indels.hg19.sites.vcf 1000G_phase1.indels.hg19.sites.vcf.idx hg19/1000G_phase1.snps.high_confidence.hg19.sites.vcf hg19/1000G_phase1.snps.high_confidence.hg19.sites.vcf.idx dbsnp_138.hg19.vcf dbsnp_138.hg19.vcf.idx hapmap_3.3.hg19.sites.vcf hapmap_3.3.hg19.sites.vcf.idx Mills_and_1000G_gold_standard.indels.hg19.sites.vcf Mills_and_1000G_gold_standard.indels.hg19.sites.vcf.idx dbSNP 用于去除部分候选突变，其在其他人中已经被观察到的，最有可能是胚系突变。因为提交给dbSNP数据库的突变验证水平很低，所以我们不能确定标记为胚系突变或者体细胞突变的标签是否可信。 相比之下，COSMIC是一个经过更高验证的资源，所以它基本上被用作白名单来“拯救”候选突变，否则这些候选突变将会因为在正常和/或dbSNP中而被去除。 我们期望在dbSNP中被标记为somatic的任何东西都将在COSMIC中，所以我们可以依靠COSMIC来重新回收这些位点。 当前最好的已知indels集合将被用于局部重新比对（local realignment）（请注意，我们不再使用dbSNP）; 使用这两个文件： 1000G_phase1.indels.b37.vcf (currently from the 1000 Genomes Phase I indel calls) Mills_and_1000G_gold_standard.indels.b37.sites.vcf If you run any GATK tool on a vcf that doesn’t have an index, it will automatically generate one for you, so knock yourself out。 参考：generate an idx file for a vcf GATK: Prepare Reference Files参考： (howto) Prepare a reference for use with BWA and GATK Prerequisites Installed BWA Installed SAMTools Installed Picard Steps Generate the BWA index bwa index -a bwtsw ucsc.hg19.fasta &emsp;&emsp;#-a bwtsw指定索引算法 Generate the Fasta file index samtools faidx ucsc.hg19.fasta &emsp;&emsp;#将生成ucsc.hg19.fasta.fai 文件 Generate the sequence dictionary（也可直接用已下载的ucsc.hg19.dict文件） java -jar picard.jar CreateSequenceDictionary \ REFERENCE=reference.fa \ OUTPUT=reference.dict （更详细的可参考：链接） Cosmic*.gz文件下载COSMIC需要注册 下载 CosmicCodingMuts.vcf CosmicNonCodingVariants.vcf Cosmic.hg19.vcf文件生成COSMIC and dbSNP files for MuTect sortByRef.pl was part of https://github.com/amplab/smash gunzip Cosmic*.gz grep &quot;^#&quot; CosmicCodingMuts.vcf &gt; VCF_Header grep -v &quot;^#&quot; CosmicCodingMuts.vcf &gt; Coding.clean grep -v &quot;^#&quot; CosmicNonCodingVariants.vcf &gt; NonCoding.clean cat Coding.clean NonCoding.clean | sort -gk 2,2 | awk &apos;{print &quot;chr&quot;$0}&apos; | perl sortByRef.pl --k 1 - hg19UCSC.fa.fai &gt; Cosmic.hg19 cat VCF_Header Cosmic.hg19 &gt; Cosmic.hg19.vcf GATK输入文件要求参考：What input files does the GATK accept / require? 参考（1）GATK使用（推荐） （2）使用GATK过程常见报错及解决 （3）GATK使用 备忘录（推荐） （4）GATK Best practices for variant discovery （BITS Courses TRAINING AT VIB） （5）初探 GATK4 beta]]></content>
      <categories>
        <category>NGS</category>
      </categories>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rmarkdown生成动态报告]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F12%2F10%2FRmarkdown%E7%94%9F%E6%88%90%E5%8A%A8%E6%80%81%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[Rmarkdown生成动态报告 &emsp;&emsp;RStudio可以当做 Markdown 编辑器来用（R Markdown），根据数据处理结果快速生成报告文档，这一功能主要通过 Package Knit 及相关组件完成。 &emsp;&emsp;R Markdown 的两大特别之处，一是通过 Pandoc 将 Markdown 转化成 LaTex，再由强大的 LaTex 转换成 HTML、PDF、Word，理论上来说借助 LaTex 可以生成学术论文、期刊杂志、数据报告等规范格式的文档；另一大特点是整合了 R 语言的环境，可以在 Markdown 语法中 code block 直接执行 R 语言代码并将结果插入文档。 R Markdown from Rstudio 帮助文档 一个小教程: Writing your thesis with R Markdown (1) – Getting started Writing your thesis with R Markdown (2) – Text, citations and equations Writing your thesis with R Markdown (3) – Figures, R code and tables Writing your thesis with R Markdown (4) – Putting the thesis together Writing your thesis with R Markdown (5) – The thesis layout 安装必要的包install.packages(&quot;devtools&quot;) # 如果以前没有安装 devtools 包 devtools::install_github(&quot;rstudio/rmarkdown&quot;) #安装github上最新版rmarkdown library(rmarkdown) 如何编辑 添加的是普通的文字: 那就按照Markdown写吧，你看到过的功能R都支持。 添加的是代码: 那就放到代码区域里面去，和Markdown的代码标记不太一样，多了 {}。 1code 然后在 {} 里告诉 R Studio 你希望显示什么: echo控制R代码块是否可见,设置为FALSE表示隐藏R代码，但会运行代码块并输出结果到文档。如果你只是为了显示而不需要运行一个代码块，设置eval = FALSE即可。 message参数用于设置是否显示控制台输出的信息，message = FALSE表示不显示。 只想显示代码 {r,echo = FALSE, eval = FALSE} 只想显示结果 {r,echo = FALSE, eval = TRUE} 想要代码+编译结果 {r,echo = TRUE，eval = FALSE} 如果是在文中添加代码，没有{} `r 2+ 2` chunk options 这个chunk放在最前面，声明以后的每一个chunk都不输出warnings和message 在代码块执行完后，控制结果的输出形式。包括文本、图表和图形的输出。有四个取值（更多细节参考http://yihui.name/knitr/options/）： 1.markup—标记显示 2.asis—文本显示 3.hold—末尾显示 4.hide—隐藏 由graphics和ggplot2得到的图形对齐方式可通过fig.align = ‘left’/‘right’/‘center’分别设置成左对齐，右对齐，居中。下图设置图形居中（默认是左对齐） 插入图片![Caption for the picture.](/path/to/image.png) 输出(html ,word, pdf)从Rmd格式可以导出为三种格式，用Pandoc实现:Word, HTML, PDF（额外需要LaTex支持，并且对中文的支持需要额外的设定） 软件安装Windows There is a package installer at pandoc’s download page. 选择msi installer或者zip file都可以。 For PDF output, you’ll also need to install LaTeX. We recommend MiKTeX. R Studio的全局配置(为了支持中文pdf输出) Tools – Global Options – Code—Saving， 设置Default text coding: UTF-8 coding Tools – Global Options – Sweave，将Typeset LaTeX into PDF using:设置为 XeLaTeX 需要注意的就是latex_engine:xelatex 了。即使设置了默认的编译器为xeLaTeX依旧要手动再声明一遍编译器 设置 YAML完成对R Studio的全局配置后，对每个Rmd文件（R markdown）在最开头条线之间进行设置才是更重要的。这个部分叫做YAML wiki 123456789101112---author: "wd"date: "2017.12.10"output: pdf_documenttitle: "MRstudy"outputs: pdf_document: includes: in_header: header.tex keep_tex: yes latex_engine: xelatex--- 步骤: 在YMAL里面设置 output: pdf_document，或者word_document, html_document。 设定好了之后三种导出的方法都一样，点击代码窗口上面的蓝色毛线团标记（选择输出html或者word或者pdf）。（knit英文是编织的意思，所以就是把代码织成文本吧） 注意正确的缩进和冒号 以上意思是，输出为html，word和pdf。html和word为默认设置。pdf设置包括，in_header，keep_tex和latex_engine。 如果一个设置还没到具体的内容，它紧接的是冒号，换行后需要缩进两个空格在开始。 如果已经指向明确的内容，结束没有冒号，换行之后不需要缩进。 header.tex需要和你的Rmd文档放到一个路径， 其中内容是： 12345\usepackage&#123;xeCJK&#125;\setCJKmainfont&#123;楷体&#125; % 字体可以更换\setmainfont&#123;Georgia&#125; % 設定英文字型\setromanfont&#123;Georgia&#125; % 字型\setmonofont&#123;Courier New&#125; 更多详细配置可以参考官方文档 编译前在viewer窗口预览文档使用方法： 安装 Xaringan install.packages(“devtools”) if (!requireNamespace(“xaringan”)) devtools::install_github(“yihui/xaringan”) R markdown不需额外设置。 编译的时候找到 Addin，点击Infinite Moon Reader rmarkdown转化中文字符为PDF的设置rmarkdown对于输出含中文的html和word文档，在YAML设置html_document: default或者word_document: default即可，但对于输出含有中文的pdf文件需要单独设置YAML。如下： 123456output: pdf_document: keep_tex: yes latex_engine: xelatex includes: in_header: header.tex 中文模板 详细说明安装rticles包，调用中文模板 install.packages(“rticles”) 安装成功之后，我们可以新建一个Rmarkdown文件。点击New-&gt;file-&gt;R markdown,其中有了一个From Template 使用ctrl + shift + k的快捷键，稍等片刻会出现中文PDF 参考（1）利用R-Markdown和Knitr创建动态报告（第一部分） （2）利用R-Markdown和Knitr创建动态报告（第二部分） （3）R Markdown 设置和使用 （4）R Markdown + Infinite Moon Reader + 编辑实时更新 （5）RStudio 中的 R Markdown（推荐） （6）Rmarkdown输出PDF的中文支持问题解决 （7）rmarkdown转化中文字符为PDF的设置 （8）Rmarkdown中文实现（推荐）]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建宏去除从pdf复制到word的回车换行]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F12%2F03%2F%E5%88%9B%E5%BB%BA%E5%AE%8F%E5%8E%BB%E9%99%A4%E4%BB%8Epdf%E5%A4%8D%E5%88%B6%E5%88%B0word%E7%9A%84%E5%9B%9E%E8%BD%A6%E6%8D%A2%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;从PDF或网页中复制一段文字再粘贴到WORD中，会出现很多多余的空格和回车，一个一个去删除费时费力费心。在word创建宏，并设置按钮即可。 创建宏去除从pdf复制到word的回车换行 如何创建宏及设置按钮Steps to Record a Macro in Word Firstly, open your Word. And make sure you have added “Developer” tab on the Ribbon first. For detailed instructions to add “Developer”, please read the article: How to Insert Background Music into Your Word Document Once “Developer” tab is available, click it. Then click “Record Macro” in “Code” group. Now a “Record Macro” dialog box will pop up. First, type the macro name, such as “copytext” here. Then in “Assign macro to” part, choose either “Button” or “Keyboard”. Here we will go “Button”. Next, click “OK”. And now you will see the “Word Options” window. Click “Customize Ribbon”. Then find a location for the macro on the right side. Here we will click “New Group” to set a new one for the macro. Noe continue to choose “Macros” from the drop-down list of “Choose commands from”. Next click the macro you just create. Then click “Add” in the middle of the window. Now the macro will be placed in the new group. Just right click the macro And choose “Rename” option. In “Rename” dialog box, choose a symbol for your macro. Then type the display name. Click “OK”. Now go back to “Word Options” window, and click “OK” there. The macro starts recording from now. 代码12345678910111213141516171819202122232425262728293031323334353637383940Sub 粘贴并替换回车() Dim Flag As Integer '粘贴并选中 startpos = Selection.Start 'Selection.Paste '普通粘贴 Selection.PasteAndFormat (wdFormatPlainText) '粘贴为文本 Selection.Start = startpos '先将多个回车并为一个 With Selection.Find .Text = "^13&#123;2,&#125;" .Replacement.Text = "^p" .MatchWildcards = True '使用通配符 .Wrap = wdFindStop '把 .Wrap = wdFindAsk 改成 .Wrap = wdFindStop对应于“是否搜索其余部分”中的“否” .Execute Replace:=wdReplaceAll End With '主要针对最后是两个回车的特殊情况这种特殊情况下，替换后少选择一位字符，影响后续操作 If Selection.Text Like "*[!。\?？\!！”：；]" &amp; Chr(13) Then Flag = 1 End If '再将前面不是句号的回车删除 With Selection.Find .Text = "([!.。\?？\!！”：；])^13" .Replacement.Text = "\1" .MatchWildcards = True '使用通配符 .Wrap = wdFindStop '把 .Wrap = wdFindAsk 改成 .Wrap = wdFindStop对应于“是否搜索其余部分”中的“否” .Execute Replace:=wdReplaceAll End With If Flag Then Selection.MoveLeft unit:=wdCharacter, Count:=-1, Extend:=wdExtend '取消选定最后一个回车符 End If '清除替换的内容 Selection.Find.Replacement.Text = ""End Sub 补充代码主要从参考1修改而来，主要修改： 源代码第一个With Selection.Find部分导致空格删除，使得中文可以，但英文全部空格被删除，所以需要注释=掉或者删除掉 第三个With Selection.Find部分需要加一个.号，主要针对英文 效果 参考（1）[源码]文本从PDF等粘贴到WORD中，智能删除多余的空格和回车 （2）How to Remove the Formatting of Pasted Texts with Macro and VBA in Your Word]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文献查询与引用技巧]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F11%2F25%2F%E6%96%87%E7%8C%AE%E6%9F%A5%E8%AF%A2%E4%B8%8E%E5%BC%95%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[文献查询与引用技巧 只查询review sci-hub最新地址（20171215） https://scihub22266qpcxt.onion.link/ http://sci-hub.tw/ 或者 www.sci-hub.tw http://sci-hub.hk/ 或者 www.sci-hub.hk 80.82.77.83 80.82.77.84 实验protocol或者数据分析protocolNature Protocols​ 或者 springer protocol 文献引用的下载 方法一：从中国知网 方法二：从百度学术 方法三：从Pubmed 方法四：从web of science &emsp;&emsp;方法 快速下载一篇文献后的引文导入EndNote：方法 剩下依然找不到，或者是电子文献的类型的只有手动在EndNote中生成了：方法 web of science文献检索技巧： 首先根据一个关键词检索，然后在搜索到的结果中精炼 文献引用的生成对于EndNote自带，或者官网有的Style可以直接下载使用 （1）Endnote期刊格式的下载和使用 （2）Endnote文献引用格式全解之常规引用格式获取方法 &emsp;&emsp;EndNote官网 修改文献引用格式&emsp;&emsp;硕士论文，博士论文没有完全对应的那种style，虽然EndnoteX7中已经有与GB/T7714-2005对应的两种参考文献输出格式：Chinese Std GBT7714(author-year).ens和Chinese Std GBT7714(numeric).ens，分别对应著者－出版年制和顺序编码制。但是这两个自带的style都不能完全满足国家标准的要求，还有就是不同学校的具体要求不一样，所以，需要自己在此基础上自定义。 顺序编码制 &emsp;&emsp;顺序编码制是指作者在论文中所引用的文献按它们在文中出现的先后顺序，用阿拉伯数字加方括号连续编码，视具体情况把序号作为上角或作为语句的组成部分进行标注，并在文后参考文献表中，各条文献按在论文中出现的文献序号顺序依次排列。 著者-出版年制 &emsp;&emsp;著者-出版年制”是指正文中各篇文献的标注内容由著者姓氏与出版年构成，并置于圆括号“（）”内；参考文献表按文种集中后按著者字顺和出版年排列的引用文献标注方法。 网上教程比较多，就不一一列举了，汇总一些问题的可行的解决方法还是可以的，已亲测可行哦！！ 问题一：endnote 出入文献怎样让英文参考文献在前,中文在后？方法 问题二：EndNote中英文混排时etal和等的3种解决方法? 方法 &emsp;&emsp;方法 细节问题：问题一：编号后的间隙有点大，不符合标准。默认的为2个字符，但是毕设手册要求的应该是1个字符? 方法 问题二：EndNoteX7一段文字如何引用多个连续文献[2-7]？方法 问题三：在endnoteX5中怎么用分号而不是逗号把多个citation分开？方法 问题四：搜狗输入法中文实心点怎么打?方法 问题五：Endnote中参考文献期刊名称的全称与缩写转换?方法 综合性推荐（1） Endnote中英文混排之完美解决（转） （2）在endnote中制作GB/T7714《文后参考文献著录规则》的输出格式 （3）endnoteX7全新教程 范例在EndNote中创建同济大学研究生学位论文参考文献格式! 网址 徐源_毕业论文参考文献输出标准格式.ens文件下载! 网址 另科研动力主页有许多关于EndNote的资料，基本可以解决文献应用的你遇到的所有问题：网址 快速导入一篇文章引用的参考文献至EndNoted再次引用&emsp;&emsp;在使用Endnote过程中遇到这样一个情况，如果发现一篇很好的文章，其后参考文献都很好，是某一方向或领域的经典，如何将这些文章一次性导入自己的Endnote中呢？最初用笨笨的方法，那就是一条条的往里输，等几十篇文章输完，快则一两个小时，慢的话一个上午甚至一天才能搞定。网上有使用scopus数据库的，并且有教程,但是scopus是需要登陆的，折腾了好久，在网上也没找到能用的账号。于是乎想想免费通用的办法罗。首先想到的是PubMed，确实可以，但是以下方法只对PubMed收录的免费的文献适用，对于全文版权在其他出版商的文献则无能为力了。 所以想到了Web of Science，这个方法更加通用可行！！已亲测，只需7步，快速导入一篇文章引用的参考文献至EndNoted。 参考]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql数据库与生信]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F11%2F23%2Fmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E7%94%9F%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;主要介绍win下和linux下连接重用生信数据库，操作数据库中表，以及根据自己的需要下载公共数据，创建mysql数据库。 mysql数据库与生信 mysql学习资料（1）21分钟 MySQL 入门教程 （2）MySQL 5.7 Reference Manual: 具体技巧例如 Counting Rows；Pattern Matching mysql连接生信主要公共数据库linux下格式：mysql -h[host] -u[user] -p[password] -P[port] [database-name] -h : 该命令用于指定客户端所要登录的MySQL主机名, 登录当前机器该参数可以省略; 退出：输入 exit; 或 quit; 退出登录 例如： Server User Password Port mysql-db.1000genomes.org anonymous - 4272 （1）1000 Genomes: since June 16, 2011 mysql -h mysql-db.1000genomes.org -u anonymous -P 4272 -A （2）UCSC Downloading Data using MySQL mysql -h genome-mysql.soe.ucsc.edu -u genome -P 3306 -A 或者 mysql -h genome-euro-mysql.soe.ucsc.edu -u genome -P 3306 -A 注意：必须加上端口号-P 3306，按照官网的方法会报错： ERROR 2003 (HY000): Can’t connect to MySQL server on ‘genome-mysql.soe.ucsc.edu’ (111) （3）The Ensembl public MySQL Servers mysql -h ensembldb.ensembl.org -u anonymous -P 5306 -A （4）GO mysql -h mysql-amigo.ebi.ac.uk -u go_select -P 4085 -pamigo -A The -A flag is optional but is recommended for speed. 其他数据库：参见网址 mysql直接读ucsc数据库数据mysql --user=genome --host=genome-mysql.cse.ucsc.edu -P 3306 -A -D hg19 -e &apos;select * from refGene where name=&quot;NM_000038&quot;&apos; | less 显示： bin name chrom strand txStart txEnd cdsStart cdsEnd exonCount exonStarts exonEnds score name2 1440 NM_000038 chr5 + 112073555 112181936 112090587 112179823 16 112073555,112090569,112 windows下使用Navicat，其好处在于更加方便直观 如图： 查询某一张表，查看具体内容，导出，筛选等等，很方便 mac下可以使用Sequel Pro python连接mysql数据库pip2.7 install MySQL-python 解决：libmysqlclient.so.18库在mysql安装目录的lib下，设置LD_LIBRARY_PATH环境变量即可 export LD_LIBRARY_PATH=&quot;$DYLD_LIBRARY_PATH:/home/wangdong/local/mysql/lib&quot; ps： 网上一般的做法是在mysql/lib目录下找到libmysqlclient.so.18，设置软链接到usr/lib或者usr/lib64，但这两个目录都需要管理员权限的。 应用例子利用mysql客户端查询UCSC数据库，获取geneSymbol名的bed信息 脚本geneInfo.py 根据需要创建UCSC genome MySQL database数据来源：UCSC hg19 hg38 需要两种文件： （1）*sql是一种数据库脚本语言，是一种对关系数据库中的数据进行定义和操作的句法，为大多数关系数据库管理系统所支持的工业标准。可以用文本编辑器打开并查看 （2)数据文件。txt文件 例子：.sql文件 使用shell脚本自动完成 1234567891011# create databasemysql -u root -prootab -e 'create database hg19'# obtain table schemacd /home/wangdong/local/mysql/datawget http://hgdownload.cse.ucsc.edu/goldenPath/hg19/database/ensGene.sql# create tablemysql -u root -prootab hg19 &lt; ensGene.sql# obtain and import table datawget http://hgdownload.cse.ucsc.edu/goldenPath/hg19/database/ensGene.txt.gzgunzip ensGene.txt.gzmysqlimport -u root -prootab --local hg19 ensGene.txt 注意：数据需要下载到/home/wangdong/local/mysql/data，位置可以在配置文件(my.cnf)中修改，具体操作查看链接：MySQL 转移 datadir 为了便于在命令提示符下显示中文, 在创建时通过 character set gbk 将数据库字符编码指定为 gbk create database samp_db character set gbk; 创建数据库表时，对于一些较长的语句在命令提示符下可能容易输错, 因此我们可以通过任何文本编辑器将语句输入好后保存为 createtable.sql 的文件中, 通过命令提示符下的文件重定向执行执行该脚本。 mysql -D samp_db -u root -p &lt; createtable.sql desc TABLE_NAME; 显示数据库表的结构（desc是describe的缩写） select * from TABLE_NAME limit 0,2;显示表的前两行内容，0表示起始行偏移量 补充LD_LIBRARY_PATH环境变量LIBRARY_PATH和LD_LIBRARY_PATH是Linux下的两个环境变量，二者的含义和作用分别如下： LIBRARY_PATH环境变量用于在程序编译期间查找动态链接库时指定查找共享库的路径， 例如，指定gcc编译需要用到的动态链接库的目录。设置方法如下（其中，LIBDIR1和LIBDIR2为两个库目录）： export LIBRARY_PATH=LIBDIR1:LIBDIR2:$LIBRARY_PATH LD_LIBRARY_PATH环境变量用于在程序加载运行期间查找动态链接库时指定除了系统默认路径之外的其他路径， 注意，LD_LIBRARY_PATH中指定的路径会在系统默认路径之前进行查找。设置方法如下（其中，LIBDIR1和LIBDIR2为两个库目录）： export LD_LIBRARY_PATH=LIBDIR1:LIBDIR2:$LD_LIBRARY_PATH 区别与使用：开发时，设置LIBRARY_PATH，以便gcc能够找到编译时需要的动态链接库。 发布时，设置LD_LIBRARY_PATH，以便程序加载运行时能够自动找到需要的动态链接库。 可视化管理工具 MySQL Workbench&emsp;&emsp;尽管我们可以在命令提示符下通过一行行的输入或者通过重定向文件来执行mysql语句, 但该方式效率较低, 由于没有执行前的语法自动检查, 输入失误造成的一些错误的可能性会大大增加, 这时不妨试试一些可视化的MySQL数据库管理工具, MySQL Workbench 就是 MySQL 官方 为 MySQL 提供的一款可视化管理工具, 你可以在里面通过可视化的方式直接管理数据库中的内容, 并且 MySQL Workbench 的 SQL 脚本编辑器支持语法高亮以及输入时的语法检查, 当然, 它的功能强大, 绝不仅限于这两点。 MySQL Workbench官方介绍: http://www.mysql.com/products/workbench/ MySQL Workbench 下载页: http://dev.mysql.com/downloads/tools/workbench/ MySQL Show命令总结MySQL中有很多的基本命令，show命令也是其中之一，在很多使用者中对show命令的使用还容易产生混淆，本文汇集了show命令的众多用法。 show tables或show tables from database_name; — 显示当前数据库中所有表的名称。 show tables like ‘my%’; — 显示当前数据库中以my开头的表。 show databases; — 显示mysql中所有数据库的名称。 show [full] columns from table_name from database_name; 或show [full] columns from database_name.table_name; — 显示表中列名称。 show grants for user_name; — 显示一个用户的权限，显示结果类似于grant 命令。 show index from table_name; — 显示表的索引。 show status;(show master status;show slave status) — 显示一些系统特定资源的信息，例如，正在运行的线程数量。 show variables; — 显示系统变量的名称和值。 show [full] processlist; — 显示系统中正在运行的所有进程，也就是当前正在执行的查询。大多数用户可以查看他们自己的进程，但是如果他们拥有process权限，就可以查看所有人的进程，包括密码。 show table status; — 显示当前使用或者指定的database中的每个表的信息。信息包括表类型和表的最新更新时间。 show privileges; — 显示服务器所支持的不同权限。 show create database database_name; — 显示create database 语句是否能够创建指定的数据库。 show create table table_name; — 显示create database 语句是否能够创建指定的数据库。 show engies; — 显示安装以后可用的存储引擎和默认引擎。 show innodb status; — 显示innoDB存储引擎的状态。 show logs; — 显示BDB存储引擎的日志。 show warnings; — 显示最后一个执行的语句所产生的错误、警告和通知。 show errors; — 只显示最后一个执行语句所产生的错误。 show [storage] engines; –显示安装后的可用存储引擎和默认引擎。 参考（1）生物信息学学者学习mysql之路 （2）Linux环境变量LD_LIBRARY_PATH （3）使用MySQL制作SNP146数据库 （4）How to: create a partial UCSC genome MySQL database （5）5分钟入门MySQL Workbench]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计及挑选捕获测序探针，并计算覆盖度]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F10%2F29%2F%E8%AE%BE%E8%AE%A1%E5%8F%8A%E6%8C%91%E9%80%89%E6%8D%95%E8%8E%B7%E6%B5%8B%E5%BA%8F%E6%8E%A2%E9%92%88%EF%BC%8C%E5%B9%B6%E8%AE%A1%E7%AE%97%E8%A6%86%E7%9B%96%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[使用bedtools进行捕获测序引物的筛选并计算覆盖度 基因CDS区域捕获测序，引物设计确定目标基因的某一转录本的CDS区域坐标，整理成bed文件最简单的方法是从gff文件中，根据转录本蛋白ID,直接grep抽取出CDS区间的chr, satrt, end wget http://ftp.ncbi.nih.gov/refseq/H_sapiens/annotation/GRCh38_latest/refseq_identifiers/GRCh38_latest_genomic.gff.gz ungz GRCh38_latest_genomic.gff.gz mv GRCh38_latest_genomic.gff GRCh38.p10_ncbi.gff #get genes positions by gene symbol list in gene.txt gene=($(cat gene.txt));for gene in ${gene[@]}; do grep -m 1 &quot;${gene}&quot; GRCh38.p10_ncbi.gff &gt;&gt;gene_result.txt;done #get cds regions positions by proteins list in proteins_id.txt protein_id=($(cat protein_id.txt));for protein_id in ${protein_id[@]}; do grep &quot;${protein_id}&quot; GRCh38.p10_ncbi.gff &gt;&gt;cds_result.txt;done #get gene chrom locations or transfor gene symbol ID to essenble ID by gene symbol list in gene.txt wget http://ftp.ncbi.nih.gov/refseq/H_sapiens/Homo_sapiens.gene_info.gz head -n 1 Homo_sapiens.gene_info &gt; chr_result.txt gene=($(cat gene.txt));for gene in ${gene[@]}; do grep -m 1 &quot;${gene}&quot; Homo_sapiens.gene_info &gt;&gt;chr_result.txt;done 整理成bed文件 安捷伦的eArray可以设计，输入只需要目标区域的bed文件即可！ Agilent Genomic Workbench Downloads Installation Guide 补充（1）NCBI 的FTP站点中GRCh37和GRCh38的最新版基因组注释数据在该路径下：http://ftp.ncbi.nih.gov/refseq/H_sapiens/annotation Last updated: April 19, 2017 assembly name: GRCh38.p10（第十版） （2）对于做湿实验的同学可能通过浏览器的方式查询CDS区域坐标，但存在一个问题（首先浏览器上的版本是GRCh38.p7（第七版））！ NCBI —&gt;选择gene数据库—&gt;输入gene symbol —-&gt;点选gene symbol—-&gt;genebank—-&gt;找到目标转录本 &emsp;&emsp;可以看到CDS由一段一段的区域join形成的，但这是相对坐标，如何转换成基因组的绝对坐标呢？或许你会用基因的起始和结束位置进行加减，但尝试比较了下，发现坐标偏差很大（0.2M）。首先是版本的问题？, 其次可能NCBI的坐标系统中CDS区域的位置，使用在基因区间的基础上加减的做法不对。将上述链接最下方的FASTA序列的第62-199区间摘取出来，在UCSC中BLAT发现其结果是与从GRCh38.p10_ncbi.gff文件摘取出来的坐标一致的，所以用基因的起始和结束位置进行加减的方法是不正确的。 引物筛选 A组引物扩增区域（Amplicon_Stop-Amplicon_Start）长度范围为126-274nt，平均值为238nt B组引物扩增区域（Amplicon_Stop-Amplicon_Start）长度范围为124-174nt,平均值为158nt A,B两组引物都是针对同一目标区域设计的捕获探针，但是参数不同，导致扩增长度不同，覆盖度不同 &emsp;&emsp;所以A组引物（primer20）偏长，B组引物（primer24）偏短，现在需要将A组引物中扩增区域大于250nt的目标区域用 B组引物来扩增，实现长度互补和综合。 方法：使用bedtools工具即可！ 将targeted.bed与primer20.bed查看覆盖情况，将没有引物覆盖的，或者覆盖的引物扩增长度大于250nt的目标区域的bed区间抽取出来整理为target_region_of_primer20_up250.bed 将target_region_of_primer20_up250.bed与primer24.bed查看覆盖情况，将覆盖上的引物挑出，此时原则是目标区域即使有某条引物能全部覆盖，但为了测序数据更加准确，一个位置保证2-3个引物覆盖为好 将A组合B组引物保留的部分引物合并，同时整理出A,B两组引物都没有覆盖的目标区域。 1234567891011#step1bedtools intersect -a target.bed -b primer20.bed -wao &gt; primer20_result.txt awk '$6-$5&gt;250 &#123;print $1,$2,$3&#125;' primer20_result.txt &gt; target_region_of_primer20_up250.bed#step2bedtools intersect -a target_region_of_primer20_up250.bed -b primer24.bed -wao &gt; primer24_result.txt#step3primer20=($(cat primer20_reserved.txt));for primer20 in $&#123;primer20[@]&#125;; do grep -m 1 "$&#123;primer20&#125;" primer20_original.txt &gt;&gt;primer20_reserved_result.txt;doneprimer24=($(cat primer24_reserved.txt));for primer24 in $&#123;primer24[@]&#125;; do grep -m 1 "$&#123;primer24&#125;" primer24_original.txt &gt;&gt;primer24_reserved_result.txt;done 根据targete.bed和primer20.bed计算覆盖度1234567891011121314151617(1)检验bed区间是否有重叠length_sum1=`awk 'BEGIN &#123;x=0&#125;&#123;x=x+$3-$2+1&#125;&#123;print x&#125;' target.bed |tail -n 1`length_sum2=`sort -k1,1 -k2,2n target.bed |bedtools merge -i target.bed| awk 'BEGIN &#123;x=0&#125;&#123;x=x+$3-$2+1&#125;&#123;print x&#125;'|tail -n 1`#如果length_sum1 &gt; length_sum2,有重叠；如果length_sum1 = length_sum2,无重叠#所以target.bed无重叠，primer20和primer24有重叠(2)先用bedtools工具得到primer20的merge后的bed文件，然后与target.bed查看覆盖碱基数，并求和sort -k1,1 -k2,2n primer20.bed|bedtools merge -i &gt; primer20_merge.bedlength_sum3=`bedtools intersect -a target.bed -b primer20_merge.bed -wao | awk 'BEGIN &#123;x=0&#125;&#123;x=x+$7&#125;&#123;print x&#125;' |tail -n 1` coverage = length_sum3/length_sum1*100 bedtools merge功能图示（需要先排序，否则报错） 对于.xlxs文件，另存为.txt，然后复制到linux的txt文件（vim） 补充 参考（1）染色体位置overlap的计算–bedtools应用 （2）Tool: Converting Genome Coordinates From One Genome Version To Another (Ucsc Liftover, Ncbi Remap, Ensembl Api)]]></content>
      <categories>
        <category>NGS实验</category>
      </categories>
      <tags>
        <tag>NGS实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库安装及入门]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F10%2F21%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E8%A3%85%E5%8F%8A%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[无root权限，从源码编译安装MySQL数据库，及其简单使用 科德十二定律科德十二定律（Codd’s 12 rules）是由数据库的关系模型的先驱埃德加·科德（EdgarF. Codd）提出的，使数据库管理系统关系化需满足的十三条（从0至12）准则。又称为“黄金十二定律”。 准则0:&emsp;一个关系形的关系数据库系统必须能完全通过它的关系能力来管理数据库。 准则1 信息准则: &emsp;关系数据库系统的所有信息都应该在逻辑一级上用表中的值这一种方法显式的表示。 准则2 保证访问准则: &emsp; 依靠表名、主码和列名的组合，保证能以逻辑方式访问关系数据库中的每个数据项。 准则3 空值的系统化处理: &emsp;全关系的关系数据库系统支持空值的概念，并用系统化的方法处理空值。 准则4 基于关系模型的动态的联机数据字典: &emsp;数据库的描述在逻辑级上和普通数据采用同样的表述方式。 准则5 统一的数据子语言: &emsp;一个关系数据库系统可以具有几种语言和多种终端访问方式，但必须有一种语言，它的语句可以表示为严格语法规定的字符串，并能全面的支持各种规则。 准则6 视图更新准则: &emsp;所有理论上可更新的视图也应该允许由系统更新。 准则7 高级的插入、修改和删除操作: &emsp;系统应该对各种操作进行查询优化。 准则8 数据的物理独立性: &emsp;无论数据库的数据在存储表示或存取方法上作任何变化，应用程序和终端活动都保持逻辑上的不变性。 准则9 数据逻辑独立性: &emsp;当对基本关系进行理论上信息不受损害的任何改变时，应用程序和终端活动都保持逻辑上的不变性。 准则10 数据完整的独立性: &emsp;关系数据库的完整性约束条件必须是用数据库语言定义并存储在数据字典中的。 准则11 分布独立性: &emsp;关系数据库系统在引入分布数据或数据重新分布时保持逻辑不变。 准则12 无破坏准则: &emsp;如果一个关系数据库系统具有一个低级语言，那么这个低级语言不能违背或绕过完整性准则。 Relational Database Management Systems (RDBMS) Commercial products Open-source offerings Oracle MySQL (Oracle) DB2 (IBM) PostgreSQL MS SQL Server (Microsoft) SQLite 下载MySQL下载MySQL源代码 下载选项： Source Code -&gt; 源代码 Generic Linux (Architecture Independent) -&gt; 通用的Linux（独立结构） Compressed TAR Archive，Includes Boost Headers -&gt; 选择带有Boost头的压缩包（MySQL需要Boost C++库构建） wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-boost-5.7.20.tar.gz 从源安装MySQL安装CMakecmake，一个跨平台的编译自动配置工具（作用生成makefile 文件） 123456789#!bin/shHOME=/home/wangdonginstall_path=$HOME/local/cmakemkdir -p $install_path/.srccd $install_path/.srcwget http://www.cmake.org/files/v2.8/cmake-2.8.12.2.tar.gztar zxvf cmake-2.8.12.2.tar.gzcd cmake-2.8.12.2./configure --prefix=$install_path 输出 CMake has bootstrapped. Now run gmake. #确保cmake没有错误发生 echo $? 0 #下面运行gmake命令更新curl ./bootstrap --system-curl gmake gmake install ps :系统中需要先安装好curl以及其libssl-dev 安装curl : ​ ./configure –with–ssl ​ make ​ make install 安装boost库​ wget https://nchc.dl.sourceforge.net/project/boost/boost/1.59.0/boost_1_59_0.tar.gz ​ tar -zxvf boost_1_59_0.tar.gz 编译安装MySQL1234567891011121314151617181920212223242526272829303132333435363738394041#（1）下载MySQL-5.6及创建相应目录结构HOME=/home/wangdonginstall_path=$HOME/local/mysqlmkdir -p /home/wangdong/local/mysqlwget https://dev.mysql.com/get/Downloads/MySQL-5.6/mysql-5.6.35.tar.gztar zxvf mysql-5.6.35.tar.gzcd mysql-5.6.35mkdir $install_path/data#（2）编译(系统已经安装cmake,此处徐使用上述自己安装的cmake)cmake \-DCMAKE_INSTALL_PREFIX=$install_path \-DMYSQL_DATADIR=$install_path/data \ -DDEFAULT_CHARSET=utf8 \-DDEFAULT_COLLATION=utf8_general_ci \ -DMYSQL_TCP_PORT=3306 \ -DMYSQL_USER=mysql \ -DWITH_MYISAM_STORAGE_ENGINE=1 \ -DWITH_INNOBASE_STORAGE_ENGINE=1 \ -DWITH_ARCHIVE_STORAGE_ENGINE=1 \ -DWITH_BLACKHOLE_STORAGE_ENGINE=1 \ -DWITH_MEMORY_STORAGE_ENGINE=1 \ -DDOWNLOAD_BOOST=1 \ -DWITH_BOOST=~/softwares/MySQL/mysql5.7/boost#（3)安装 make &amp;&amp; make install#(4)配置（找到support-files/my-default.cnf，该文件是一个配置模板，在此基础上自己修改配置）cp support-files/my-default.cnf my.cnf在运行初始化权限表的时候使用增加参数--datadir ，命令格式为：scripts/mysql_install_db --user=dongwang --datadir=/share/home/dongwang/softwares/mysql/mysql5.6/data#(5)使用启动my.cnf配置文件中的设置启动mysqld_safe服务和启动mysqlbin/mysqld_safe --defaults-file=my.cnf &amp; #&amp;表示后台运行netstat -apn|grep 13308support-files/mysql.server start|stop|restart #开始|停止|重启bin/mysql --socket=mysql.sock -u root 如果执行成功，会提示如下内容： 同时，生成mysql.pid和mysql.sock文件，正常！ 以及查看13306端口，正常！ 关于配置的注意事项（1）最基本的需要修改以下7项（关于my.cnf配置文件的具体解释可以看这里（MySQL之——MySQL5.6 my.cnf 参数说明(附上自己服务器上真实配置文件)）） 在[mysqld]里修改port=13306 在[mysqld]里修改sock文件位置（socket） 在[mysqld]里添加MySQL基础目录（basedir） 在[mysqld]里添加MySQL数据存储目录（datadir） 在[mysqld]里添加MySQL日志文件（log-error） 在[mysqld]里添加MySQL进程文件（pid-file） 在[mysqld]里添加指定MySQL数据库所属用户（user -这里填写你所用的linux用户） （2）检查MySQL默认端口3306是否被占用，执行命令：netstat -apn | grep 3306如下图表明3306已经被占用，那么换一个端口，建议端口号在10000以上，比如改成13306，所以可以设置port=13306 如下图为my-default.cnf原始文件（模板） 如下图为修改配置后的my.cnf文件 注意：修改好my.cnf文件后，记得创建/home/wangdong/local/mysql/data和/home/wangdong/local/mysql/logs文件目录，否则在第（5）步会报错 启动MySQL每次启动MySQL都需要nohup bin/mysqld_safe --defaults-file=my.cnf &amp; #&amp;表示后台运行 support-files/mysql.server start #开始 support-files/mysql.server stop #关闭 可以看到MySQL正常启动了，但是写入日志时不具有/var/log/mysqld.log的权限，问题是我们之前不是设置了log-error = /home/wangdong/local/mysql/logs/mysql_error.log吗？原因在于在linux系统中mysql配置文件的读取顺序为:/etc/my.cnf;/etc/mysql/my.cnf;/usr/local/mysql/etc/my.cnf ;~/.my.cnf 我们可以使用locate查找系统已有的my.cnf配置文件，如下图， 网上搜了一下解决办法，删除系统上/etc目录下的my.cnf配置文件，但无root权限做不到的，但还好，写入日志文件无权限并不影响MySQL的正常启动和使用！ MySQL数据库使用大致步骤包括： 第一次访问MySQL数据库的时候要以root进去（及-u root），且没有密码。 然后使用mysql数据库，修改root密码。 创建新的用户，以及授权 正常使用、登录mysql,root进去，且需要密码。 第一次访问MySQL数据库执行命令格式：bin/mysql –socket=mysql.sock -u root 一定要加上–socket=mysql.sock（mysql安装目录中的mysql.sock，否则提示ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock’ (2)） 查看已有数据库，删除内置的test数据库执行命令（注意命令末尾的分号不可少）： show databases; drop database test; 查看内置MySQL用户，删除匿名用户执行命令： use mysql; #选择mysql数据库 select host, user, password from user; #从mysql数据库中的user表格中选择host, user, password三个字段 delete from user where user = &apos;&apos;; 修改密码执行命令： update user set password = password(&apos;rootab&apos;); 修改密码后需要先关闭mysql服务，然后重新启动my.cnf配置文件中的设置启动mysqld_safe服务和启动mysql，使新密码生效！！ 执行命令： support-files/mysql.server stop bin/mysqld_safe --defaults-file=my.cnf &amp; support-files/mysql.server start 正常使用，使用root登陆，并且需要密码登陆mysql -u 用户名 -h host_name -P 端口号 -p密码 (‘-P 端口号’的P大写 ‘-p密码’的p小写，且密码(password)和p之间没有空格) 如bin/mysql –socket=mysql.sock -u root -h localhost -P 13306 -prootab 也可以这样写： bin/mysql --socket=mysql.sock -u root -h localhost -P 13306 -p 然后在窗口弹出Enter password:时输入密码即可 （查看mysql命令的帮助: bin/mysql -I） 将bin/mysql加入环境变量echo &apos;export PATH=/home/wangdong/local/mysql/bin:$PATH&apos;&gt;&gt;~/.bashrc source ~/.bashrc 以后登陆直接： WORKDIR=/home/wangdong/local/mysql/ mysqld_safe --defaults-file=$WORKDIR/my.cnf &amp; $WORKDIR/support-files/mysql.server start mysql --socket=$WORKDIR/mysql.sock -u root -h localhost -P 13306 -p Do somethings exit; $WORKDIR/support-files/mysql.server stop (使用版本：Server version: 5.6.35 Source distribution) 参考（1）CentOS 6.4编译安装mysql 5.7 （2）从源编译MySQL （3）Linux MySQL免安装及配置 （4） linux中无root权限，装mysql 于用户目录步骤 （5）非root权限安装mysql]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算捕获效率，测序深度，覆盖度]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F10%2F12%2F%E8%AE%A1%E7%AE%97%E6%8D%95%E8%8E%B7%E6%95%88%E7%8E%87%EF%BC%8C%E6%B5%8B%E5%BA%8F%E6%B7%B1%E5%BA%A6%EF%BC%8C%E8%A6%86%E7%9B%96%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[计算捕获效率，测序深度，覆盖度 &emsp;&emsp;WGS, exome, or targeted sequencing的数据分析的时候，经常需要计算全基因组整体的平均测序深度或者 target 区域的测序深度的分布情况以考察试剂盒的捕获效率。 bamutils / stats bedtools-protocols 全外显子测序&emsp;&emsp;使用不同公司的捕获panel,对应的捕获区域也不完全相同，可以在相应公司的官网下载相应的bed文件；当然也可以自行设计相应的捕获区域。 例如Agilent公司的SureSelect 已经设计好的系列kits：网址（需要注册） SureSelect Human All Exon V5+UTRs为75M的捕获区域 SureSelect Human All Exon V5 为50M的捕获区域 SureSelect Human All Exon V6 r2为60M的捕获区域 下载文件内容的具体说明可查看：Target enrichment design files available for download 其中[design ID]_Covered.bed - This BED file contains a single track of the genomic regions that are covered by one or more probes in the design. The fourth column of the file contains annotation information. You can use this file for assessing coverage metrics. 即是我们想要的用于计算覆盖度的bed文件。 为了提高计算速度，bed文件最好先排序： sort -k1,1 ranges-cov.bed &gt; ranges-cov-sorted.bed #测序深度计算 bedtools coverage -hist -abam samp.01.bam -b target_regions.bed | grep ^all &gt; samp.01.bam.hist.all.txt 输出结果含义： The number of features in B that overlapped (by at least one base pair) the A interval. The number of bases in A that had non-zero coverage from features in B. The length of the entry in A. The fraction of bases in A that had non-zero coverage from features in B. all 0 170 300 0.5666667 all 1 130 300 0.4333333 即第2列为测序深度depth 的X数，第5列为侧得碱基相对于target.bed区间的碱基占比。 GATK DepthOfCoverage&emsp;&emsp;This tool processes a set of bam files to determine coverage at different levels of partitioning and aggregation. Coverage can be analyzed per locus, per interval, per gene, or in total; can be partitioned by sample, by read group, by technology, by center, or by library; and can be summarized by mean, median, quartiles, and/or percentage of bases covered to or beyond a threshold. Additionally, reads and bases can be filtered by mapping or base quality score. 12345678910#Time:91m52time java -Xmx$&#123;mythread&#125;g -jar $gatk \-T DepthOfCoverage \-R $ref \-L $capture_interval \-I $realign/$&#123;sample&#125;_realignment.BQSR.bam \-o $preprocess/$&#123;sample&#125;_coverage.depth \-ct 1 -ct 5 -ct 10 -ct 15 -ct 20 -ct 25 -ct 30 -ct 40 -ct 45 -ct 50 -ct 60 -ct 70 -ct 80 -ct 90 -ct 100 \-ct 110 -ct 120 -ct 130 -ct 140 -ct 150 -ct 160 -ct 170 -ct 180 -ct 190 -ct 200 GATK DepthOfCoverage输出结果解释 DepthOfCoveragePerInterval 全基因组测序使用picard工具集合中的CollectWgsMetricsWithNonZeroCoverage即可： java -jar picard.jar CollectWgsMetricsWithNonZeroCoverage \ I=input.bam \ O=collect_wgs_metrics.txt \ CHART=collect_wgs_metrics.pdf \ R=reference_sequence.fasta 测序覆盖度和深度可视化展示参考：Question: How to plot coverage and depth statistics of a bam file Visualize coverage for targeted NGS (exome) experiments alfred安装及使用conda install -c bioconda alfred 参考（1）bam文件急速depth计算工具 （2）GATK DepthOfCoverage （3）alfred（推荐） （4）安捷伦Agilent 外显子捕获试剂盒捕获区域bed文件下载 （5）答复 | 如何计算每个基因的覆盖度与深度]]></content>
      <categories>
        <category>NGS</category>
      </categories>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R一页多图]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F10%2F03%2FR%E4%B8%80%E9%A1%B5%E5%A4%9A%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;发表文章一般都要求将多个相关的图组合成单个图，并标上A,B,C等标签。所以总结一下R语言绘图的一页多图，以及多图的拼接，子母图等的各种实现方法，！ R一页多图 cowplot：基于ggplot的可视化系统简介&emsp;&emsp;cowplot是一个ggplot2包的简单补充，意味着其可以为ggplot2提供出版物级的主题等。更重要的是，这个包可以组合多个”ggplot2”绘制的图为一个图，并且为每个图加上例如A,B,C等标签， 这在具体的出版物上通常是要求的。 代码123456789101112131415161718192021222324library(ggplot2)require(cowplot) plot.iris &lt;- ggplot(iris, aes(Sepal.Length, Sepal.Width)) + geom_point() + facet_grid(. ~ Species) + stat_smooth(method = "lm") + background_grid(major = 'y', minor = "none") + panel_border() + labs(title = "dot-line plot")plot.mpg &lt;- ggplot(mpg, aes(x = cty, y = hwy, colour = factor(cyl))) + geom_point(size=2.5) + labs(title = "dot plot")plot.diamonds &lt;- ggplot(diamonds, aes(clarity, fill = cut)) + geom_bar() + theme(axis.text.x = element_text(angle=70, vjust=0.5)) + labs(title = "bar plot")ggdraw() + draw_plot(plot.iris, 0, .5, 1, .5) + draw_plot(plot.mpg, 0, 0, .5, .5) + draw_plot(plot.diamonds, .5, 0, .5, .5) + draw_plot_label(c("A", "B", "C"), c(0, 0, 0.5), c(1, 0.5, 0.5), size = 15) 结果 注意：其中draw_plot(plot, x = 0, y = 0, width = 1, height = 1, scale = 1)，坐标参数范围为0-1，相当于每幅图占画布长宽的百分比 rmisc包中的multiplot函数实现上述相同效果简单高效，一句话搞定！可以实现上述同样的结果。 代码12345library("Rmisc")library("lattice")library("plyr")multiplot(plot.iris,plot.mpg,plot.diamonds, layout = matrix(c(1,1,2,3), nrow=2, byrow=TRUE)) 下面看看源码中multiplot函数，本质是grid包！！ 源代码123456789101112131415161718192021222324252627282930313233343536multiplot &lt;- function(..., plotlist=NULL, file, cols=1, layout=NULL) &#123; library(grid) # Make a list from the ... arguments and plotlist plots &lt;- c(list(...), plotlist) numPlots = length(plots) # If layout is NULL, then use 'cols' to determine layout if (is.null(layout)) &#123; # Make the panel # ncol: Number of columns of plots # nrow: Number of rows needed, calculated from # of cols layout &lt;- matrix(seq(1, cols * ceiling(numPlots/cols)), ncol = cols, nrow = ceiling(numPlots/cols)) &#125; if (numPlots==1) &#123; print(plots[[1]]) &#125; else &#123; ###新建图表版面 grid.newpage() ####将版面分成nrow(layout)*ncol(layout)的矩阵 pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout)))) # Make each plot, in the correct location for (i in 1:numPlots) &#123; # Get the i,j matrix positions of the regions that contain this subplot matchidx &lt;- as.data.frame(which(layout == i, arr.ind = TRUE)) print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row, layout.pos.col = matchidx$col)) &#125; &#125;&#125; grid包实现上述相同效果代码12345678grid.newpage() ###新建图表版面grid.text("title of this panel", vp = viewport(layout.pos.row = 1, layout.pos.col = 1:2))pushViewport(viewport(layout = grid.layout(2,2))) ####将版面分成2*2矩阵vplayout &lt;- function(x,y)&#123;viewport(layout.pos.row = x, layout.pos.col = y)&#125;print(plot.iris, vp = vplayout(1,1:2)) ###将（1,1)和(1,2)的位置画图plot.irisprint(plot.mpg, vp = vplayout(2,1)) ###将(2,1)的位置画图plot.mpg print(plot.diamonds , vp = vplayout(2,2)) ###将（2,2)的位置画图plot.diamonds 使用gridExtra包实现上述相同效果123grid.arrange( arrangeGrob(plot.iris,left="A"), arrangeGrob(plot.mpg, left="B"), arrangeGrob(plot.diamonds, left="C"), layout_matrix = matrix(c(1,1,2,3), ncol=2, byrow=TRUE), top = "Title",left = "This is my global Y-axis title") 结果 单个图的标签（A,B,C）位置和属性不是很方便调整 使用gridExtra包实现多图的轴向组合代码12345678910111213141516hist_top &lt;- ggplot()+geom_histogram(aes(mtcars$mpg)) #绘制上方条形图empty &lt;- ggplot()+geom_point(aes(1,1), colour="white")+ theme(axis.ticks=element_blank(), panel.background=element_blank(), axis.line =element_blank(), axis.text.x=element_blank(), axis.text.y=element_blank(), axis.title.x=element_blank(), axis.title.y=element_blank())scatter &lt;- ggplot()+geom_point(aes(mtcars$mpg, mtcars$qsec)) #绘制主图散点图hist_right &lt;- ggplot()+geom_histogram(aes(mtcars$qsec))+coord_flip() #绘制右侧条形图#最终组合，由四个图拼图而成，只是右上角的图已经将各种标注去除了grid.arrange(hist_top, empty, scatter, hist_right, ncol=2, nrow=2, widths=c(4, 1), heights=c(1, 4)) 结果 其实绘制这种组合图已经有相应的R包了–ggExtra代码12345library(ggplot2)df &lt;- data.frame(x = mtcars$mpg, y = mtcars$qsec)p &lt;- ggplot(df, aes(x, y)) + geom_point() + theme_classic()ggExtra::ggMarginal(p, type = "histogram") ggExtra包中最主要的函数ggMarginal - Add marginal histograms/boxplots/density plots to ggplot2 scatterplots 子母图适用场景&emsp;&emsp;当做分组条形图时，有时碰到一组数据特北大，其他组数据特别小，这时候就不太美观了。可能你想到的第一个办法是截断，但其实还可以用字母图，形成局部放大的效果，既可以从整体上对比，又兼顾特别小的数据组可以轻松查看，而没必要单独做两张图。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# 载入需要的包library(plyr)library(Rmisc)library(ggplot2)library(grid)#创建数据A &lt;- rnorm(10,75,10)B &lt;- rnorm(10,12,5)C &lt;- rnorm(10,4,3)Group &lt;- c(rep('A',10),rep('B',10),rep('C',10))Value &lt;- c(A,B,C)D &lt;- data.frame(Group,Value)# 求标准差，后面画误差要用DSe &lt;- summarySE(D,measurevar = 'Value',groupvars = 'Group')# 把组别转化成因子D$Group &lt;- factor(D$Group)# 挑三种颜色C &lt;- c('#55a0fb','#ff8080','#c5944e')#画大图p1 &lt;- ggplot(DSe,aes(Group,Value)) + # 定义环境 geom_bar(aes(Group,Value,fill = Group),stat = 'identity',width = 0.5,show.legend = T) + # 画条形图 geom_errorbar(aes(ymin = Value-se, ymax = Value+se),width = .2) + #加误差线 scale_fill_manual(values = C) + # 配色 labs(x='修改X轴为Group',y='修改Y轴为Value',title = '添加标题')+ theme(axis.title = element_text(face = 'bold'),# 定义主題，如坐标轴，标题样式、背景等 axis.text = element_text(face = 'bold',colour = 'black'), plot.title = element_text(face = 'bold',colour = 'black',hjust = 0.5,size = 20), legend.background = element_rect(I(0),linetype = 1))p1 # 看下效果# 选择小数据集、小颜色集DSe2 &lt;- DSe[2:3,]C2 &lt;- C[2:3]# 画小图，基本和大图一樣，后面要背景透明、显示坐标轴p2 &lt;- ggplot(DSe2,aes(Group,Value)) + geom_bar(aes(Group,Value,fill = Group), stat = 'identity',width = 0.5) + geom_errorbar(aes(ymin = Value-se, ymax = Value+se),width = .2)+ scale_fill_manual(values = C2)+ guides(fill = F)+ theme(axis.text = element_text(face = 'bold',colour = 'black'), axis.title.y = element_blank(), axis.line = element_line(linetype = 1,colour = 'black'), # 显示坐标轴 plot.background = element_rect(I(0),linetype = 0), # 背景透明 panel.background = element_rect(I(0)), panel.grid.major = element_line(colour = NA), panel.grid.minor = element_line(colour = NA))p2 # 看下效果# 嵌套sub &lt;- viewport(width = 0.5,height = 0.4,x = 0.64,y = 0.6) # 配置环境。前兩個是子图的大小比例，后两个是位置，可自行调整到好看位置。p1 # 上大图print(p2,vp = sub) # 加小图 结果 关键代码就是利用了grid包的viewport函数，viewport简单说就是图形中一块矩形区域（类似于图层），是在这个区域中进一步绘图的基础。所以我们可以利用viewport函数在任意指定位置将两个或者多个图进行拼接~ ggplot2之分组和分面&emsp;&emsp;以上是不同数据来源的图，以不同展现形式组合成一个图，另外ggplot2对一个数据集合进行分组，通过分面绘图，也算是实现一页多图的效果吧~ 代码12345678910111213setwd("F:/R working directory/GO enrichment")data&lt;-read.csv("GO.csv",header=TRUE,check.names = FALSE)data_new&lt;-subset(data,data$FDR&lt;0.5)library("ggplot2")ggplot(data=data_new)+ theme(plot.margin=unit(c(1,1,1,3),"cm"))+ #调整作图边距，上，右，下，左 geom_bar(aes(x=Term,y=Count,fill=-log10(Pvalue)),stat="identity")+ #指定横纵变量，stat指定统计变换 scale_fill_gradient(low='red',high='blue')+xlab('')+ylab('')+ #指定注释条带 #指定横纵标签的大小，角度，距离等细节 theme(axis.text.x = element_text(color='black',size = 5,angle=90, hjust=1), axis.text.y = element_text(color='black',size=10))+ facet_grid(.~Type) #根据Type划分作图区块 结果 可以看到结果并不是很好，横轴标签每个分组（BP,CC,MF）均含有13个通路，这是三个分组富集到的GO通路的交集，空值显示出来并不太美观 解决1234567891011setwd("F:/R working directory/GO enrichment")data&lt;-read.csv("GO.csv",header=TRUE,check.names = FALSE)data_new&lt;-subset(data,data$FDR&lt;0.5) #过滤数据Order &lt;-1:dim(data_new)[1] #生成横坐标输出顺序data_order&lt;-cbind(data_new,Order) #数据框添加一列library("ggplot2")ggplot(data=data_order,aes(x=reorder(Term,data_order$Order),y=-log10(Pvalue),fill=Type))+ coord_flip()+ #将图横向 xlab('')+ #覆盖横坐标 theme(plot.margin=unit(c(1,1,1,1),"cm"))+ #调整作图边距，上，右，下，左 geom_bar(stat="identity") 结果 主要通过给数据框加一列来对每一组进行排序输出 参考（1）【R:ggplot2】同时绘制多个图 （2）cowplot：基于ggplot的可视化系统 （3）R语言可视化——图表排版之一页多图 （4）Add labels to a plot made by grid.arrange from multiple plots （5）R语言grid包使用笔记——viewport （6）利用ggplot将多个图形组合在一起（推荐-置信椭圆） （7）Scatterplot with marginal histograms in ggplot2（推荐） （8）你終於會做截斷圖了，可審稿人說不讓做，怎麼破？ （9）ggplot2之分组和分面]]></content>
      <categories>
        <category>R绘图</category>
      </categories>
      <tags>
        <tag>R绘图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文本挖掘与展示之文献关键词]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F10%2F01%2F%E6%96%87%E6%9C%AC%E6%8C%96%E6%8E%98%E4%B8%8E%E5%B1%95%E7%A4%BA%E4%B9%8B%E6%96%87%E7%8C%AE%E5%85%B3%E9%94%AE%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[文本挖掘与展示之文献关键词 &emsp;&emsp;想看看Biotechnology and bioengineering杂志上最新的研究方向及研究热点，通过对文献的keywords进行统计分析，然后用词云进行可视化展示，似乎可行。 文献检索 可以看到我们需要的keywords在\标签下的\段落内，可以通过class = “keywords”进行定位。 火狐浏览器另存页面为PubMed-NCBI.html 利用python的bs4模块解析html文件123456789101112131415161718192021# coding=utf-8import osfrom bs4 import BeautifulSoupos.chdir(r'F:\pycharm_project\bs4')# 读取html文件并生成Soup对象File = open('PubMed-NCBI.html',encoding='UTF-8')Soup = BeautifulSoup(File,"lxml")# 使用finfAll方法定位class属性为keywords的div块，存入列表divs = Soup.findAll('div', &#123;'class':'keywords'&#125;)resultFile = open(r'.\keywords_result.txt', 'w',encoding='UTF-8')# 遍历列表divs，将结果keywords写入文件for div in divs: resultFile.write(div.p.string + '\n')resultFile.close() 利用R绘制词云进行展示123456789101112131415161718192021222324#第一步：读取setwd("F:/R working directory/wordcloud")text&lt;-scan("keywords_result.txt",what='')#第二步：分词library(jiebaR) ##加载包engine_s&lt;-worker() ##初始化分词器seg&lt;-segment(text,engine_s) ##分词head(seg)f1&lt;-freq(seg) ##统计词频head(f1)f2&lt;-f1[order((f1)[2],decreasing=TRUE),]##根据词频降序排列head(f2) # 第三步：绘图library(wordcloud2)#加载wordcloud2包wordcloud2(f2, size = 0.8 ,shape='star')#绘制成五角形状词云letterCloud(f2, size=1, word="生信学习") #绘制成字符 参考（1）python网络数据采集.pdf （2）https://mp.weixin.qq.com/s/Zhq7ysZ5wAvWNhPEauhRsQ]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pandas使用入门]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F10%2F01%2Fpandas%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[pandas使用入门 pandas从文件读写数据读取数据 读取txt数据（read_table默认以tab键分割数据） Exp_matrix = pd.read_table(r’.\data\game_of_thrones_geneExp.txt’) 读取csv数据（read_csv默认以逗号分割数据） Exp_matrix = pd.read_csv(r’.\data\game_of_thrones_geneExp.csv’) 读取数量不定的空白符分割的txt文件 Exp_matrix = pd.read_table(r’.\data\game_of_thrones_geneExp.txt’,sep=’\s+’) 读取Excel文件数据 xls_file = pd.ExcelFile(‘data.xls’)&emsp;&emsp; #创建ExcelFile实例 table = xls_file.parse( ‘Sheet1’) &emsp;&emsp; #通过parse读取到DataFrame （对于使用复杂分隔符或多字符串分隔符的文件，csv模块就无能为力了。这种情况下，就只能使用字符串的split方法或者正则表达式的re.split进行拆分和整理了） 读数据时关于行列名选项 header=None &emsp;&emsp; #指定列名从0开始增长的数 names=[‘a’,’b’,’c’,’d’,’e’] &emsp;&emsp; #用names参数指定列名 index_col=’e’ &emsp;&emsp; #用指定的列作为行名（index） 逐块读取文本文件 nrows = 5 &emsp;&emsp; #只读取文件前5行 其他参数 使用skiprows跳过文件的某些行 skiprows = [0,2,3] 写数据至文件 写入csv文件 result.to_csv(‘D:\data\out1.csv’) 写数据时关于行列名选项 index=False &emsp;&emsp; #舍弃行名 header=False &emsp;&emsp; #舍弃列名 其他参数 sep = ‘|’ &emsp;&emsp; #指定分隔符 na_rep = ‘NULL’ &emsp;&emsp; #指定缺失值表示符号 数据规整化：清理，转换，合并，重塑pandas访问元素 取前8行 Exp_matrix_class_3 = Exp_matrix[0:8] 取前8列 Exp_matrix_class_3 = Exp_matrix[Exp_matrix.columns[0:8]] 取前8行，及1-3列 Exp_matrix_class_3 = Exp_matrix.iloc[0:8,1:4] 根据条件筛选行 Exp_matrix[Exp_matrix[‘Class’] == 3] 数据框转置 Exp_matrix_class_3_T = Exp_matrix_class_3.T 注意： (1)行列最小从0开始 (2)取值区间左闭右开 Dataframe 排序 逆序 Exp_matrix_T.sort_values([‘abs_dif_3_5’], ascending=False) 轴向连接 行合并 result = pd.concat([Exp_matrix_T[1:2],result_gene]) 增加一列 Exp_matrix_T[‘abs_dif_3_5’] = abs_dif_3_5 计算描述统计：统计函数 方法 说明 count 非NA值的数量 describe 针对Series或各DataFrame列计算汇总统计 min,max 计算最小值和最大值 argmin,argmax 计算能够获取到最小值和最大值的索引位置（整数) idxmin,idxmax 计算能够获取到最小值和最大值的索引值 quantile 计算样本的分位数（0到 1） sum 值的总和 mean 值的平均数， a.mean() 默认对每一列的数据求平均值；若加上参数a.mean(1)则对每一行求平均值 media 值的算术中位数（50%分位数) mad 根据平均值计算平均绝对离差 var 样本值的方差 std 样本值的标准差 skew 样本值的偏度（三阶矩） kurt 样本值的峰度（四阶矩） cumsum 样本值的累计和 cummin,cummax 样本值的累计最大值和累计最小 cumprod 样本值的累计积 diff 计算一阶差分（对时间序列很有用) pct_change 计算百分数变化 参考（1）PANDAS 数据合并与重塑（concat篇） （2）pandas数据的导入与导出 （3）使用Pandas对数据进行筛选和排序 （4）pandas小记：pandas计算工具-汇总统计 （5）资源 | 23种Pandas核心操作，你需要过一遍吗？]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux的CPU拓扑结构（Topology）]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F09%2F17%2Flinux%E7%9A%84CPU%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84%EF%BC%88Topology%EF%BC%89%2F</url>
    <content type="text"><![CDATA[由一次教训驱动的学习 &emsp;&emsp;“用服务器的同学注意下，以后请尽量不要在登录节点（frontend）提交任务，实在需要提交任务请注意任务消耗的资源情况，以免内存耗尽导致服务器死机！因为登录节点死机的话其他节点就都无法使用了！” 登陆节点frontend： [wangdong@frontend ~]$ 查看某一节点cpu使用情况例如第6节点： ssh node6 &apos;top -n 1 -b&apos;| head 批量查看节点cpu使用情况for((i=2;i&lt;=8;i++));do ssh node${i} &apos;top -n 1 -b&apos;| head ;done 更换节点例如更换至6节点： ssh node6 [wangdong@node6 ~]$ 具体含义：参考 不切换当前节点，在其他节点运行命令直接把命令写在ssh nodeX后面，然后是我习惯于加引号 ssh nodeX &apos;command&apos; 注意： 登录节点主要用于日常操作，如提交作业、查看作业运行情况、编辑、编译、压缩/解压缩等 不要在登录节点不通过作业调度系统直接运行作业，以免影响其余用户的正常使用 &emsp;&emsp;一般跑小程序不用考虑这些，但大程序消耗内存很大，所以尽量不要在登录节点（frontend）提交任务，实在需要提交任务请注意任务消耗的资源情况，以免内存耗尽导致服务器死机！因为登录节点死机的话其他节点就都无法使用了。 补充命令top查看当前运行的任务情况&emsp;&emsp;linux下用top命令查看cpu利用率超过100%。这里显示的所有的cpu加起来的使用率，说明你的CPU是多核，你运行top后按大键盘1看看，可以显示每个cpu的使用率，top里显示的是把所有使用率加起来。 注意： 按下1后可以看到我的机器的CPU是16核的。%Cpu0,,,,,,%Cpu15。 若是 0 代表目前该核心空闲， 可以运算作业。 100代表 cpu核心满负荷运算。若某个节点 16 个 CPU 负荷已很高， 换至其余空闲节点运算作业。 建议一个计算节点核心数最多使用 15 核。 查看 CPU Topology（拓扑结构）：cat /proc/cpuinfo 具体含义：参考 逻辑CPU个数： cat /proc/cpuinfo | grep ‘processor’ | wc -l 物理CPU个数： cat /proc/cpuinfo | grep ‘physical id’ | sort | uniq | wc -l 每个物理CPU中Core的个数： cat /proc/cpuinfo | grep ‘cpu cores’ | wc -l 查看内存的总量及消耗free -g 具体含义 参考 补充知识NUNA与SMP&emsp;&emsp;NUMA(Non-Uniform Memory Access，非一致性内存访问)和SMP(Symmetric Multi-Processor，对称多处理器系统)是两种不同的CPU硬件体系架构。 &emsp;&emsp;SMP的主要特征是共享，所有的CPU共享使用全部资源，例如内存、总线和I/O，多个CPU对称工作，彼此之间没有主次之分，平等地访问共享的资源，这样势必引入资源的竞争问题，从而导致它的扩展内力非常有限。 &emsp;&emsp;NUMA技术将CPU划分成不同的组（Node)，每个Node由多个CPU组成，并且有独立的本地内存、I/O等资源。Node之间通过互联模块连接和沟通，因此除了本地内存外，每个CPU仍可以访问远端Node的内存，只不过效率会比访问本地内存差一些，我们用Node之间的距离（Distance，抽象的概念）来定义各个Node之间互访资源的开销。 &emsp;&emsp;如果你只知道CPU这么一个概念，那么是无法理解CPU的拓扑的。事实上，在NUMA架构下，CPU的概念从大到小依次是：Node、Socket、Core、Processor（Node-&gt;Socket-&gt;Core-&gt;Processor） &emsp;&emsp;随着多核技术的发展，我们将多个CPU封装在一起，这个封装一般被称为Socket（插槽的意思，也有人称之为Packet，不知到哪个更加准确？），而Socket中的每个核心被称为Core。为了进一步提升CPU的处理能力，Intel又引入了HT（Hyper-Threading，超线程)的技术，一个Core打开HT之后，在OS看来就是两个核，当然这个核是逻辑上的概念，所以也被称为Logical Processor，本文简称为Processor。 &emsp;&emsp;综上所述，一个NUMA Node可以有一个或者多个Socket，一个多核Socket显然包含多个Core，一个Core如果打开HT则变成两个Logical Processor。 Logical processor只是OS内部看到的，实际上两个Processor还是位于同一个Core上，所以频繁的调度仍可能导致资源竞争，影响性能。 查看Numa Nodenumactl是设定进程NUMA策略的命令行工具，也可以用来查看当前的Nuwa node: numactl --hardware 从上面可以看出本机有两个Numa node，如果要进一步知道一个Node包含哪几个CPU，该怎么办？ 一种方法是通过查看ls /sys/devices/system/node/目录下的信息，例如： cpu0 cpu1 cpu10 cpu11 cpu2 cpu3 cpu8 cpu9 cpumap distance meminfo numastat 可见, node0包含4/5/6/7/12/13/14/15八个Processor（刚好是一个Socket）。 查看Socket&emsp;&emsp;一个Socket对应主板上的一个插槽，在本文中是指一个CPU封装。在/proc/cpuinfo中的physical id就是Socket的ID，可以从中找到本机到底有多少个Socket，并且每个Socket有那几个Processor。 1) 查看有几个Socket $ grep &apos;physical id&apos; /proc/cpuinfo | awk -F: &apos;{print $2 | &quot;sort -un&quot;}&apos; 0 1 $ grep &apos;physical id&apos; /proc/cpuinfo | awk -F: &apos;{print $2 | &quot;sort -un&quot;}&apos; | wc -l 2 2) 查看每个Socket有几个Processor $ grep &apos;physical id&apos; /proc/cpuinfo | awk -F: &apos;{print $2}&apos; | sort | uniq -c 8 0 8 1 3) 查看Socket对应那几个Processor 123456789101112131415awk -F: '&#123; if ($1 ~ /processor/) &#123; gsub(/ /,"",$2); p_id=$2; &#125; else if ($1 ~ /physical id/)&#123; gsub(/ /,"",$2); s_id=$2; arr[s_id]=arr[s_id] " " p_id &#125;&#125; END&#123; for (i in arr) print arr[i];&#125;' /proc/cpuinfo | cut -c2- 0 1 2 3 8 9 10 114 5 6 7 12 13 14 15 查看Core/proc/cpuinfo文件中的cpu cores表明一个socket中有几个cores，例如： cat /proc/cpuinfo | grep &apos;core&apos; | sort -u 上面的结果说明一个socket有4个cores，它们的id分别为0/1/9/10，根据之前查到的我们的机器有2个socket，所以总共有8个core。 查看Processor&emsp;&emsp;查看Processors的个数就比较简单了，从上面的统计结果中我们已经可以知道有16个Logical processor，不过也可以直接从/proc/cpuinfo文件中获取： $ grep &apos;processor&apos; /proc/cpuinfo | wc -l 16 参考（1）http://www.bio-info-trainee.com/1028.html （2）rabbit gao’s blog （3）http://blog.csdn.net/huangshanchun/article/details/44397581 （4）团子的小窝 （推荐） （5）http://tieba.baidu.com/p/1285719732?red_tag=s0690960116]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R语言之批量导入csv文件，并以文件名作为变量名]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F09%2F04%2FR%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5csv%E6%96%87%E4%BB%B6%EF%BC%8C%E5%B9%B6%E4%BB%A5%E6%96%87%E4%BB%B6%E5%90%8D%E4%BD%9C%E4%B8%BA%E5%8F%98%E9%87%8F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;当要处理一批csv文件时，一个一个读入就太麻烦而且太low了。那么如何一次将工作路径的csv文件读入当前环境空间（Environment），并且使用文件名作为变量名，使用时直接调用即可呢?? 批量读入csv文件12345#将列表中文件读入环境空间，并以文件名作为变量名mycsvfile = list.files(pattern="*.csv") #生成.csv文件的列表list2env( lapply(setNames(mycsvfile, make.names(gsub("*.csv$", "", mycsvfile))), read.csv,header=TRUE,check.names=FALSE), envir = .GlobalEnv) 当然，上述语句也可以用于批量读入txt文件1234mytxtfile = list.files(pattern="*.txt")list2env( lapply(setNames(mytxtfile, make.names(gsub("*.txt$", "", mytxtfile))), read.table,header=TRUE,sep="\t"), envir = .GlobalEnv) 批量读入自定义函数对于自定义的函数，可以通过source函数导入环境空间，然后才能调用，当然也可以写个函数，调用此函数批量导入罗！！！ 12345678sourceDir &lt;- function(path, trace = TRUE, ...) &#123; for (nm in list.files(path, pattern = "[.][RrSsQq]$")) &#123; if(trace) cat(nm,":") source(file.path(path, nm), ...) if(trace) cat("\n") &#125;&#125;sourceDir("自定义函数所在文件夹的完整路径") 补充：涉及到的语法，包括R语言的环境空间，正则表达式。 1.R语言的环境空间 在R语言中，不管是变量，对象，或者函数，都存在于R的环境空间中，R程序在运行时都有自己的运行空间。 1234567# 当前环境空间&gt; .GlobalEnv# 列出当前环境中的变量 &gt; ls()# 查看环境空间加载的包&gt; search() 2.正则表达式 12pattern="*.csv" #list.files函数中用正则表达式匹配文件名的一个选项gsub("*.txt$", "", mytxtfile) #匹配以.txt结尾的文件名，将其替换为空，也就是去掉.txt，只留文件名作为变量名 3.lapply函数用于对mytxtfile列表中的文件，都应用read.csv函数，从而实现批量读取文件]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现excel二维表格格式化]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F09%2F02%2Fpython%E5%AE%9E%E7%8E%B0excel%E4%BA%8C%E7%BB%B4%E8%A1%A8%E6%A0%BC%E6%A0%BC%E5%BC%8F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Excel 是 Windows 环境下流行的、强大的电子表格应用。openpyxl 模块让 Python 程序能读取和修改 Excel 电子表格文件。例如，可能有一个无聊的任务，需要从一个电子表格拷贝一些数据，粘贴到另一个电子表格中。或者可能需要从几千行中挑选几行，根据某种条件稍作修改。或者需要查看几百份部门预算电子表格，寻找其中的赤字。正是这种无聊无脑的电子表格任务，可以通过 Python 来完成。 &emsp;&emsp;同时，发现之前写了很多小脚本，但代码的复用率极低。因此，今后的代码得更加注意用函数进行代码的封装。EXCEL中行的排序及筛选比较容易，但对于列比较麻烦。在此，通过一个对EXCEL列排序及筛选（取子列）的例子进行演示。 sort_column.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# -*- coding:utf-8 -*-'''EXCEL文件列根据自定义规则排序'''__file__ = 'sort_column.py'__date__ = '2017-9-2'__version__ = '0.1'__author__ = 'anjing'__blog__ = 'https://anjingwd.github.io/'__license__ = 'GPL v3 License'def sort_column(file, row1, column1_letter ,column2_letter): import openpyxl from openpyxl.cell import column_index_from_string #列字母和数字之间的转换 column1_num = column_index_from_string(str(column1_letter)) column2_num = column_index_from_string(str(column2_letter)) #从工作簿中取得工作表 wb = openpyxl.load_workbook(file) sheet1 = wb.get_sheet_by_name('Sheet1') sheet2 = wb.get_sheet_by_name('Sheet2') sheet3 = wb.create_sheet('result_sorted') #按顺序记录下待排序列的列号 order = [] #注意range范围是左闭区间，右开区间 for i in range(1,sheet2.max_row+1): for j in range(column1_num, column2_num+1): if sheet2.cell(row=i, column=1).value == sheet1.cell(row=row1, column=j).value: order.append(j) #将排序结果写入新的sheet3 count = column1_num for j in order: for i in range(row1, sheet1.max_row+1): sheet3.cell(row=i, column=count).value = sheet1.cell(row=i, column=j).value count += 1 #将起始列之前的列写入，一般是行名等 for i in range(row1, sheet1.max_row+1): for j in range(1, column1_num): sheet3.cell(row=i, column=j).value = sheet1.cell(row=i, column=j).value # 写入之后需要保存 wb.save(file) print("Everything has been done")######################################################################################################if __name__ == "__main__": print('对excel文件指定列区间排序，sheet1为数据，sheet2为自定义顺序顺序。') print('四个参数：输入excel绝对路径，需排序列的标题，列的起始列，终止列') print(r'用法例如：python sort_column.py F:\pycharm_project\excel_format\new1.xlsx 1 H AU') #Sys.argv是一个元组，里边的项为用户从程序外部输入的参数 import sys file = sys.argv[1] row1 = int(sys.argv[2]) column1_letter = sys.argv[3] column2_letter = sys.argv[4] sort_column(file, row1, column1_letter, column2_letter) 测试数据 new1.xlsxSheet1 Sheet2 使用在cmd下进入脚本sort_column.py和测试数据new1.xlsx所在目录，运行： python sort_column.py F:\pycharm_project\excel_format\new1.xlsx 1 B S 结果result_sorted 参考（1）书籍-Python编程快速上手让繁琐工作自动化–第12章处理 Excel 电子表格]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决ggplot 作图x轴和y轴不重合问题]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F09%2F01%2F%E8%A7%A3%E5%86%B3ggplot-%E4%BD%9C%E5%9B%BEx%E8%BD%B4%E5%92%8Cy%E8%BD%B4%E4%B8%8D%E9%87%8D%E5%90%88%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[解决ggplot 作图x轴和y轴不重合问题 只需要在作图时加上加上一下代码，即可即可让x轴和y轴在坐标原点重合： scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) 现在用测试代码看看前后变化： library(ggplot2) df &lt;- data.frame(x = 1:5, y = 1:5) p1 &lt;- ggplot(df, aes(x, y)) + geom_point() p1 &lt;- p1 + expand_limits(x = 0, y = 0) p1 library(ggplot2) df &lt;- data.frame(x = 1:5, y = 1:5) p2 &lt;- ggplot(df, aes(x, y)) + geom_point() p2 &lt;- p2 + expand_limits(x = 0, y = 0)+ scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) p2 参考： （1）http://stackoverflow.com/questions/36669095/y-axis-wont-start-at-0-in-ggplot （2）http://stackoverflow.com/questions/13701347/force-the-origin-to-start-at-0-in-ggplot2-r （3）http://stackoverflow.com/questions/29955618/starting-y-axis-at-0-using-ggplot-and-facet-wrap]]></content>
      <categories>
        <category>R绘图</category>
      </categories>
      <tags>
        <tag>R绘图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[批量fastqc]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F08%2F30%2F%E6%89%B9%E9%87%8Ffastqc%2F</url>
    <content type="text"><![CDATA[分别介绍使用循环和MultiQC软件两种方式批量进行fastqc 方法一：循环与命令并行问： 我当前文件夹下面有100个fastq测序文件，我要批量对他们运行fastqc软件（软件安装目录：~/biosoft/fastqc ）来处理，所以写了脚本 ls *fastq | while read id ; do ~/biosoft/fastqc $id;done 但是这样有一个弊端，就是这100个fastq测序文件是一个个被运行，这样耗时太长！所以我稍作修改： ls *fastq | while read id ; do nohup ~/biosoft/fastqc $id &amp; ;done 这样又一下子把100个fastqc任务提交了，我的服务器根本受不了。 所以需要修改修改脚本，让它一下子并行提交10个任务，因为我服务器限制。 该如何最简单的完成呢？ 答：加个参数-p ls *fastq | xargs -n 1 -p 10 -i FQ ~/biosoft/fastqc FQ 每次最多提交10个文件，加-p就可以并行计算啦 方法二：MultiQChomepage: http://multiqc.info 功能：把多个测序结果的qc结果整合成一个报告。支持fastqc、trimmomatic、bowtie、STAR等多种软件结果的整合。 Installation 安装conda install -c bioconda multiqc Run MultiQC 运行安装好后，进入你要分析的测序文件所在的文件夹，直接输入multiqc加要扫描的目录即可运行，如果要扫描当前文件夹，直接输入”multiqc .”即可 multiqc . multiqc /data/mydir/ multiqc /data/*fastqc.zip multiqc /data/sanple_1* 相关参数使用“–ignore”参数忽略某些文件multiqc . --ingore *_R2* multiqc . --ignore run_two/ multiqc . --ignore */run_three/*/fastqc/*.zip 使用文本指定要分析的文件的路径multiqc --file-list_my_file_list.txt 重命名输出结果分析结果默认命名为“multiqc_report.html”，相关的以tab风格的data file保存在“multiqc_data”文件夹下。可以用“-n”参数改变结果文件的名字，用“-o”改变输出文件的位置。 覆盖已存在的结果添加参数“-f”，输出结果时会自动覆盖同名文件。 更换报告模板添加参数“-t”或者“–template”可以选择不同风格的报告模板，具体内容请查看帮助文档“multiqc –help”。同时，MultiQC也支持自行创作结果文件的模板。 输出图片Exporting plot除了直接输出html文件外，Multiqc还可以直接保存图片文件。用以下参数进行保存： multiqc -p/--export 默认设置下，图片会保存在“multiqc_plots”文件夹中，以.png/.svg或者pdf格式保存。 同时，也可以直接在html文件中使用“toolbox”中的Export 保存图片。 报告正文报告页面分为三部分，左边是导航页面，中间是报告正文，右边是toolbox General Statistics （Configure Conlumns）可选择需要展示的列名 点击列名可进行排序 (plot)可选择任意两列进行plot Toolbox 工具栏主要有Hightlight Samples、Rename Samples、Show/Hide Samples、Export Plots、Saving Setting以及帮助等功能。 参考（1）https://mp.weixin.qq.com/s/tuGWPqCAG4TvIxpGsYWIDA（2）http://www.cnblogs.com/leezx/p/7360668.html]]></content>
      <categories>
        <category>NGS</category>
      </categories>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修复Chrome浏览器崩溃]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F08%2F28%2F%E4%BF%AE%E5%A4%8DChrome%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B4%A9%E6%BA%83%2F</url>
    <content type="text"><![CDATA[Chrome浏览器一进入就全面崩溃，包括设置页面！ 解决办法： 原因就是 C:\Windows\System32\drivers\bd0001.sys 这个文件 首先可以把这个文件利用360杀毒工具强力删除。 因为书签路径是 C:\Users\Administrator\AppData\Local\Google\Chrome\User Data,所以然后将原Google删除（C:\Program Files (x86)\Google）并不会删除书签。 重新安装Chrome稳定版ChromeStandalone_60.0.3112.101_Setup.exe 重启电脑即可！ &emsp;&emsp;win7不能删除文件提示(您需要来自administrators的权限才能对此文件夹进行更改）该如何解决呢？ 可以使用360杀毒–功能大全-文件粉碎机]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用bash脚本下载和处理基因表达数据]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F08%2F25%2F%E4%BD%BF%E7%94%A8bash%E8%84%9A%E6%9C%AC%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%A4%84%E7%90%86%E5%9F%BA%E5%9B%A0%E8%A1%A8%E8%BE%BE%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[使用bash脚本从ArrayExpress下载和处理基因表达数据（去接头和质控），也就是练习写生信分析pipline ArrayExpress数据库简介&emsp;&emsp;ArrayExpress是EBI的微阵列实验和基因表达谱的公共数据库，它是一个一般的基因表达数据库，设计用来保存来自所有微阵列平台的数据。ArrayExpress使用MIAME(Minimum Information About a Microarray Experiment，有关微阵列实验的最小化信息)注释标准及相关的XML数据交换格式MAGE-ML(Microarray Gene Expression Markup Language，微阵列基因表达标记语言)，它被设计成以结构化的方式来存储良好注释的数据。ArrayExpress基础结构由数据库本身，以MAGE-ML格式的数据提交或通过在线的提交工具MIAMExpress，在线数据库查询接口，Expression Profiler在线分析工具组成。ArrayExpress提供三种类型的提交，阵列，实验和实验方案，它们中的每一个都分配一个登录号。数据提交和注释的帮助由监管小组提供。数据库可以用诸如作者，实验室，物种，试验或阵列类型等参数进行查询。 随着越来越多的(an increasing number of)组织采用MAGE-ML标准，提交到ArrayExpress的量在快速增长着。 具体步骤1.AEArrayExpress主页搜索E-MTAB-567 https://www.ebi.ac.uk/arrayexpress/ 点击Export table in Tab-delimited format，下载E-MTAB-567.sdrf.txt 2.提取status,ID,link grep &apos;fastq.gz&apos; E-MTAB-567.sdrf.txt | head -2 | awk &apos;{print $39&quot;,&quot;$21&quot;,&quot;$35}&apos; &gt; status,ID,link.csv 输出: 3.mainPipeline.sh 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#!/bin/bashset -uset -eset -o pipefail#####################################################################################################################################################################################################################使用bash脚本从ArrayExpress下载和处理基因表达数据（去接头和质控）#####################################################################软件安装##安装fastx_toolkitconda install fastx_toolkit ##安装FastQconda install fastqc#################################################################################################################################################提取相关信息（extract.sh）for LINE in $(cat status,ID,link.csv)do echo $LINE STATUS=$(echo $LINE|cut -d, -f1) ID=$(echo $LINE|cut -d, -f2) LINK=$(echo $LINE|cut -d, -f3) FILE=$(basename $LINK) STEM=$(basename $LINK .gz) NEWID=$STATUS.$ID echo $STATUS, $ID, $LINK, $STEM, $FILE, $NEWID##############################################################################################输出：#u641750@GenekServer:~$ ./extract.sh #Normal,10N_1,ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR031/ERR031017/ERR031017_1.fastq.gz#Normal, 10N_1, ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR031/ERR031017/ERR031017_1.fastq.gz, ERR031017_1.fastq, ERR031017_1.fastq.gz, Normal.10N_1#Normal,10N_2,ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR031/ERR031017/ERR031017_2.fastq.gz#Normal, 10N_2, ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR031/ERR031017/ERR031017_2.fastq.gz, ERR031017_2.fastq, ERR031017_2.fastq.gz, Normal.10N_2#例如：$STATUS：Normal, $ID:10N_1, $LINK:ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR031/ERR031017/ERR031017_1.fastq.gz , $STEM:ERR031017_1.fastq, $FILE:ERR031017_1.fastq.gz, $NEWID:Normal.10N_1################################################################################################################################################[ -d ./fastqFiles ]|| mkdir -p ./fastqFiles#下载数据 if [ ! -f ./fastqFiles/$NEWID.$STEM ];then wget $LINK gunzip $FILE mv $STEM ./fastqFiles/$NEWID.$STEM #移动并改名 fidone##############################################################################################输出：#u641750@GenekServer:~/fastqFiles$ ls -l#total 16341536#-rw-r--r-- 1 u641750 GenekVIP 8358690360 Aug 22 21:29 Normal.10N_1.ERR031017_1.fastq#-rw-r--r-- 1 u641750 GenekVIP 8358690360 Aug 25 13:20 Normal.10N_2.ERR031017_2.fastq#################################################################################################################################################质量控制(修剪)[ -d ./trimmed/fastQC ]||mkdir -p ./trimmed/fastQCfor FILE in ./fastqFiles/*.fastqdo ls -lh $FILE STEM=$(basename $FILE .fastq) if [ ! -f ./trimmed/$STEM.trimmed.fastaq ];then fastq_quality_trimmer -v -t 20 -l 20 -Q 33 -i $FILE -o ./trimmed/$STEM.trimmed.fastq fidone##############################################################################################结果#u641750@GenekServer:~/trimmed$ ls#fastQC Normal.10N_1.ERR031017_1.trimmed.fastq Normal.10N_2.ERR031017_2.trimmed.fastq#输出：#-rw-r--r-- 1 u641750 GenekVIP 7.8G Aug 22 21:29 ./fastqFiles/#Normal.10N_1.ERR031017_1.fastq#Minimum Quality Threshold: 20#Minimum Length: 20#Input: 34536162 reads.#Output: 34458851 reads.#discarded 77311 (0%) too-short reads.#-rw-r--r-- 1 u641750 GenekVIP 7.8G Aug 25 13:20 ./fastqFiles/#Normal.10N_2.ERR031017_2.fastq#Minimum Quality Threshold: 20#Minimum Length: 20#Input: 34536162 reads.#Output: 33968272 reads.#discarded 567890 (1%) too-short reads.#################################################################################################################################################质量控制（评估）[ -d ./trimmed/fastQC ]||mkdir -p ./trimmed/fastQCFASTQC=/home/u641750/miniconda3/bin/fastqcfor FILE in ./trimmed/*.trimmed.fastqdo ls -lh $FILE STEM=$(basename $FILE .fastq) if [ ! -d ./trimmed/fastQC/$STEM_fastqc ]; then $FASTQC -o ./trimmed/fastQC $FILE fidone##############################################################################################结果：#u641750@GenekServer:~/trimmed/fastQC$ ls#Normal.10N_1.ERR031017_1.trimmed_fastqc.html#Normal.10N_1.ERR031017_1.trimmed_fastqc.zip#Normal.10N_2.ERR031017_2.trimmed_fastqc.html#Normal.10N_2.ERR031017_2.trimmed_fastqc.zip#################################################################################################################################################改名for FILEONE in ./trimmed/*_1.trimmed.fastqdo STEM=$(basename $FILEONE _1.trimmed.fastq | sed '' s/_1//g') FILETWO=$(echo $FILEONE | sed 's/_1./_2./g') ls -lh $FILEONE ls -lh $FILETWO echo stem $STEMexit done##############################################################################################输出#-rw-r--r-- 1 u641750 GenekVIP 7.5G Aug 25 15:29 ./trimmed/Normal.10N_1.ERR031017_1.trimmed.fastq#-rw-r--r-- 1 u641750 GenekVIP 7.5G Aug 25 15:44 ./trimmed/Normal.10N_2.ERR031017_2.trimmed.fastq#stem Normal.10N.ERR031017################################################################################################################################################ 在后台运行脚本nohup ./mainPipeline.sh &gt; outMainPipeline.log &amp; 附录：1.基本命令：basename 用途:返回一个字符串参数的基本文件名称 语法:basename String [ Suffix ] 描述:basename 命令读取 String 参数，删除以 /(斜杠) 结尾的前缀以及任何指定的 Suffix 参数，并将剩余的基本文件名称写至标准输出。 （截取文件名）例如，输入： basename Normal.10N_1.ERR031017_1.trimmed.fastq _1.trimmed.fastq 结果是：Normal.10N_1.ERR031017 例如，输入： basename /u/dee/desktop/cns.boo cns.boo 结果是：cns.boo 如果指定 Suffix（后缀名）参数，且它和字符串中所有字符都不相同，但和字符串的后缀相同，则除去指定后缀。例如，输入： basename /u/dee/desktop/cns.boo .boo 结果是：cns 2.fastq_quality_trimmer fastq_quality_trimmer [-h] [-v] [-t N] [-l N] [-z] [-i INFILE] [-o OUTFILE] 修剪reads的末端 [-t N] = 从5’端开始，低与N的质量的碱基将被修剪掉 [-l N] = 修建之后的reads的长度允许的最短值 [-z] = 压缩输出 [-v] =详细-报告序列编号，如果使用了-o则报告会直接在STDOUT，如果没有则输入到STDERR 3.以下代码段用于脚本的分步测试 1234567891011##########################################################用于测试STATUS="do"#STATUS="done"if [ $STATUS !="done" ];then do somethingfi######################################################### 参考:（1）Bash scripting for Bioinformatics https://www.youtube.com/watch?v=3ME7gayYeUQ （2）Linux命令之basename 命令 http://blog.sina.com.cn/s/blog_5f70c7060100ukyh.html （3）高通量测序数据的质控工具—fastx_toolkit软件使用说明 http://blog.sciencenet.cn/blog-1509670-848270.html]]></content>
      <categories>
        <category>NGS</category>
      </categories>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令之nohup]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F08%2F25%2Flinux%E5%91%BD%E4%BB%A4%E4%B9%8Bnohup%2F</url>
    <content type="text"><![CDATA[命令后台运行及相关操作 nohup命令参考用途：该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思( no hang up) 语法：nohup Command [ Arg … ] [ &amp; ] 描述：nohup 命令运行由 Command 参数和任何相关的 Arg 参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 &amp; （ 表示”and”的符号）到命令的尾部 将任务移至后台在应用Unix/Linux时，我们一般想让某个程序在后台运行，于是我们将常会用 &amp; 在程序结尾来让程序自动运行。比如我们要在后台运行一个aaa.sh的脚本： ./test2.sh &amp; 可是当我们注销或者屏保后，这个脚本就会自动停止，这时我们就需要nohup命令， 怎样使用nohup命令呢？请看: [wangdong@frontend ~]$ nohup ./test2.sh &amp; [1] 18569 [wangdong@frontend ~]$ nohup: ignoring input and appending output to `nohup.out&apos; 注意： 只有当虚拟终端是 $ 或者 # 时候（如下图所示），才可关闭此终端，否则可能导致已经启动的进程被关闭（如果程序持续输出信息而没有出现 $ 或 #，按一下enter即可） 后台执行脚本（有多个脚本，每个窗口最好只执行一个），如果在同一个窗口执行，下个执行命令需要等待前面一个执行完成才能执行，这种效率不是我们要的。 无论是否将 nohup 命令的输出重定向到终端，输出都将附加到当前目录的 nohup.out 文件中，起到了log的作用。 如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。除非另外指定了输出文件：nohup command &gt; myout.file 2&gt;&amp;1 &amp; /dev/null 是黑洞路径， 可用于用于丢弃输出，例如nohup COMMAND &gt; /dev/null &amp; 其他操作用 jobs 命令可以查看当前Screen中的后台任务。jobs [1]+ Done nohup ./test2.sh （1）jobs命令执行的结果，＋表示是一个当前的作业，减号表是是一个当前作业之后的一个作业。 （2）jobs -l 选项可显示所有任务的PID, （3）jobs的状态可以是running, stopped, Terminated 但当关闭该窗口在打开查看，这时候jobs已经不能使用，只能通过以下方式查看后台执行的脚本是否正在执行 ps -ef | grep conda #grep conda用于过滤命令 用 fg JOBID 命令可以将后台的任务调入前台继续运行（Foreground）。&emsp;&emsp;如果执行完后台脚本命令，当前窗口没有关闭，可以执行jobs查看当前窗口运行的后台进程的进程号，再通过fg n，将此后台进程调到前台执行。 命令在前台执行一半了，想转入后台执行 首先用 ctrl + z 快捷键可以将一个正在前台执行的命令放到后台，并且暂停 接着用 bg JOBID 命令可以将一个在后台暂停的命令，变成继续执行（Background）。 进程的终止前台进程的终止：ctrl+c 后台进程的终止： 方法一：通过jobs命令查看job号（假设为num），然后执行kill num 方法二：通过ps命令查看job的进程号（PID，假设为pid），然后执行kill pid 补充概念：当前任务&emsp;&emsp;如果后台的任务号有2个，[1],[2]；如果当第一个后台任务顺利执行完毕，第二个后台任务还在执行中时，当前任务便会自动变成后台任务号码“[2]”的后台任务。所以可以得出一点，即当前任务是会变动的。当用户输入“fg”、“bg”和“stop”等命令时，如果未指定jobsid，则所变动的均是当前任务。 ps -ef 是用标准的格式显示进程的 其中各列的内容意思如下 UID //用户ID、但输出的是用户名 PID //进程的ID PPID //父进程ID C //进程占用CPU的百分比 STIME //进程启动到现在的时间 TTY //该进程在那个终端上运行，若与终端无关，则显示? 若为pts/0等，则表示由网络连接主机进程。 CMD //命令的名称和参数 参考（1）http://rajaruan.blog.51cto.com/2771737/822199 （2）https://wenku.baidu.com/view/28863c79581b6bd97f19ead8.html （3）http://blog.sina.com.cn/s/blog_673ee2b50100iywr.html]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建生信分析pipline（dna-seq/rna-seq）-基础版]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F08%2F22%2F%E5%88%9B%E5%BB%BA%E7%94%9F%E4%BF%A1%E5%88%86%E6%9E%90pipline(DNA-seq%2CRNA-seq)-%E5%9F%BA%E7%A1%80%E7%89%88%2F</url>
    <content type="text"><![CDATA[创建生信分析pipline（dna-seq/rna-seq）-基础版 dna-seq建立项目文件系统(step1-prep_mkdir_cp.sh)1234567891011121314#建立合理的文件结构cdmkdir bin proj1 toolscd proj1mkdir reads fastqc ref snp-calling#拷贝相关的分析工具cp -r /home/training/tools/bwa ./tools/cp -r /home/training/tools/fastqc ./tools/cp -r /home/training/tools/samtools ./tools/#执行程序路径export PATH=$PATH:~/bin/ 安装软件（step2-install_software.sh）1234567891011121314151617181920212223242526272829303132#安装FastQCcd ~/tools/fastqc/unzip fastqc_v0.10.1.zipcd FastQCchmod +x fastqccd ~/bin/ln -s ~/tools/fastqc/FastQC/fastqc ./cdfastqc -h#安装BWAcd ~/tools/bwa/tar -jxvf bwa-0.7.3a.tar.bz2cd bwa-0.7.3a/makecp bwa ~/bin/cdbwa#安装samtoolscd ~/tools/samtools/tar -jxvf samtools-0.1.19.tar.bz2cd samtools-0.1.19/makecp samtools ~/bin/cp bcftools/vcfutils.pl ~/bin/cp bcftools/bcftools ~/bin/cdsamtoolsvcfutils.pl step3-snp_calling.sh123456789101112131415161718192021222324252627282930#测序数据质量控制cp /home/training/data/DNA-Seq/example1.* ~/proj1/reads/cd ~/proj1/fastqc/fastqc -f fastq -o ./ ../reads/example1.*#建立参考基因组索引cp /home/training/data/DNA-Seq/ref1.fa ~/proj1/ref/cd ~/proj1/ref/bwa index -a is ref1.fa#拼接组装##生成sai文件cd ~/proj1/bwa aln ref/ref1.fa reads/example1.L.fq &gt; aln_example1.L.saibwa aln ref/ref1.fa reads/example1.R.fq &gt; aln_example1.R.sai##生成sam文件bwa sampe ref/ref1.fa aln_example1.L.sai aln_example1.R.sai reads/example1.L.fq reads/example1.R.fq &gt; aln_example1.sam生成bam文件samtools view -bS aln_example1.sam | samtools sort - aln_example1_sorted#生成bcf文件cd ~/proj1/samtools mpileup -ugf ref/ref1.fa aln_example1_sorted.bam | bcftools view -bvcg - &gt; snp-calling/var_example1_sorted.raw.bcf#生成vcf文件bcftools view snp-calling/var_example1_sorted.raw.bcf | vcfutils.pl varFilter -D100 &gt; snp-calling/var_example1_sorted.flt.vcf rna-seq建立项目文件系统及软件安装（step1-prep_install.sh）123456789101112131415161718192021222324252627282930313233343536# generate foldercd ~/mkdir proj2cd proj2mkdir reads fastqc ref tophat# copy toolscd ~/cp -fr /home/training/tools/bowtie ./tools/cp -fr /home/training/tools/tophat ./tools/cp -fr /home/training/tools/cufflinks ./tools/# change pathexport PATH=$PATH:~/bin/# install bowtiecd ~/tools/bowtie/unzip bowtie2-2.0.5-linux-x86_64.zipcd bowtie2-2.0.5/cp bowtie2* ~/bin/# install tophatcd ~/tools/tophat/tar -zxvf tophat-2.0.8.Linux_x86_64.tar.gzcd tophat-2.0.8.Linux_x86_64/cp * ~/bin/# install cufflinkscd ~/tools/cufflinks/tar -zxvf cufflinks-2.0.2.Linux_x86_64.tar.gzcd cufflinks-2.0.2.Linux_x86_64/cp * ~/bin/# back to workpathecho "preparation and install complete..."cd ~/ 测序数据质量评估(step2-quality_control.sh)1234567# quality controlcp /home/training/data/RNA-Seq/example2-* ~/proj2/reads/cd ~/proj2/fastqc/fastqc -f fastq -o ./ ../reads/example2-*# back to workpathcd ~/ (step3-tophat_cuffdiff.sh)123456789101112131415161718192021222324252627282930313233#拷贝参考基因组数据cp /home/training/data/RNA-Seq/ref2.fa ~/proj2/ref/cp /home/training/data/RNA-Seq/ann2.gtf ~/proj2/ref/#建立基因组索引cd ~/proj2/ref/bowtie2-build ref2.fa ref2#生成bam文件cd ~/proj2/tophat/tophat2 -o E2-1-thout ../ref/ref2 ../reads/example2-1.L.fq ../reads/example2-1.R.fqtophat2 -o E2-2-thout ../ref/ref2 ../reads/example2-2.L.fq ../reads/example2-2.R.fq# 生成gtf文件cd ~/proj2/tophat/cufflinks -o E2-1-clout E2-1-thout/accepted_hits.bamcufflinks -o E2-2-clout E2-2-thout/accepted_hits.bam# 生成assemblies.txt文件touch assemblies.txtecho "./E2-1-clout/transcripts.gtf" &gt;&gt; assemblies.txtecho "./E2-2-clout/transcripts.gtf" &gt;&gt; assemblies.txt#生成注释文件cd ~/proj2/tophat/cuffmerge -s ../ref/ref2.fa assemblies.txt# 基于注释文件比较E2-1和E2-2表达差异cuffdiff -o diff_out1 -b ../ref/ref2.fa -L E2-1,E2-2 -u merged_asm/merged.gtf ./E2-1-thout/accepted_hits.bam ./E2-2-thout/accepted_hits.bam# 基于参考注释比较E2-1和E2-2表达差异cuffdiff -o diff_out2 -b ../ref/ref2.fa -L E2-1,E2-2 -u ../ref/ann2.gtf ./E2-1-thout/accepted_hits.bam ./E2-2-thout/accepted_hits.bam 注意： 建立合理的文件结构 bin目录的创建利于管理不同项目，使用不同软件版本 使用sh脚本 source step1-prep_mkdir_cp.sh （用source而不用sh是因为step1-prep_mkdir_cp.sh有添加环境变量的步骤，sh 对添加环境变量没用） 安装相关的分析工具 使用sh脚本安装软件 sh step2-install_software.sh 验证是否安装成功 ls bin 基因组比对用BWA,转录组比对用tophat 数据分析 上述命令是软件最初版本用法，软件版本更新用法会变化]]></content>
      <categories>
        <category>NGS</category>
      </categories>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何优雅的生成及遍历python嵌套字典]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F08%2F19%2F%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%94%9F%E6%88%90python%E5%B5%8C%E5%A5%97%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[如何优雅的生成及遍历python嵌套字典 嵌套字典生成方法一:定义类12345class Vividict(dict): def __missing__(self, key): value = self[key] = type(self)() return value 解释： 第一行：class后面紧接着是类名，即Vividict，类名通常是大写开头的单词，紧接着是(dict)，表示该类是dict类继承下来的。 我们可以使用dir(dict）查看dict的方法12In[22]: print(dir(dict))['__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values'] 同理，可以查看Vividict的方法12In[23]: print(dir(Vividict))['__class__', '__contains__', '__delattr__', '__delitem__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__missing__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values'] 比较两者可以发现，Vividict的方法比dict的方法多了一个missing方法，也就是我们添加的方法。所以这就是继承，继承最大的好处是子类获得了父类的全部功能，而不必重新造轮子。 第二行：python魔法方法中的自定义序列，类似于定义一个函数。missing 在字典的子类中使用，它定义了当试图访问一个字典中不存在的键时的行为（目前为止是指字典的实例，例如我有一个字典 d ， “george” 不是字典中的一个键，当试图访问 d[‘george’] 时就会调用 d.missing(“george”)，结果为{} ）。 第三行，第四行：访问字典中不存在的键(key)时，返回空字典作为其返回值（value） 例如：1234In[17]: a = dict()In[18]: type(a)()Out[18]: &#123;&#125; 注意： 特殊方法“missing”前后有两个下划线！！！ 和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。 使用： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# coding=utf-8#导入模块import os, openpyxlimport pprintfrom pandas import DataFrame#pprint模块可以输出漂亮的字典结构，但是不利于后期利用R作图#DataFrame可以将字典结构转为数据框输出，方便后期利用R作图#切换工作路径os.chdir(r'F:\pycharm_project\mutation_count')#读取excel表格wb = openpyxl.load_workbook('东方肝胆数据综合.xlsx')sheet = wb.active#定义类class Vividict(dict): def __missing__(self, key): value = self[key] = type(self)() return value#实例化d = Vividict()#字典初始化，赋初值0for i in range(2,sheet.max_row+1): d[sheet.cell(row=i, column=1).value][sheet.cell(row=i, column=15).value] = 0#累加统计各个样本各种突变类型的数目for i in range(2,sheet.max_row+1): d[sheet.cell(row=i, column=1).value][sheet.cell(row=i, column=15).value] +=1pprint.pprint(d)#输出字典结构pprint.pprint(d)&#123;'PDC1279A_vs_PDC1279': &#123;'UTR3': 9, 'UTR5': 4, 'downstream': 5, 'exonic': 149, 'intergenic': 170, 'intronic': 163, 'ncRNA_exonic': 17, 'ncRNA_intronic': 23, 'splicing': 2, 'upstream;downstream': 2&#125;, 'PDC1279C_vs_PDC1279': &#123;'UTR3': 11, 'UTR5': 13, 'downstream': 1, 'exonic': 174, 'intergenic': 189, 'intronic': 172, 'ncRNA_exonic': 24, 'ncRNA_intronic': 36, 'splicing': 4, 'upstream': 2, 'upstream;downstream': 2&#125;&#125;#输出数据框结构，缺损的元素用 NaN补齐frame = DataFrame(d)print(frame) PDC1279A_vs_PDC1279 PDC1279C_vs_PDC1279 \UTR3 9.0 11.0 UTR5 4.0 13.0 downstream 5.0 1.0 exonic 149.0 174.0 exonic;splicing NaN NaN intergenic 170.0 189.0 intronic 163.0 172.0 ncRNA_exonic 17.0 24.0 ncRNA_intronic 23.0 36.0 ncRNA_splicing NaN NaN splicing 2.0 4.0 upstream NaN 2.0 upstream;downstream 2.0 2.0 方法二：使用defaultdict()两个维度字典：1234from collections import defaultdictd = defaultdict(defaultdict)d[1][2] = 3 等价于： 12345678from collections import defaultdictdef nested_dict_factory(): return defaultdict(int)def nested_dict_factory2(): return defaultdict(nested_dict_factory)db = defaultdict(nested_dict_factory2) 当然，第一种方法简洁的多！ 要获得更多维度，你可以（三维）： 1234from collections import defaultdictd = defaultdict(lambda :defaultdict(defaultdict))d[1][2][3] = 4 使用defaultdict任何未定义的key都会默认返回一个根据method_factory参数不同的默认值, 而相同情况下dict()会返回KeyError. python中lambda存在意义就是对简单函数的简洁表示 实际上 defaultdict也是通过missing方法实现的。defaultdict在dict的基础上添加了一个missing(key)方法, 在调用一个不存的key的时候, defaultdict会调用missing, 返回一个根据default_factory参数的默认值, 所以不会返回Keyerror. 12In[35]: print(dir(defaultdict))['__class__', '__contains__', '__copy__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__missing__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'clear', 'copy', 'default_factory', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values'] 嵌套字典的遍历方法一：一层一层的嵌套迭代,从而实现遍历1234for key,value in d.items(): for key2, val2 in value.items(): print (key2, val2) 在类中定义walk方法实现嵌套字典的遍历123456789101112class Vividict(dict): def __missing__(self, key): value = self[key] = type(self)() return value def walk(self): for key, value in self.items(): if isinstance(value, Vividict): for tup in value.walk(): yield (key,) + tup else: yield key, value 解释:第1-4行：上面已经解释过了第5-11行：定义一个walk函数，并对字典items对象的key和value进行遍历，isinstance用于判断对象类型，如果value是一个字典，那么对value调用walk（）方法继续进行遍历，一层一层将key,value存储在元祖中（）。当最里面一层，即else情况，输出key,value。整个过程即将字典数据结构扁平化为元祖 此时，我们可以这样来遍历字典（输出元祖） 12345678910111213141516#打印整个元祖for tup in d.walk(): print(tup)('PDC1279_vs_PDC1279C6', 'downstream', 3)('PDC1279_vs_PDC1279C6', 'UTR3', 11)('PDC1279_vs_PDC1279C6', 'intronic', 164)('PDC1279_vs_PDC1279C6', 'splicing', 4)**这就是扁平化的字典**#打印元祖的第3列for tup in d.walk(): print(tup[2]) 参考（1）https://ask.helplib.com/229754 （2）Python魔法方法指南（推荐阅读） http://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用链接（持续更新）]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F08%2F19%2F%E5%B8%B8%E7%94%A8%E9%93%BE%E6%8E%A5%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[常用链接（持续更新） 论坛 Name Description 医学论坛网 医学资讯及文献导读 seqanswer 关于测序的一个论坛 PLoB Public Library of Bioinformatics (中文博客) rna-seqblog RNA-seq英文博客 biotrainee 生信技能树 oschina 开源中国 Capital of Statistics, COS 统计之都 数据人网 大数据 Qgenomics 人基因组学与生物信息学(推荐) 雪晴数据网资讯前沿 R与python及数据分析（推荐） Quora 问答SNS网站 学术导航 Name Description 学术网 文献，科技部，工程院，基金，论坛 龙猫学术导航 国内外文献图书，科研工具，专利标准导航，信息交流等 搞科研 学术圈新闻，科研工具，生活小工具，在线小工具等 学术网站大全 cnki 官方，绝对够全 linux及数据分析 Name Description Linux命令大全 linux命令搜索，查看帮助 awk &amp; sed awk &amp;sed ppt教程 Linux command line exercises for NGS data processing NGS数据处理实践过程中的linux命令行知识点 Introduction to Linux for bioinformatics VIB Bioinformatics Core Wiki ITArticles/Linux/ linux技术文章 分析流程 Name Description Illumina Amplicons Processing Workflow 16S pipelines bio简书 bwa+samtools+picardtools+GATK call SNP 流程 生信数据库 Name Description SNPedia link SNP genotypes to specific traits （SNP与人类疾病，人群频率，文献报道） GWAS Catalog GWAS研究的SNP,triat,Study等 Hi-HOST Phenome H2P2使用细胞特征的GWAS来提供解读人类遗传变异如何调控细胞途径的手段 OMIM(Online Mendelian Inheritance in Man) &emsp; PheGenI &emsp; ClinVar &emsp; Pheno-scanner 基因型和表明相互关联数据库 miRBase miRNA “官方”列表。 TimeTree 进化树的时间尺度。 IPDGC International Parkinson Disease Genomics Consortium GIANT Genetic Investigation of Anthropometric Traits) SCZR2 provides a comprehensive online resource for schizophrenia studies GeneCards &emsp;&emsp; WikiGene &emsp;&emsp; GeneReviews 常用的查基因及突变功能的数据库 2017NAR发布的收录数据库和web应用网站 十分全面（推荐） ensembl &emsp;NCBI &emsp; UCSC &emsp; HapMap 常用数据库FTP地址 基因雷达 查基因涉及的疾病，文献等 CLINVITAE 基于ACMG的突变注释及临床解读（公司做的） CardioVAI 基于ACMG的心血管疾病突变注释临床解读 Service &amp; Open API Name 链接 EBI services 链接 Amazon Genomics API 链接 Google Genomics API 链接 DNAnexus API 链接 23andme open API 链接 OMIM API 链接 Ensembl API 链接 DAVID Bioinformatics API 链接 101 Biology APIs: BioCatalogue, BioGRID and Synergizer 链接 72 Medical APIs: Avvo, National Library of Medicine and NHS 链接 开发社区 Name Description Biostars 专注于生物信息学，计算基因组学和生物数据分析的问答社区 Segmentfault 一个专注于解决编程问题，提高开发技能的社区 Stackoverflow 编程相关的IT技术问答网站 Quora 不仅限于编程方面的问答 GitHub 面向开源及私有软件项目的git托管平台 Gitbook 电子书搜索下载与diy Gitsearch 搜索存储在github上的开源仙姑和源代码 Kaggle 机器学习竞赛、托管数据库、编写和分享代码的平台 Bitbucket 与github类似的开源代码仓库，区别 The Lab for Data Intensive Biology github项目仓库 Applied Bioinformatics Laboratories github项目仓库 sigve nakken cancer genomics, clinical bioinformatics, precision oncology, human genetic variation opengene OpenGene - Open Source Genetics Toolbox python Name Description PYMOTW Python2标准库的使用 Bioinformatics code libraries and scripts 常遇到的问题都有脚本（py/pl） Python4cn(news, jobs) Python商业网站,技术博客,开源项目,图书 ,教程,讨论区等 张志明的个人博客 python，shell,运维（推荐） 静觅 崔庆才的个人博客 python 爬虫 The Invent with Python Blog python英文博客 RD文档 python模块中文文档 MySQL数据库与生信 Name Description Relational Databases For Biologists:Efficiently Managing And Manipulating Your Data (2006) MySQL数据库操作与设计（推荐） 在线小工具 Name Description 在线工具 开源中国开发的，主要面向码农 smallpdf &emsp; pdfcandy pdf转word等，在线工具 正则表达式在线测试 检查脚本中使用的正则表达式是否正确，提前发现问题 regular expressions 101 支持php，java，oython，golang正则表达式 RGB颜色对照表 绘图配色必备 在线代码着色 看看就好 在线 Markdown 编译器 用着不错 ASCII码对照表 速查 草料二维码（静态二维码） &emsp;&emsp; Q码（动态二维码） 比较好玩儿 Tagxedo 词云（不是所有浏览器都可以） 批改网 英语作文在线免费批改（还阔以） jvenn 在线绘制维恩图 搜索 Name Description PDFDRIVE 搜索下载免费的pdf电子书 slideshare 免费且高质量英文ppt下载与分享 Hi,PPTer PPT资源导航 Library Genesis 外文书籍的超级好用网址,免费下载 FreeBookCentre.net 英文版电子书分类免费下载 Explore · GitBook GitBook开源电子书搜索 PDF电子书基地 免费下载，比较全 youtube 可以搜索很多视频教程（可以设置加字幕和自动翻译） 全国图书馆参考咨询联盟 查询和试看 鸠摩搜书 pdf和epub电子书，好用 B–OK The world’s largest ebook library. 软件 Name Description 冰点文库下载器 自由下载百度、豆丁、丁香、MBALib、道客巴巴、Book118等文库文档 visio 专业绘制流程图 谷歌访问助手 “google/gmail/google scholar”一网打尽 Google和Google学术可用链接汇总 能用 硕鼠网络视频下载器 爬取网络视频 TeamViewer 12 远程控制 iMindMap 8 思维导图 OK &emsp; 美化大师 PPT特效，模板插件 prize &emsp; prize中国 prezi是一款在线的演讲文稿生成软件,“动态”PPT 多看 自带取词及字典功能，并且笔记可以直接导入印象笔记（推荐） Pan Download 百度网盘不限速下载软件 Md2All 公众号的Markdown排版利器（介绍） 谷歌插件 Name Description Sci-Hub Links 转换 DOI 和 Pubmed 位址为 sci-hub 连结 医学文献助手(有限版) 在 PubMed 搜索结果页面，添加 PDF 链接、影响因子、F1000评论、作者发表记录 等 远方 New Tab 每天打开新页面都是一段不期而遇的旅行 Search by Image (by Google) 用图片搜索 新媒体管家 微信公众号排版及扩展功能 油猴（Tampermonkey） &emsp; 推荐“油猴脚本” 爱奇艺，腾讯VIP视频破解 &emsp; 无需插件、软件 在线解析VIP视频 通过安装各类脚本对网站进行定制 Tabs Outliner 书签快速保存 四大高质量且实用的chrome翻译插件 推荐 Aria2 百度云下载加速 aria2+chrome+BaiduExporter 下载百度云加速 文献 Name Description Researchgate &emsp; 文献鸟 文献推送，文献跟踪与速读小工具 Web of Science 大型综合性、多学科、核心期刊引文索引数据库 PubMed 免费海量英文文献 中国知网 中文期刊 论文下载网 中文论文下载，知网，万方 SCI-HUB 收费文献免费下载 梅斯医学 影响因子查询（APP更好用） 科研动力 专注EndNote, 关注科研论文写作 GCBI 与PubMed同步并课显示影响因子 pubmedplus 文献摘要自动翻译（翻译得比较好） China PubMed 英文文献摘要翻译（更新不够快） Article-based PubMed Search Engine 快速搜寻到与你的PubMed索引论文所相关的文章 CNKI硕博士学位论文搜索 根据学位授予单位分类搜索（推荐） SJTU 上海交通大学学位论文数据库 bioRxiv 生物论文预印本（比pubmed早半年至一年） Biostatistics 生物统计方法文献 生物信息学杂志 Name Description IEE Xplore IEEE Xplore是一个学术文献数据库，主要提供计算机科学、电机工程学和电子学等相关领域文献的索引、摘要以及全文下载服务（pubmed上不一定能搜到） Bioinformatics 网址 BMC Bioinformatics 网址 Genome Biology 网址 Genome Research 网址 Nucleic Acids Research 网址 Briefings in Bioinformatics 网址 FEBs letters 网址 Biochemical and Biophysical Reasearch 网址 Communications 网址 Molecular Systems Biology 网址 Molecular Biology and Evolution 网址 PLoS Computational Biology 网址 PloS ONE 网址 Protein Science 网址 Proteins 网址 Protein Engineering Design and Selection 网址 Algorithms for Molecular Biology 网址 心肌病相关研究杂志 Name IF Journal of the American College of Cardiology(JACC) 19.896 European Heart Journal 19.651 Circulation Research 13.965 Journal of the American Heart Association 4.863 Journal of Molecular and Cellular Cardiology 4.81 Clinical Infectious Diseases (从感染，公共卫生，微生物学和免疫学) 8.26 论文写作与投稿 Name Description English Communication for Scientists 一本小书（推荐） International Science Editing 文章润色服务，其中writing tips部分很实用 ozdic 英语搭配词典（推荐） Purdue Online Writing Lab 普渡大学学术英语写作资源 Plagiarism Certification Tests for Master’s and Doctoral Students 印第安纳大学鉴别论文剽窃小测试 生信软件 Name Description hope的博客总结 常用生物信息在线工具 生信客部落总结 生物信息工具整合(包含在线工具与离线工具) ESPript 美得令人心动的序列显示工具 Pathway Builder Tool 零基础也能画出超酷信号通路图 cytoscape 相互作用网络绘图 ITOL 进化树后期编辑神器 EVOLVIEW 进化树编辑，编程加多层注释圈儿 Bioconductor annotation packages Bioconductor注释文件合集 DNAMAN DNAMAN 8 全功能英文版，免序列号（By Raindy） 实验 Name Description 实验小白 基础实验介绍 生物无忧 中文实验视频教程 Journal of Visualized Experiments ( JoVE) JoVE是一份展示可视化实验的期刊，是世界上第一个同行评议的科技视频期刊 PROTOCAL ONLINE 生物医学研究领域的实验protocols以及最新实验方面的文章 Nature protocols Nature的实验Protocol,述详细的实验步骤及注意事项 Nature methods 主要发表生命科学领域中新的研究方法或对经典方法有显著改进的相关论文 Nucleic Acids Research Methods 可按不同研究领域来查找具体的实验技术 Springer出版社的Protocol系列 在“Browse by discipline”一栏选择“Life science”,然后在“Content Type”一栏点击protocol,在搜索框输入关键词查询实验方法 Cold Spring Harbor Protocols 冷泉港实验室Protocols bio-protocol 质量非常高，而且全部免费，非常好用 Nature protocols或者Springer Protocol不仅可以搜实验的protocol，还可以搜分析的protocol 推荐博客 Name Description 施一公个人博客 心灵鸡汤 老D博客 网络为主，各种黑科技 车小胖的博客 网络 raindu’s home R与Excel数据可视化 Sam’s Note 专注转化医学，专注生物信息 Bob’s Blog 药学工作者中的极客达人，精通SQL，R，擅长数据分析，数据挖掘。 BioChen生物 Lnc RNA , ChiP, Genome（推荐） Y叔的博客 R ，生信 （推荐） hope 基因组和转录组方面 文字的博客 GWAS (推荐) free_mao的博客 python, linux ,gwas 生信客部落 python , R ,工具 生物信息博客 生物数据库、软件、程序介绍 刘辉的博客 生信基础 生信笔记 生信入门级 花之恋的博客 生信工具等 CALYX&amp;YAMOL 博客 WeGene基因一员 JackTalk 生物信息学，计算生物学，python fanyucai的博客 生信 EmanLee, Eman Lee’s Space (blog, website) 生信 飘的博客 生物信息学资料分享，写的比较简单 Zuguang Gu 英文博客，博主在德国 陈连福NGS 陈连福NGS,开培训班 博耘生物 已经不再更新了 Spring‘s info 生物信息，已经不再更新 rabbit gao’s blog 计算机、数学、生物混合男，已经不再更新了 Bioinformatics 已经不再更新了 铁汉1990的博客 已经不再更新了 生物日志-鸣一到 生物信息分析教程，数据可视化，已经不再更新了 云之南博客 已经不再更新了 Bioinformatics Zen 英文博客，已经不再更新了 沈梦圆博客 似乎已经不再更新了 欧拉的博客 程序员&amp;金融喵 Bioinformatics I/O Tips &amp;&amp; tricks from a cluster of bioinformaticians（英文博客，推荐） Getting Genetics Done 遗传和生信研究（推荐） DAVE TANG’S BLOG COMPUTATIONAL BIOLOGY AND GENOMICS Botian Shi（机器学习） 输入paper，输出knowledge RPubs brought to you by RStudio Write R Markdown documents in RStudio R语言 Name Description awesome-R R包中文介绍【全】 Bioconductor - Mirrors Bioconductor镜像汇总 RStudio Blog &emsp;R-bloggers &emsp;R Programming Resource Center&emsp; R China RStudio 博客, R博客,R 编程资源中心（链接），R语言中文网 Quick-R &emsp; R Tutorial &emsp; R &emsp; R基础资料 R语言忍者秘笈 &emsp; R语言在线电子书 KENT STATE SPSS 教程 PUL Getting Started in Data Analysis: Stata, R, SPSS, Excel: SPSS MATLAB Bioinformatics Toolbox MATLAB生信分析示例 Kings college london R语言课件—伦敦国王大学 OnePageR A Survival Guide to Data Science with R R for Bioinformatics &emsp;R for Biomedical Statistics &emsp; R for Time Series R语言英文小书 Statistics with R &emsp; Using R for statistical analyses R统计 StatsBlogs 统计相关博客R,SAS等 Bioconductor for Genomic Data Science 关于Bioconductor的网络课程，有视频，有材料 张丹博客 原创了大量R语言技术实战文章，包括R的极客理想系列文章，RHadoop实战系列文章，R离间NoSQL系列文章，并写作”R的极客理想”系列图书 谢益辉的个人博客 博客主要包括各种有趣的技术和吐槽文章。谢益辉是统计之都的创始人，现任RStudio公司程序员 刘思喆的个人博客 博客中主要包括R语言企业级应用的文章。刘思喆现任京东推荐算法经历 李舰的个人博客 博客中主要包括R语言建模的文章。李舰现任Mango Solutions中国区数据总监 阿稳的个人博客——不周山 博客中主要包括R语言并行技术的文章。 WHAT YOU’RE DOING IS RATHER DESPERATE-（推荐） 作者为澳大利亚悉尼大学的生物信息学家 The Yhat Blog machine learning, data science, engineering(推荐) R Package Documentation A comprehensive index of R packages and documentation from CRAN, Bioconductor, GitHub and R-Forge. STATISTICS BOOKS FOR LOAN 统计英文书籍合集 wangyunpeng_bio的博客 生信分析pipline（推荐） Statistics for Genomic Data Science 使用R做基因组数据分析 Bioconductor for Genomic Data Science 系列软件合集 PH525x series - Biomedical Data Science 统计模型到NGS数据分析 Bioconductor reference card 常用bioconductor包简介 Bioinformatics I/O Tips &amp;&amp; tricks from a cluster of bioinformaticians 数据可视化 Name Description plotly 支持R和python，图例丰富（含代码） ECharts ECharts GL 是 WebGL 的扩展包，提供了丰富的三维可视化组件以及常规图表的性能增强 WebGL 中文网 教程 网络 Name Description 胡智峰的博客 Linux工具及网络 网络生信课程 Name Description coursera 在网上学习全世界最好的课程 Bioinformatics: Introduction and Methods 北大MOOK生物信息学导论 陈魏学基因 NGS相关视频 Applied Bioinformatics Course 北大罗静初老师abc生信课程 Biomedical Data Science 统计，算法，NGS书籍 NOVOCRAFT NOVOCRAFT 公司NGS资料（干货） Workshops 康奈尔大学生信课件（2010-2017） Bioinformatics and Genome Analyses Courses 巴斯德研究所2005-2017生信课程全集 CGU-GIBMS 台湾长庚大学生信课件 Bioinformatics Team (BioITeam) at the University of Texas 德州大学奥斯丁分校生信课件 CANB7640 COURSE WEBSITE 生信课件-按研究内容分 UCLA 加利福尼亚大学洛杉矶分校NGS数据处理workshop最全合集 Purdue university Discovery Park 普渡大学生物信息课程 Bioinformatics Crash Course - July 2014 &emsp; RNA-seq Analysis &emsp; Linux and HPCC 马里兰大学的生信中心课程-NGS分析，RNA-seq分析，linux和高性能计算 BTI Bioinformatics Course 2017 美国康奈尔大学博伊斯汤普森植物研究所课件 Swiss Institute of Bioinformatics 瑞士生物信息学研究所8年培训资料 BioFrontiers Education 科罗拉多大学生物信息课程 Statistics 246 Statistical Genetics Spring 2006 伯克利大学的遗传统计学课程 NGSchool 2016 Workshops NGSchool非常全面的ppt BIOINFORMATICS PLATFORM 德国柏林医学院中心生物信息学课程资料 UT HEALTH SCIENCE CENTER 圣安东尼奥-生命健康中心-jin实验室生物信息学课程ppt MSc lecture Genomics 柏林自由大学 Genomics12 Statistical Genetics &emsp;NGS &emsp;Statistical Genetics and Genomics 伯明翰阿拉巴马大学-生物信息视频教程 Babraham Institute the Bioinformatics 伯拉罕研究所生信课程 Applied Bioinformatics 2014 biostar handbook-生信分析 Computational and Systems Biology” Video Lectures MIT计算与系统生物学课程 UCR(Institute for In tegrative Genome Biology) Manuals 包括NGS with R/Bioconductor，NGS Analysis with Galaxy and IGV， EMBOSS，Linux 等十分全面。 VIB Bioinformatics Core 从基础到实践，非常全面 Learn about Bioinformatics and Computational Tools for Biology 一直在更新，推荐 Canadian Bioinformatics Workshops Course Materials 2004-2016超级多 Bioinformatics Links Directory 生信资源，工具和数据库 WikiOmics Open Bioinformatics - a collection of questions and answers about bioinformatics. Duke HTS 2017 统计基础，计算，生物，生信 popucui 生信github博客 PacificBiosciences/Bioinformatics-Training Star 227 Harvard Bioinformatics Training at HBC 涉及面很多，强烈推荐 OpenHelix Learn to use Bioinformatics Resources griffithlab/rnaseq_tutorial Star 404 bioinform The Bioinformatics Repository bioc-refcard Bioconductor cheat sheet bcbio A python toolkit providing best-practice pipelines for fully automated high throughput sequencing analysis IARC bioinformatics nextflow pipelines 基于Nextflow的生信pipline EMBL-EBI Training 在线生信培训（干货） Where To Look For Quality Bioinformatics Short Courses And Workshops? 生信在线资料biostar问答 Links To Good Next Gen Sequence Analysis Training Courses And Centres NGS在线资料biostar问答 Programming for Bioinformatics MySQL和Python（配套答案） CBCB Seminar series 计算生物学（偏算法） MIT-OPEN-COURSEARE 生信算法（推荐：点Lecture notes） bioalgorithms.info 生物信息学算法导论书籍扩展在线算法课程 Computational Biology Core（pipline, online course, light reading） 推荐 STHDA Statistical tools for high-throughput data analysis What are the best blogs about bioinformatics? Quora问答 生物日志 鸣一道 数据集 Name Description Kaggle 公共数据分析竞赛 天池 阿里 UCI 机器学习数据仓库 mldata.org 机器学习公共数据集 LIBSVM Data 多种回归、 二值化、 多标号分类等LIBSVM格式的数据集 20newsgroup 文本数据集 机器学习 Name Description nanjunxiao的博客 链接 Name Description 王夫子 PPT模板，简历模板，免费 五百丁 PPT模板，简历模板，&lt;10元]]></content>
      <categories>
        <category>常用链接</category>
      </categories>
      <tags>
        <tag>常用链接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bedtools使用教程详解]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F08%2F19%2Fbedtools%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;bedtools开发的目的是为了快速，灵活的比较大量的基因组特征（genomic features）。而genomic features通常使用Browser Extensible Data (BED) 或者 General Feature Format (GFF)文件表示，用UCSC Genome Browser进行可视化比较。 &emsp;&emsp;例如,bedtools可以进行取intersect（交集）, merge（并集）, count（计数）, complement（补集），以及用来对广泛使用的基因组文件格式，例如BAM, BED, GFF/GTF, VCF等进行基因组区间的转换。单个的工具设计的目的是应对简单的任务，复杂的分析能通过组合多个bedtools工具操作实现。同时，该工具允许控制输出结果的呈现形式。最初的bedtools版本支持单独的6列BED文件。但是，如今增加了对序列比对BAM文件的支持。以及GFF文件的特征，BED文件。以及VCF文件。这些工具是相当快速的，并且即使是大的数据集也可以在数秒内完成任务。 我们用bedtools都可以做些啥?&emsp;&emsp;bedtools总共有二三十个工具/命令来处理基因组数据。比较典型而且常用的功能举例如下：格式转换，bam转bed（bamToBed），bed转其他格式（bedToBam，bedToIgv）；对基因组坐标的逻辑运算，包括：交集（intersectBed，windowBed），”邻集“（closestBed），补集（complementBed），并集（mergeBed），差集（subtractBed）;计算覆盖度（coverage）（coverageBed，genomeCoverageBed）；此外，还有一些强大而实用的工具（shuffleBed，groupBy，annotateBed，……） Utility Description annotate Annotate coverage of features from multiple files. bamtobed Convert BAM alignments to BED (&amp; other) formats. bamtofastq Convert BAM records to FASTQ records. bed12tobed6 Breaks BED12 intervals into discrete BED6 intervals. bedpetobam Convert BEDPE intervals to BAM records. bedtobam Convert intervals to BAM records.** closest Find the closest, potentially non-overlapping interval. cluster Cluster (but don’t merge) overlapping/nearby intervals. complement Extract intervals not represented by an interval file. coverage Compute the coverage over defined intervals. expand Replicate lines based on lists of values in columns. flank Create new intervals from the flanks of existing intervals. genomecov Compute the coverage over an entire genome. getfasta Use intervals to extract sequences from a FASTA file. groupby Group by common cols. &amp; summarize oth. cols. (~ SQL “groupBy”) igv Create an IGV snapshot batch script. intersect Find overlapping intervals in various ways. jaccard Calculate the Jaccard statistic b/w two sets of intervals. links Create a HTML page of links to UCSC locations. makewindows Make interval “windows” across a genome. map Apply a function to a column for each overlapping interval. maskfasta Use intervals to mask sequences from a FASTA file. merge Combine overlapping/nearby intervals into a single interval. multicov Counts coverage from multiple BAMs at specific intervals. multiinter Identifies common intervals among multiple interval files. nuc Profile the nucleotide content of intervals in a FASTA file. overlap Computes the amount of overlap from two intervals. pairtobed Find pairs that overlap intervals in various ways. pairtopair Find pairs that overlap other pairs in various ways. random Generate random intervals in a genome. reldist Calculate the distribution of relative distances b/w two files. shift Adjust the position of intervals. shuffle Randomly redistribute intervals in a genome. slop Adjust the size of intervals. sort Order the intervals in a file. subtract Remove intervals based on overlaps b/w two files. tag Tag BAM alignments based on overlaps with interval files. unionbedg Combines coverage intervals from multiple BEDGRAPH files. window Find overlapping intervals within a window around an interval. BEDTools suite使用详细bedtools官网： http://bedtools.readthedocs.io/en/latest/ bedtools使用说明： http://quinlanlab.org/tutorials/bedtools/bedtools.html#bedtools-merge BEDTools主要使用BED格式的前三列,即： chrom: 染色体信息 start: genome feature的起始位点，从0开始 end: genome feature的终止位点，至少为1 一般常用物种的genome file在BEDTools安装目录的/genome里面 BEDPE格式是其自定义的一种新的格式，为了简洁的描述不连续的genome features，例如结构变异和双端测序比对 注意： start1和start2起始坐标第一个碱基都为0，所以start=9, end=20表示碱基跨度是从第10位到第20位 chrom1或者chrom2用.表示unknown;start1，end1,start2,end2用-1表示unknown (1)intersect&emsp;&emsp;可以计算两个或者多个BED/BAM/VCF/GFF文件中基因组坐标位置的交集(overlap)，根据参数不同，可以得到不同的结果。 两个BED文件比较图示 一对多比较图示 语法：bedtools intersect -a &lt;bed/gff/vcf/bam&gt; -b &lt;bed/gff/vcf/bam&gt; [OPTIONS] -wa参数可以报告出原始的在A文件中的feature -wb参数可以报告出原始的在B文件中的feature -c参数可以报告出两个文件中的overlap的feature的数量 -wo 返回overlap碱基数 -v 返回非overlap区间 -s 相同链上的feature 当用bedtools intersect 处理大文件时比较耗内存，有效的方法是对A和B文件按照染色体名字(chromosome)和位置(position)排序(sort -k1,1 -k2,2n),然后用-sorted参数重新intersect 案例注意，自己生成测试bed文件，都必须用tab键分割，否则会报错！！ 案例一：包含着染色体位置的两个文件，分别记为A文件和B文件。分别来自于不同文件的染色体位置的交集是什么？ $ cat A.bed chr1 10 20 chr1 30 40 $ cat B.bed chr1 15 25 $ bedtools intersect -a A.bed -b B.bed chr1 15 20 案例二：包含着染色体位置的两个文件，分别记为A文件和B文件。求A文件中哪些染色体位置是与文件B中的染色体位置有overlap. $ cat A.bed chr1 10 20 chr1 30 40 $ cat B.bed chr1 15 25 $ bedtools intersect -a A.bed -b B.bed -wa chr1 10 20 案例三：包含着染色体位置的两个文件，分别记为A文件和B文件。求A文件中染色体位置与文件B中染色体位置的交集，以及对应的文件B中的染色体位置. $ cat A.bed chr1 10 20 chr1 30 40 $ cat B.bed chr1 15 25 $ bedtools intersect -a A.bed -b B.bed -wb chr1 15 20 chr1 15 25 案例四（经用）： 包含着染色体位置的两个文件，分别记为A文件和B文件。求对于A文件的染色体位置是否与文件B中的染色体位置有交集。如果有交集，分别输入A文件的染色体位置和B文件的染色体位置；如果没有交集，输入A文件的染色体位置并以’. -1 -1’补齐文件。 $ cat A.bed chr1 10 20 chr1 30 40 $ cat B.bed chr1 15 25 $ bedtools intersect -a A.bed -b B.bed -loj chr1 10 20 chr1 15 25 chr1 30 40 . -1 -1 案例五： 包含着染色体位置的两个文件，分别记为A文件和B文件。对于A文件中染色体位置，如果和B文件中染色体位置有overlap,则输出在A文件中染色体位置和在B文件中染色体位置，以及overlap的长度. $ cat A.bed chr1 10 20 chr1 30 40 $ cat B.bed chr1 15 20 chr1 18 25 $ bedtools intersect -a A.bed -b B.bed -wo chr1 10 20 chr1 15 20 5 chr1 10 20 chr1 18 25 2 案例六： 包含着染色体位置的两个文件，分别记为A文件和B文件。对于A文件中染色体位置，如果和B文件中染色体位置有overlap,则输出在A文件中染色体位置和在B文件中染色体位置，以及overlap的长度；如果和B文件中染色体位置都没有overlap,则用’. -1-1’补齐文件 $ cat A.bed chr1 10 20 chr1 30 40 $ cat B.bed chr1 15 20 chr1 18 25 $ bedtools intersect -a A.bed -b B.bed -wao chr1 10 20 chr1 15 20 5 chr1 10 20 chr1 18 25 2 chr1 30 40 . -1 -1 案例七： 包含着染色体位置的两个文件，分别记为A文件和B文件。对于A文件中染色体位置，输出在A文件中染色体位置和有多少B文件染色体位置与之有overlap. $ cat A.bed chr1 10 20 chr1 30 40 $ cat B.bed chr1 15 20 chr1 18 25 $ bedtools intersect -a A.bed -b B.bed -c chr1 10 20 2 chr1 30 40 0 案例八(常用)： 包含着染色体位置的两个文件，分别记为A文件和B文件。对于A文件中染色体位置，输出在A文件中染色体位置和与B文件染色体位置至少有X%的overlap的记录。 $ cat A.bed chr1 100 200 $ cat B.bed chr1 130 201 chr1 180 220 $ bedtools intersect -a A.bed -b B.bed -f 0.50 -wa -wb chr1 100 200 chr1 130 201 (2)merge&emsp;&emsp;用于合并位于同一个bed/gff/vcf 文件中有overlap或者距离在一定范围内的相邻区间，距离可由参数(-d)定义。需要注意的是，做合并之前需要先对bed文件做根据染色体排序，可以用bedtoolssort命令实现。 图示 语法bedtools merge [OPTIONS] -i &lt;bed/gff/vcf&gt; 案例$ cat A.bed chr2 10 20 chr1 30 40 chr1 15 20 chr1 18 25 排序： sort -k1,1 -k2,2n A.bed &gt; A.sort.bed $ cat A.sort.bed chr1 15 20 chr1 18 25 chr1 30 40 chr2 10 20 案例一：取并集 bedtools merge -i A.sort.bed chr1 15 25 chr1 30 40 chr2 10 20 案例二：计算重叠区间的个数,-i 指定统计的列，-o指定操作5 bedtools merge -i exons.bed -c 1 -o count chr1 15 25 2 chr1 30 40 1 chr2 10 20 1 案例三：-d 两个独立区域间距小于（等于）该值时将被合并为一个区域；-o collapse显示合并了哪些标签 $ bedtools merge -i A.sort.bed -d 5 -c 1 -o count，collapse chr1 15 40 3 chr1,chr1,chr1 chr2 10 20 1 chr2 (3)complement：返回基因组非覆盖区（用途，比如多轮设计panel)图示 语法bedtools complement -i &lt;BED/GFF/VCF&gt; -g &lt;genome files&gt; (4)genomecov：染色体和全基因组覆盖度计算要求：单个输入bed文件（-i指定）和genome files；如果输入为bam(-ibam指定)文件，则不需要genome files 图示 语法bedtools genomecov [OPTIONS] -i &lt;bed/gff/vcf&gt; -g &lt;genome&gt; 案例$ cat ranges-cov-sorted.bed chr1 4 9 chr1 1 6 chr1 8 19 chr1 25 30 chr2 0 20 $ cat cov.txt （染色体及每条染色体总碱基数） chr1 30 chr2 20 bedtools genomecov -i ranges-cov-sorted.bed -g cov.txt chr1 0 7 30 0.233333 1 chr1 1 20 30 0.666667 chr1 2 3 30 0.1 chr2 1 20 20 1 2 genome 0 7 50 0.14 3 genome 1 40 50 0.8 genome 2 3 50 0.06 #name 覆盖次数 覆盖碱基数 总碱基数 覆盖度 #同时计算单染色体和全基因组覆盖度 ranges-cov.bed文件需提前排序sort -k1,1 ranges-cov.bed &gt; ranges-cov-sorted.bed -bg参数可得到每个碱基的覆盖度。 (5)coverage 计算染色体给定区间覆盖度，输入可以是 BAM 文件$ cat A.bed chr1 0 100 chr1 100 200 chr2 0 100 $ cat B.bed chr1 10 20 chr1 20 30 chr1 30 40 chr1 100 200 $ bedtools coverage -a A.bed -b B.bed chr1 0 100 3 30 100 0.3000000 chr1 100 200 1 100 100 1.0000000 chr2 0 100 0 0 100 0.0000000 #name 覆盖次数 覆盖碱基数 总碱基数 覆盖度 (6)getfasta：提取序列提取指定位置的 DNA 序列，也是很好用的一个功能，反向互补链也可以提，不用自己写脚本提了 1234567891011$ cat test.fa&gt;chr1AAAAAAAACCCCCCCCCCCCCGCTACTGGGGGGGGGGGGGGGGGG$ cat test.bedchr1 5 10$ bedtools getfasta -fi test.fa -bed test.bed&gt;chr1:5-10AAACC 注意取的是（5,10]，区间左开右闭 语法bedtools getfasta [OPTIONS] -fi &lt;fasta&gt; -bed &lt;bed/gff/vcf&gt; -fo &lt;fasta&gt; 案例要求：基因组fasta文件（-fi指定）,提取区间BED/GTF/GFF/VCF文件(-bed指定),输出文件FASTA（-fo 指定） bedtools getfasta -fi Mus_musculus.GRCm38.75.dna_rm.toplevel_chr1.fa -bed mm_GRCm38_3kb_promoters.gtf -fo mm_GRCm38_3kb_promoters.fasta 扩展： 提取序列之samtools（速度较快） #首先建立fai索引文件（第一列为染色体名字，第二列为序列碱基数） samtools faidx Mus_musculus.GRCm38.75.dna.chromosome.8.fa #序列提取，多提取区间空格隔开 samtools faidx Mus_musculus.GRCm38.75.dna.chromosome.8.fa \ 8:123407082-123410744 8:123518835-123536649 &gt;8:123407082-123410744 GAGAAAAGCTCCCTTCTTCTCCAGAGTCCCGTCTACCCTGGCTTGGCGAGGGAAAGGAAC CAGACATATATCAGAGGCAAGTAACCAAGAAGTCTGGAGGTGTTGAGTTTAGGCATGTCT [...] &gt;8:123518835-123536649 TCTCGCGAGGATTTGAGAACCAGCACGGGATCTAGTCGGAGTTGCCAGGAGACCGCGCAG CCTCCTCTGACCAGCGCCCATCCCGGATTAGTGGAAGTGCTGGACTGCTGGCACCATGGT [...] (7)nuc: 计算GC含量即各碱基数语法bedtools nuc [OPTIONS] -fi &lt;fasta&gt; -bed &lt;bed/gff/vcf&gt; Options: -fi 输入FASTA文件 -bed 提取区间BED/GTF/GFF/VCF文件(-bed指定) 案例bedtools nuc -fi hg19.fa -bed CDS.bed 输出结果解释：在原bed文件每行结尾增加以下几列 Output format:The following information will be reported after each BED entry: 1) %AT content 2) %GC content 3) Number of As observed 4) Number of Cs observed 5) Number of Gs observed 6) Number of Ts observed 7) Number of Ns observed 8) Number of other bases observed 9) The length of the explored sequence/interval. 10) The seq. extracted from the FASTA file. (opt., if -seq is used) 11) The number of times a user&apos;s pattern was observed. (opt., if -pattern is used.) 高级用法Coverage analysis for targeted DNA capture RNA-seq coverage analysis 参考：（1）王球爸的博客： http://blog.sina.com.cn/s/blog_5d5f892a0102v665.html （2）生信人 https://www.wxzhi.com/archives/871/gk4yd3ujan57e0ft/ （3）hope http://tiramisutes.github.io/2016/03/18/bedtools.html]]></content>
      <categories>
        <category>NGS软件</category>
      </categories>
      <tags>
        <tag>NGS软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全基因组关联分析(GWAS)简介]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F08%2F18%2FGWAS-%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[全基因组关联分析(GWAS)简介 GWAS介绍&emsp;&emsp;全基因组关联分析是对多个个体在全基因组范围的遗传变异多态性进行检测，获得基因型，进而将基因型与可观测的性状，即表型，进行群体水平的统计学分析，根据统计量或P值筛选出最有可能影响该性状的遗传变异。 分析流程材料选择，性状调查，基因分型，模型选择，关联结果，数据深度挖掘 GWAS分析选材原则 保证选取的样本具有足够的代表性； 样本中不能有明显的亚群分化（例如生殖隔离等），因为明显分化的群体会使得遗传背景的噪音较大； 建议选择几个比较重要且遗传力较高的表型性状作为研究的重点； 质量性状尽量为0、1二值性状，并且两类性状的样本数应当尽量相近； 数量性状尽量精确量化记录（如抗病性可以量化为发病率、死亡率、存活率、病斑数、病斑面积等，而不是简单的多级衡量），并使表型总体呈近似正态分布； 栽培植物可以进行多年多点多重复记录，多年多点的观测结果可以分别进行关联分析，多重复可以取平均值进行关联分析； 表型变异丰富、性状有明显的主效位点控制时样本量可以适当减小，推荐200个以上；表型差异较小，多基因控制时样本量应当增大，推荐500个以上。 自然群体GWAS的研究对象非严格遗传群体： 种质资源 半同胞家系，混合家系 MAGIC/NAM家系 多个F2/RIL/全同胞家系 高杂合类物种：F1群体 师兄你好！打扰百忙之中的你，学弟我甚感抱歉。我是南农的在读研究生，正在试图运用关联分析方法进行大豆各性状的QTL分析研究，很荣幸拜读了你发表在《TAG》和《作物学报》上的几篇文章，受益匪浅。 由于底子浅薄，我对关联分析方面的一些问题不能很透彻地理解。比如在群体材料方面，关联分析要求材料应为相互间无直接亲缘关系。请问这一要求是为了能获得更多更广泛的等位基因数目、获得更好的多态吗？ 这一要求是不是也与群体LD的强弱有关？然而即使材料间没有直接亲缘关系，但是当取材时如果这些材料出现产地位置的结构特征，而会使分析结果产生假阳性。为避免产生假阳性得用STRUCTURE对群体结构进行校正，请问这里所用的软件（STRUCTURE）和方法，与SA方法中对群体分层进行校正所用的相同吗？ 期待你的回信与帮助，谢谢！ 你好，感谢你对我研究的关注。 材料选择所要求的无直接亲缘关系，主要是为了避免等位变异在家族的传递不平衡，以及由于亲缘关系造成的群体的亚分等群体结构问题，因此获得更多更广泛的等位基因数目及多态不是问题的核心。 材料不管怎么选都会有假阴、假阳这样那样的问题，因此你所说的“产地位置的结构特征，而会使分析结果产生假阳性”不无可能，这 才使得人们考虑用统计方法做矫正；structure软件分析原理我的论文里有所涉及，如要深究可参考论文后给出的参考文献 Pritchard J K, Stephens M, Donnelly P. Inference of population structure using multilocus genotype data. Genetics, 2000, 155:945-959， 可以肯定的说它与SA方法中对群体分层进行校正所用的不相同。 模型选择 &emsp;&emsp;目前的 GWAS 多采用两个阶段的设计：首先采用覆盖整个基因组的高通量 SNP 分型芯片（如affy6.0）对一批样本进行扫描，然后筛选出最显著的 SNP（如 P&lt;10-7）供第二阶段进行扩大样本验证,第一步选的snp大多是tag snp。GWAS 两阶段研究设计减少了基因分型的工作量和花费，同时通过重复实验降低了研究的假阳性率。GWAS 的整体过程比较复杂，其大致流程如下： 经过处理的 DNA 样品与高通量的 SNP 分型芯片进行杂交； 通过特定的扫描仪对芯片进行扫描，将每个样品所有的 SNP 分型信息以数字形式储存于计算机中 对原始数据进行质控，检测分型样本和位点的得率（call rate） 、病例对照的匹配程度、人群结构的分层情况等； 对经过各种严格质控的数据进行关联分析； 根据关联分析结果，综合考虑基因功能多方面因素后，筛选出最有意义的一批 SNP 位点； 根据需要验证 SNP 的数量选择合适通量的基因分型技术在独立样本中进行验证； 合并分析 GWAS 两阶段数据。 关联分析的优点（1）不需要专门构建作图群体，自然群体或种质资源都可作为研究材料；（2）广泛的遗传材料可同时考察多个性状大多数QTL关联位点及其等位变异，不受传统的FBL的“两亲本范围”的限制；（3）自然群体经历了许多轮重组后，LD衰减，存在于很短的距离内，保证了定位的更高精确性 生物信息学中的连锁分析与关联分析有哪些区别和联系？ 连锁分析的定位依赖于家族中标记基因型与表现性的共分离，从而探知影响疾病风险的遗传位点 关联分析的定位方法则是通过探测在种群水平上，哪个基因型或等位基因位点与表现性有关，并且这种相关能够在家系样本或者随机个体间实现（GWAS） 关联分析与 QTL定位的区别 全基因组关联研究(GWAS)后的新热点？&emsp;&emsp;GWAS的目的是从常见基因突变(common variant，&gt;5％的人口所具有的突变)中来找到至病的变异。现在越来越多的人开始还疑这个昂贵方法的普适性。 因为到目前为止，没有一个真正成功地用这个方法找到至病的变异，只能找到一些似是而非的、有统计意义但没有什么用的突变。 现在，有些人认为应该找罕见基因突变（rare variant，0.1-1％的人口所具有的突变）中来找到至病的变异。对于这样的变异，GWAS的方法就无效了。这个提议的假定是常见基因突变致病可能性不大，只有罕见基因突变才能致病。Hall的文中提到普林斯顿大学教授David Botstein认为1.4亿美金的HapMap(人类基因组单体型图计划)是巨大的失败(magnificent failure)。 所以在可见的将来，随着下一代测序技术(Next generation sequencing)的普及，寻找常见基因突变的GWAS的死亡将催生寻找罕见基因突变的方法及其应用。一个新的热点即将涌现。 &emsp;&emsp;我不认为GWAS是一个完全的失败，对于有些疾病还是发现了一些治病基因的。Nature Genetics上有很多的例子。另外，HapMap我也不认为是一个彻底的失败。毕竟，很多信息具有重大的参考价值，比如Allele frequency，不做怎么知道呢？第三，rare variants究竟有多大的作用还是一个比较不明朗的命题。如果真的是只有rare variants才能导致疾病，那每个人的治病基因就都不一样了。我同意你的结论，next generation sequencing是技术发展的根本，但是我觉得除了rare variants之外，通过NGS找到novel variation，进而找到causal variation也会是一个重要的研究方向。 在这里面，bioinformatics（而不是statistician）的作用就会更为明显。 参考：（1）http://blog.sciencenet.cn/blog-472757-376473.html （2）http://blog.sina.com.cn/s/blog_4b55f4130100us1m.html （3）http://blog.sina.com.cn/s/blog_4b55f4130100ibtg.html]]></content>
      <categories>
        <category>GWAS</category>
      </categories>
      <tags>
        <tag>GWAS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux解压缩]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F08%2F16%2Flinux%E8%A7%A3%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[总结下linux下各种压缩文件的解压方法及批量解压 首先要弄清两个概念：打包 和 压缩： 打包 是指将一大堆文件或目录变成一个总的文件； 压缩 则是将一个大的文件通过一些压缩算法变成一个小文件。 &emsp;&emsp;Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。 单个解压 *.tar 用 tar -xvf 解压 *.gz 用 gzip -d或者gunzip 解压 .tar.gz和.tgz 用 tar -xzf 解压 *.bz2 用 bzip2 -d或者用bunzip2 解压 *.tar.bz2用tar -xjf 解压 *.Z 用 uncompress 解压 *.tar.Z 用tar -xZf 解压 *.rar 用 unrar e解压 *.zip 用 unzip 解压 *.tar.xz 用 $xz -d *.tar.xz $tar -xvf *.tar *.tgz 用tar zxvf 解压 单个压缩文件 gzip File 压缩为.gz文件 bzip2 File 压缩为.bz2文件 zip [打包后的文件名] [打包的目录路径] 压缩为.zip文件 压缩一个或多个文件/文件夹格式：tar -options compressed_file files_to_be_compressed tar –zcvf 运行 + gzip 产生 a .tar.gz 文件 tar –jcvf 运行 tar + bzip2 产生 a .tbz2 文件 tar –cvf p运行 tar 产生 a .tar 文件 批量解压 方法一： for i in $(ls *.tar.gz);do tar xvf $i;done 方法二: for tarfile in *.tar.gz; do tar -xvf $tarfile; done 方法三: ls *.tar.gz|xargs -n1 tar xzvf &emsp;&emsp;xargs 是一条 Unix 和类 Unix 操作系统的常用命令；它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题。 例如： echo “1 2 3 4”|xargs -n11234echo “1 2 3 4”|xargs -n21 23 4 所以，加n1参数，则*.tar.gz会拆成每个tar.gz文件后，一个一个传给tar xzvf命令 方法四： find -maxdepth 1 -name “*.tar.gz”|xargs -i tar xvzf {} &emsp;&emsp;这条命令可解压当前目录下的所有gz文件，maxdepth表示搜索深度，1代表只搜索当前目录 补充使用tar -xvf *.tar.gz会出错，提示“Not found in archive”？ 通配符是shell解决的问题,如 tar -xvf *.tar.gz 实际上执行tar时，tar接收到的是 tar -xvf a.tar.gz b.tar.gz c.tar.gz … 如果当前目录跟本没有tar的东西，那么tar就收到’*.tar.gz’这个参数 与win不同，linux所有字符都可以作文件名，也即目录中不存在着 *.tar.gz这个文件 扩展同样可以利用for循环遍历操作某一类文件，比如批量建索引。 for i in `ls` do samtools faidx $i done]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NGS数据格式BED/GFF/GTF之介绍，比较，转换]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F08%2F15%2FNGS%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8FBED-GFF-GTF%E4%B9%8B%E4%BB%8B%E7%BB%8D-%E6%AF%94%E8%BE%83-%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;NGS数据格式BED/GFF/GTF之介绍，比较，转换 Ensemble与UCSC各种格式说明Ensemble各种格式说明： http://www.ensembl.org/info/website/upload/bed.html UCSC各种格式说明： http://genome.ucsc.edu/FAQ/FAQformat.html#format1 基因组坐标系统&emsp;&emsp;计算机和现实世界有一个差别，即计算机的计数是从0开始的（即0-based），而现实生活中，我们的计数是从1开始的（即1-based）。在生物学领域的不同场合，这两种计数交杂出现 两套不同理念的坐标系统——base coordinate system(BCS)和interbase coordinate system（ICS） 我们先来分析一下这样的两套系统在表述序列位置时的差别 类型 1-based 0-based 单个核苷酸 4-4: T 3-4: T 一组核苷酸 4-6: TAA 3-6: TAA deletion 4-4: T/- 3-4: T/- insertion（表示AGGTCGAAGT） 4-5: -/CG 4-4: -/CG &emsp;&emsp;如果说我们不管0-based和1-based这两种计数方式对应的坐标系统，都将其视为对序列第一个核苷酸的描述（即第一个核苷酸是算0还是算1），那么0-based的系统，其区间其实是一个左闭右开的区间，而1-based的系统则是一个闭区间。 1-based，正如前述，就是为了符合人的计数习惯。那UCSC为什么要采用0-based的interbase coordinate system系统？ICS主要的好处体现在下面的几个方面： 对于splicing sites等涉及两个核苷酸之间位置的情况，ICS提供了一个更好的呈现方案； 对于site的计算更加方便，如length=end-start; 对于坐标的转换，尤其是正负链坐标间的转换更加方便。（revStart = chromSize – oneEnd，revEnd = chromeSize – zeroStart）。 NCBI等组织采用的是和人日常习惯一致的1-based计数系统，即用数字指代核苷酸位置。但是UCSC发现使用0-based计数系统（用数字指代核苷酸间的位置） &emsp;&emsp;应用范畴：对于直接给所有用户提供直观访问服务的data portal（比如说NCBI、Ensembl、UCSC Genome Browser、mirBase）、常用的生物信息学软件（如BLAST）以及某些格式的文件（如GFF、SAM、VCF），采用的是1-based的计数方法。与之相反，UCSC的Table Browser以及它在数据库中存储的数据、BED/BAM等格式的文件，以及Chado、DAS2、dbSNP这样的data portal则采用的是0-based的计数方法。 单个格式介绍BED格式 注意： chromStart起始坐标第一个碱基为0 BED行名会展示在基因组浏览器中的bed行的左侧 UCSC中展示效果： 其实，你可以通过UCSC Genome Browser展示你的注释 tracks数据,并以可视化的方式与其他注释数据进行比较！！！ UCSC官方说明—-Displaying Your Own Annotations in the Genome Browser： http://genome.ucsc.edu/goldenPath/help/customTrack.html#EXAMPLE1 具体介绍&emsp;&emsp;个人的注释数据再上传48小时后将失效，除非你登陆并创建会话。 如何登陆Genome Browser并创建会话： http://genome.ucsc.edu/goldenPath/help/hgSessionHelp.html#CTs 当然，你也可以查看别人的定制注释tracks数据： http://genome.ucsc.edu/goldenPath/customTracks/custTracks.html Genome Browser annotation tracks是基于面向行格式的文件的，文件中每行展示一个track特征，注释文件包含三种类型的行：browser lines, track lines, and data lines。空行和其他以#开头的行将被忽略。 如何构建注释文件呢？ （1）数据格式 目前支持标准的GFF格式，以及为Human Genome Project 和 UCSC Genome Browser定制的数据格式，常见的如BED,BAM,VCF,MAF等。注意GFF和GTF文件必须以tab键分割，而不是以空格分隔。参考染色体必须以chrN的形式（区分大小写）。 （2）定义 Genome Browser展示特征的区间 例如：browser position chr22:20100000-20100900 没有的话，展示的tracks在基因组的位置可能不对 （3）定义注释track的一些属性 例如track的name, description, colors, initial display mode, use score等等 如何展示呢？ 例如注释数据如下： browser position chr22:1000-10000browser hide alltrack name=”BED track” description=”BED format custom track example” visibility=2 color=0,128,0 useScore=1chr22 1000 5000 itemA 960 + 1100 4700 0 2 1567,1488, 0,2512chr22 2000 7000 itemB 200 - 2200 6950 0 4 433,100,550,1500 0,500,2000,3500 网址： http://genome.ucsc.edu/cgi-bin/hgCustom &emsp;&emsp;当然，可视化展示并不是真正的目的，主要目的是与其他注释数据进行比较，从而发现某些科学问题。最上面是你的track(Custom Tracks),下面就是按照不同数据类型划分的注释数据，默认都是隐藏的（hide），你可以勾选相应你感兴趣的数据，选择（hide,dense,squish,pack,full）不同展现形式显示其他注释数据，然后refresh，进行可视化比较。 GFF格式参考： http://www.bbioo.com/lifesciences/40-112835-1.html GFF格式（General Feature Format）是一种简单的以tab键分割的，用于描述基因组特征的格式文件。有GFF1, GFF2，GFF3和GTF2四种版本。 GFF1 注意： start第一个碱基是从1开始计数的 frame：在feature是coding exon时，frame可以取值0-2，表示读码框的第一个碱基；如果不是coding exon,则用.表示 GFF1与其他GFF格式的最大区别在于所有相同的feature的行是聚集在一起的 扩展名为.gff1而不是gff GFF2http://gmod.org/wiki/GFF2 注意： start第一个碱基是从1开始计数的 frame：在feature是coding exon时，frame可以取值0-2，表示读码框的第一个碱基；如果不是coding exon,则用.表示 attribute：用;分隔键值对（tag-value），为每个feature提供额外的信息。同时attribute包含identifiers，可以用于联系各个特征。 扩展名为.gff2而不是gff GFF2格式的不足 &emsp;&emsp;GFF2的一个问题是它只能表现一个层次的嵌套功能。 当处理具有多个交替剪接的转录物的基因时存在问题。 GFF2无法处理基因→转录本→外显子的三级体系。 大多数人给出一系列的转录本，并给出类似的名称来表明它们来自相同的基因。 第二个限制是，虽然GFF2允许您创建两级层次结构，如转录本→外显子，但它没有层次结构方向的任何概念。 所以它不知道外显子是否是转录本的subfeature，反之亦然。 这意味着你必须使用“aggregators”来整理关系。 因此，GFF2格式已被弃用，转而支持GFF3格式。 但是，目前Genome Browser是不支持GFF3的，所有的GFF track都是基于Sanger’s GFF2 specification GFF3http://gmod.org/wiki/GFF3 注意： start第一个碱基是从1开始计数的 phase：在feature是coding exon时，phase可以取值0-2，表示读码框的第一个碱基；如果不是coding exon,则用.表示 attribute：用 “=” 分隔键值对（tag-value），为每个feature提供额外的信息。同时attribute包含identifiers，可以用于联系各个特征。 扩展名为.gff3而不是gff 与其他GFF版本格式最大区别在于： 第一行表明版本：##gff-version 3 第9列attributes关联了转录本，之前的GFF版本限制于低层次的feature(exon) key=value具有特殊的含义 ID - unique idenfifier for this feature. Parent - idenfier of parent feature. Name - used as the feature label in the feature map. GTFGTF是另外一种与GFF2十分相似的数据格式，有时称之为GFF2.5。GTF的前8列与GFF2完全一样，group列（attribute列）被扩展了，每个属性包含了一个 type/value pair，属性以;结束，初次之外，属性之间还有一个空格。 属性列（第9列）： gene_id value - A globally unique identifier for the genomic source of the sequence. transcript_id value - A globally unique identifier for the predicted transcript. 属性列例子(UCSC)： gene_id &quot;Em:U62317.C22.6.mRNA&quot;; transcript_id &quot;Em:U62317.C22.6.mRNA&quot;; exon_number 1 属性列例子(Ensemble)： gene_id &quot;ENSG00000223972&quot;; transcript_id &quot;ENST00000456328&quot;; gene_name &quot;DDX11L1&quot;; gene_sourc e &quot;havana&quot;; gene_biotype &quot;transcribed_unprocessed_pseudogene&quot;; transcript_name &quot;DDX11L1-002&quot;; transcript_source &quot;havana&quot;; GTF是不被 GMOD支持的，如果使用，可以将其转换为GFF3格式。 不同格式比较BED和GFF/GTF BED文件中起始坐标为0，结束坐标至少是1,； GFF中起始坐标是1而结束坐标至少是1 两者都是基因注释文件，gtf的一行表示一个exon，多行表示一个基因。而bed的一行表示一个基因。 GTF与GFF区别 简单来说：GFF 2 -&gt; GTF -&gt; GFF 3 G的定义不同 GFF全称为general feature format，这种格式主要是用来注释基因组。 GTF全称为gene transfer format，主要是用来对基因进行注释。 GTF是在GFF（GFF2）的基础上的一个改良，GTF的前8列信息与GFF是一样的，主要区别在第九列，GTF扩充很多GFF不具备的其他的信息 数据格式转换 file conversion script GTF to GFF3 gft2gff3 GTF to BED gtf2Bed.pl BED to GTF bedToGtf.sh 汇总，将各种格式转换为GFF格式的脚本。这些脚本分散在不同的软件包中，可以根据需要下载使用。 bioPerl script description search2gff This script will turn a protein Search report (BLASTP, FASTP, SSEARCH, AXT, WABA) into a GFF File. genbank2gff3.pl Genbank to gbrowse-friendly GFF3 gff2ps This script provides GFF to postscript handling. 如果你在win下安装了perl及bioperl直接在文件夹下搜索便可以找到上述脚本，可以直接使用 gbrowse script description ucsc_genes2gff Convert UCSC Genome Browser-format gene files into GFF files suitable for loading into gbrowse blast92gff3.pl BLAST tabular output (-m 9 or 8) conversion to GFF version 3 format, DAWGPAWS script description cnv_blast2gff.pl This program will translate a blast report for a single query sequence into the GFF format. Tandy software script description gff2aplot a program to visualize the alignment of two genomic sequences together with their annotations. From GFF-format input files it produces PostScript figures for that alignment. blat2gff Converts BLAT output files to GFF formatted files BioWiki中还有一篇，总结更多GFF工具的文章，请参看下面链接： http://biowiki.org/GffTools 参考（1）http://blog.sciencenet.cn/blog-981687-726831.html （2）http://blog.sciencenet.cn/blog-1509670-847310.html （3）https://www.yaolibio.com/2016/08/15/gene-coordinate-system/]]></content>
      <categories>
        <category>NGS</category>
      </categories>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[miniconda3安装及使用]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F08%2F14%2Fminiconda%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[miniconda3安装及使用 安装miniconda版本选择，选择miniconda3, miniconda2存在bug: Using conda with Python 2 with non-ASCII characters in your install path is basically not supported (see #1180) https://github.com/conda/conda/issues/1631 安装miniconda3wget https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh bash Miniconda3-latest-Linux-x86_64.sh Perl 模块的安装是可以用 conda 搞定的，比如安装 DBD::Sqlite 模块，使用 conda install perl-dbd-sqlite 添加清华镜像： conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ 显示URL： conda config --set show_channel_urls yes 添加channel（bioconda中国镜像已经在清华tuna镜像源的一个服务器上建成）： #conda config –add channels bioconda conda config --add channels https://nanomirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/conda 使用 查看一个包是否可用conda来安装（注意：并不是所有的包都可以用conda来安装） conda search 包名 指定安装包版本 conda install bedtools==2.17 查看Anaconda已经安装的python包列表 conda list 删除包 conda remove –name 环境变量名 包名 查看已创建的环境变量 conda info –envs Set up channels After installing conda you will need to add the bioconda channel as well as the other channels bioconda depends on. It is important to add them in this order so that the priority is set correctly (that is, bioconda is highest priority). The conda-forge channel contains many general-purpose packages not already found in the defaults channel. The r channel is only included due to backward compatibility. It is not mandatory, but without the r channel packages compiled against R 3.3.1 might not work. (conda config –add channels r) conda config –add channels defaults conda config –add channels conda-forge conda config –add channels bioconda conda安装模式可以指定仓库(channel), 比如安装bioconda的软件： conda config --add channels bioconda conda install -c bioconda agg ANNACONDA CLOUD 网址 导出已安装包信息，在新环境下批量安装 conda list -e &gt; conda_requirements.txt while read requirement; do conda install -c bioconda –yes $requirement; done &lt; conda_requirements.txt 参考（1）https://mp.weixin.qq.com/s/z2xAghI_kk4Lb9_JZAizGw （2）Linux 平台轻松解决Python3环境： conda （3） CondaHTTPError: HTTP 000 CONNECTION FAILED for url]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux神器之grep,awk操作gtf文件]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F08%2F14%2FLinux%E7%A5%9E%E5%99%A8%E4%B9%8Bgrep%2Cawk%E6%93%8D%E4%BD%9Cgtf%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Linux神器之grep,awk操作gtf文件 Linux神器之grep,awk操作gtf文件过滤#开头注释行grep -v ^# Homo_sapiens.GRCh38.89.chr.gtf |head -5 补充： -v:反向选择 过滤空行：grep -v ‘^$’ filename 过滤空行和以#开头的行: grep -vE ‘^#|^$’ filename -E表示“或”的关系。 提取并计数有多少类featuregrep -v ^# Homo_sapiens.GRCh38.89.chr.gtf |awk &apos;{print $3}&apos;| sort | uniq -c 结果： 710166 CDS 1193694 exon 143497 five_prime_utr 58174 gene 119 Selenocysteine 83231 start_codon 74952 stop_codon 136436 three_prime_utr 199167 transcript （第一列为数目，第二列为features） 筛选出特定行第一列为染色体1-22加X,Y的行 awk &apos;$1 ~ /[0-9]/ || $1 ~ /[X|Y]/&apos; Homo_sapiens.GRCh38.89.chr.gtf | tail -5 第三列为”gene”的行 awk &apos;$3==&quot;gene&quot;&apos; Homo_sapiens.GRCh38.89.chr.gtf |head -5 查看每条染色体多少个基因 awk &apos;$1 ~ /[0-9]/ || $1 ~ /[X|Y]/&apos; Homo_sapiens.GRCh38.89.chr.gtf | awk &apos;$3==&quot;gene&quot;&apos;| awk &apos;{print $1}&apos;| sort | uniq -c 结果： 5224 1 2208 10 3248 11 2952 12 1312 13 2214 14 2155 15 2509 16 3018 17 1174 18 2951 19 3971 2 1391 20 837 21 1339 22 3019 3 2504 4 2869 5 2860 6 2884 7 2367 8 2246 9 2366 X 519 Y （第一列为数目，第二列为染色体号） 先过滤出基因，然后按照chr顺序排序然后根据基因起始位置排序awk &apos;$1 ~ /[0-9]/ || $1 ~ /[X|Y]/ &amp;&amp; $3==&quot;gene&quot;&apos;Homo_sapiens.GRCh38.89.chr.gtf|sort -t $&apos;\t&apos; -k1,1n -k4,4n &gt;result_gene_sort.txt (因为根据asc码排序，所以X,Y会排在1-22之前) awk &apos;$1 ~ /[0-9]/ &amp;&amp; $3==&quot;gene&quot;&apos; Homo_sapiens.GRCh38.89.chr.gtf | sort -t $&apos;\t&apos; -k1,1n -k4,4n &gt;result_gene_sort.txt awk &apos;$1 ~ /[X|Y]/ &amp;&amp; $3==&quot;gene&quot;&apos; Homo_sapiens.GRCh38.89.chr.gtf |sort -t $&apos;\t&apos; -k1,1 -k4,4n &gt;&gt;result_gene_sort.txt sort 参数： -k 选择以哪个区间进行排序 -n 依照数值的大小排序 sort多字段的排序: -t $’\t’ 指定使用tab键分列 -k1,1n 指定以第一列按照数字（asc码）从大到小排序 -k4,4n 指定以第一列按照数字（asc码）从大到小排序 注意： （1）对于tab分隔符，还是得稍微注意一下。比如下面的命令： $sort -t &apos;\t&apos; -k3,3n a.txt &gt;a.sort sort: multi-character tab `\t’ (出错） 这个不能按照tab分隔符进行字段排序，换成如下方式就可以了 $ sort -t $&apos;\t&apos; -k3,3n a.txt&gt;a.sort （2）linux sort 命令能不能识别 科学计数法？例如 9.98E-9。使用-n得不到想要的结果，但可以使用-g 替代，它会将数字还原成一版格式再进行比较。 计算所有CDS的累积长度，其他类似cat Homo_sapiens.GRCh38.89.chr.gtf | awk &apos;$3 ==&quot;CDS&quot; { len=$5-$4 + 1; size += len; print &quot;Size:&quot;, size } &apos; （结果输出刷屏了！！加上个 |tail -1） 计算1号染色体cds的平均长度awk &apos;BEGIN {s = 0;line = 0 } ;$3 ==&quot;CDS&quot; &amp;&amp; $1 ==&quot;1&quot; { s += ($5 - $4);line += 1}; END {print &quot;mean=&quot; s/line}&apos; Homo_sapiens.GRCh38.89.chr.gtf 补充： awk的BEGIN和END 通常使用BEGIN来显示变量和预置（初始化）变量，使用END来输出最终结果。 总结一下awk基本结构为 : BEGIN{BEGIN操作,在输入文件之前执行} ; {文件行处理块,对来自输入文件datafile的每一行都要执行一遍} ; END{END操作,输入文件关闭后awk退出之前执行} 从gtf文件中分离提取基因名字$3 == &quot;gene&quot; { # 通过 ; 分离提取第9列 split($9, x, &quot;;&quot;) # 基因名字是第一个元素。 # 去除基因名字旁边的双引号 name = x[1] # 由于 &quot; 是一个特殊字符，我们必须写成 \&quot;;*反斜杠\表示转义符。 gsub(&quot;\&quot;&quot;, &quot;&quot;, name) # 打印特征类型、基因名字以及大小。 print name, $5 - $4 + 1} 最后，我们可以写成下边这条命令: cat result_gene_sort.txt |awk &apos;$3 == &quot;gene&quot;{split($10,x,&quot;;&quot;);name = x[1];gsub(&quot;\&quot;&quot;, &quot;&quot;, name);print name,$5-$4+1}&apos;|head -5 根据基因名列表提取gtf文件（1）shell脚本 ./sub_gtf.sh gene.txt Homo_sapiens.GRCh38.89.chr.gtf &gt;logfile 2&gt;&amp;1 #!/bin/bash set -u set -e set -o pipefail if [[ $# != 2 ]];then echo &quot;Parameter incorrect.&quot; exit 1 fi gene_file=$1 gtf_file=$2 gene=($(cat ${gene_file})) for gene in ${gene[@]}; do grep &quot;\&quot;${gene}\&quot;&quot; ${gtf_file} &gt;&gt;result.txt done （2）单行命令 gene=($(cat gene.txt));for gene in ${gene[@]}; do grep &quot;\&quot;${gene}\&quot;&quot; Homo_sapiens.GRCh38.89.chr.gtf &gt;&gt;result.txt;done 补充基本语法：&emsp;&emsp;awk擅长处理表格形式的数据。它逐行从文本中读取数据，将整行数据（record)定义为$0,然后根据指定的分隔符，将各列数据（record)分别定义为$1,$2,$3，然后使用如下结构处理数据： pattern1 {action1};pattern2 {action2};.... 注意： 如果没有定义pattern,则直接执行action； 如果没有提供action,则直接输出满足pattern的内容 补充知识点 grep -w, –word-regexp 强制 PATTERN 仅完全匹配字词 grep 匹配TAB键 grep -P ‘\tsh’ file.txt grep $’\tsh’ test file.txt 查看gene_biotypecat Homo_sapiens.GRCh38.85.gtf | cut -f 9 | tr &apos;;&apos; &apos;\n&apos; | grep &quot;gene_biotype&quot; | sed &apos;s/gene_biotype//&apos; | sort -u &gt;gene_biotype_hg38_91.txt 参考：（1）http://www.jianshu.com/p/7af624409dcd （2）https://mp.weixin.qq.com/s/NZCt2SR3WmCnqpb2FGcbsQ （3）Calculate transcript length of GTF file]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何写shell脚本]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F08%2F13%2F%E5%A6%82%E4%BD%95%E5%86%99shell%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[shell代码风格规范及技巧 shell代码风格规范及技巧命名有标准文件名规范，以.sh结尾，方便识别 编码要统一&emsp;&emsp;在写脚本的时候尽量使用UTF-8编码，能够支持中文等一些奇奇怪怪的字符。不过虽然能写中文，但是在写注释以及打log的时候还是尽量英文，毕竟很多机器还是没有直接支持中文的，打出来可能会有乱码。 &emsp;&emsp;这里还尤其需要注意一点，就是当我们是在windows下用utf-8编码来写shell脚本的时候，一定要注意这个utf-8是否是有BOM的。默认情况下windows判断utf-8格式是通过在文件开头加上三个EF BB BF字节来判断的，但是在Linux中默认是无BOM的。因此如果我们是在windows下写脚本的时候，一定要注意将编码改成Utf-8无BOM，一般用notepad++之类的编辑器都能改。否则，在Linux下运行的时候就会识别到开头的三个字符，从而报一些无法识别命令的错。 开头有shebang&emsp;&emsp;所谓shebang其实就是在很多脚本的第一行出现的以”#!”开头的注释，他指明了当我们没有指定解释器的时候默认的解释器，一般可能是下面这样： #!/bin/bash 写出健壮Bash Shell脚本技巧set -x set -e set -u set -o pipeline （1）set -x会在执行每一行 shell 脚本时，把执行的内容输出来。它可以让你看到当前执行的情况，里面涉及的变量也会被替换成实际的值。 （2）在”set -e”之后出现的代码，一旦出现了返回值非零，整个脚本就会立即退出。 &emsp;&emsp;set -e结束程序的条件比较复杂，在man bash里面，足足用了一段话描述各种情景。大多数执行都会在出错时退出，除非 shell 命令位于以下情况： 一个 pipeline 的非结尾部分，比如 error | ok 一个组合语句的非结尾部分，比如 ok &amp;&amp; error || other 一连串语句的非结尾部分，比如 error; ok 位于判断语句内，包括test、if、while等等。 （3）set -u，当你使用未初始化的变量时，让bash自动退出 （4）set -o pipefail 设置了这个选项以后，包含管道命令的语句的返回值，会变成最后一个返回非零的管道命令的返回值。听起来比较绕，其实也很简单： 例如test.sh set -o pipefail ls ./a.txt |echo &quot;hi&quot; &gt;/dev/null echo $? &amp;&gt; 等如 2&gt;&amp;1 , &gt; 等如 1&gt; ,那是缩写 1 是 STDOUT, 2 是 STDERR, 2&gt;&amp;1 就是 STDOUT 和 STDERR，同导向到同一文件里 运行test.sh，因为当前目录并不存在a.txt文件，输出：ls: ./a.txt: No such file or directory1 # 设置了set -o pipefail，返回从右往左第一个非零返回值，即ls的返回值1 注释掉set -o pipefail 这一行，再次运行，输出：ls: ./a.txt: No such file or directory0 # 没有set -o pipefail，默认返回最后一个管道命令的返回值 工作路径我们会先获取当前脚本的路径，然后一这个路径为基准，去找其他的路径。 work_dir=$1 reference=${work_dir}/data/reference/TAIR10_chr_all.fas 环境变量PATH一般情况下我们会将一些重要的环境变量定义在开头，确保脚本中使用的命令能被bash搜索到。 PATH=/bin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin 运行脚本chmod +x ./test.sh #给脚本权限 ./test.sh #执行脚本 Shell中的变量 “=”前后不能有空格 定义时不用$,使用时需要$,且推荐给所有变量加上花括号{} 脚本的参数 先定义具体含义，后使用 gene_file=$1 ${gene_file} 代码有注释 简述某一代码段的功能 各个函数前的说明注释 太长要分行在调用某些程序的时候，参数可能会很长，这时候为了保证较好的阅读体验，我们可以用反斜杠来分行： ./configure \ –prefix=/usr \ –sbin-path=/usr/sbin/nginx \ –conf-path=/etc/nginx/nginx.conf \ 日志例如： ./sub_gtf.shell gene.txt Homo_sapiens.GRCh38.89.chr.gtf &gt;logfile 2&gt;&amp;1 1 ：表示stdout标准输出，系统默认值是1，所以”&gt;logfile”等同于”1&gt;logfile”2 ：表示stderr标准错误&amp; ：表示等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于1 回显例如 if [[ $# != 2 ]];then echo &quot;Parameter incorrect.&quot; exit 1 fi 当执行： ./sub_gtf.shell gene.txt 因为参数数目不对，输出Parameter incorrect.至屏幕 当执行： ./sub_gtf.shell gene.txt &gt;logfile 2&gt;&amp;1 同样参数数目不对，但输出Parameter incorrect.至日志 函数相关巧用main函数,使得代码可读性更强#!/bin/bash func1(){ #do sth } func2(){ #do sth } main(){ func1 func2 } main &quot;$@&quot; 考虑作用域shell中默认的变量作用域都是全局的，比如下面的脚本： #!/usr/bin/env bash var=1 func(){ var=2 } func echo $var 他的输出结果就是2而不是1，这样显然不符合我们的编码习惯，很容易造成一些问题。 &emsp;&emsp;因此，相比直接使用全局变量，我们最好使用local, readonly这类的命令，其次我们可以使用declare来声明变量。这些方式都比使用全局方式定义要好。 local一般用于局部变量声明，多在在函数内部使用。（1）shell脚本中定义的变量是global的，其作用域从被定义的地方开始，到shell结束或被显示删除的地方为止。 （2）shell函数定义的变量默认是global的，其作用域从“函数被调用时执行变量定义的地方”开始，到shell结束或被显示删除处为止。函数定义的变量可以被显示定义成local的，其作用域局限于函数内。但请注意，函数的参数是local的。 （3）如果同名，Shell函数定义的local变量会屏蔽脚本定义的global变量。所以在函数内声明的变量，请务必记得加上 local 限定词 使用举例： #!/bin/bash function Hello() { local text=&quot;Hello World!!!&quot; #局部变量 echo $text } Hello 只读变量使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。 例如： readonly myUrl myUrl=&quot;http://www.runoob.com&quot; declare -r 只读 (declare -r var1与readonly var1作用相同) declare -r var1 -i 整数 declare -i number -a 数组 declare -a indices -f 函数 declare -f 函数返回值&emsp;&emsp;在使用函数的时候一定要注意，shell中函数的返回值只能是整数，估计是因为一般情况下一个函数的返回值通常表示这个函数的运行状态，所以一般都是0或者是１就够了，因此就设计成了这样。不过，如果非得想传递字符串，也可以通过下面变通的方法: func(){ echo &quot;2333&quot; } res=$(func) echo &quot;This is from $res.&quot; 这样，通过echo或者print之类的就可以做到传一些额外参数的目的。 使用新写法&emsp;&emsp;这里的新写法不是指有多厉害，而是指我们可能更希望使用较新引入的一些语法，更多是偏向代码风格的，比如 尽量使用func(){}来定义函数，而不是func{} 尽量使用[[]]来代替[] 尽量使用$()将命令的结果赋给变量，而不是反引号 在复杂的场 下尽量使用printf代替echo进行回显 事实上，这些新写法很多功能都比旧的写法要强大，用的时候就知道了。 其他小tip 读取文件时不要使用for loop而要使用while read 简单的if尽量使用&amp;&amp; ||，写成单行。比如[[ x &gt; 2]] &amp;&amp; echo x 利用/dev/null过滤不友好或者无用的输出信息 例如 if grep ‘pattern1’ some.file &gt; /dev/null &amp;&amp; grep ‘pattern2’ some.file &gt; dev/null then echo “found ‘pattern1’ and ‘pattern2’ in some.file” fi /dev/null ：代表空设备文件 安装shellcheckShellCheck, a static analysis tool for shell scripts shellcheck 除了可以提醒语法问题以外，还能检查出 shell 脚本编写常见的 bad code。 使用方式（１）网页版： http://www.shellcheck.net github仓库： https://github.com/koalaman/shellcheck 下载安装： wget -q https://storage.googleapis.com/shellcheck/shellcheck-latest.linux.x86_64.tar.xz xz -d shellcheck-latest.linux.x86_64.tar.xz tar -xvf shellcheck-latest.linux.x86_64.tar echo ‘export PATH=/home/wangdong/softwares/shellcheck:$PATH’&gt;&gt;~/.bashrc source ~/.bashrc 使用方式（2）终端： shellcheck yourscipts Shell不能做什么 需要精密的运算的时候 需要语言效率很高的时候 需要一些网络操作的时候 总之Shell就是可以快速开发一个脚本简化开发流程，并不可以用来替代高级语言 &emsp;&emsp;解决特定的问题要用合适的工具。知道什么时候用 shell，什么时候切换到另外一门更通用的脚本语言（比如ruby/python/perl），这也是编写可靠 shell 脚本的诀窍。如果你的任务可以组合常见的命令来完成，而且只涉及简单的数据，那么 shell 脚本就是适合的锤子。如果你的任务包含较为复杂的逻辑，而且数据结构复杂，那么你需要用ruby/python之类的语言编写脚本。 参考：（1）https://blog.mythsman.com/2017/07/23/1/ （2）https://github.com/koalaman/shellcheck （3）https://segmentfault.com/a/1190000006900083]]></content>
      <categories>
        <category>shell脚本</category>
      </categories>
      <tags>
        <tag>shell脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计sanger测序引物，验证突变位点]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F08%2F12%2F%E8%AE%BE%E8%AE%A1sanger%E6%B5%8B%E5%BA%8F%E5%BC%95%E7%89%A9%EF%BC%8C%E9%AA%8C%E8%AF%81%E7%AA%81%E5%8F%98%E4%BD%8D%E7%82%B9%2F</url>
    <content type="text"><![CDATA[在进行Variation calling 分析之后的故事 &emsp;&emsp;在进行Variation calling 分析之后。首先需要进行过滤，一般基于frequency和function两方面进行突变的过滤。 frequency过滤：根据千人基因组测序项目的等位基因频率预测的0.5%作为阈值，小于这一值的认为是突变，因为千人基因组对于我们检测到的变异属于健康对照，若该变异在健康对照的频率过高，则是致病突变的可能性就比较低了。 function过滤：一般看exonic区的non-synonymous，frameshift deletion，frameshift insertion，nonframeshift deletion，nonframeshift insertion，nonsynonymous SNV，stopgain，synonymous SNV等。 &emsp;&emsp;接着需要使用IGV查看变异位点的可靠性，并没有具体的标准。 一般先看看变异位点是否在reads的两端，若是，可能是接头没去干净； 其次看看具有该变异位点的reads占总reads的占比，一般保留&gt;50%的； 最后看看变异位点两端是否”干净”; 另外，如果有家系的数据，可以对比着看看家庭其他成员在该位点是否有相同的变异，并推测可能的遗传方式。 &emsp;&emsp;当然，以上方法得到的变异只能是初步的结果，还必须通过一代测序进行突变真实性的验证，今天的正题就是如何设计sanger测序引物？ 获取指定区域DNA序列网址：超链接 贴入位点，如chr7:74009352-74009352 先在UCSC中输入位点前500，后500个碱基， 点击get DNA ,复制结果 Primer-BLAST 设计引物网址：超链接 PCR product size 取300-500之间主要因为节省测序成本，同时，如果设计的引物没有中点在500附近的，主要可以通过调整PCR product size的上限，这样获得的产物长点就长点吧！ Get primers NCBI的Primer Blast 中这里选择的Genome(reference assembly from selected organisms)实际上是GRCh38版本。细心的可能注意到了，第一步获取序列用的是hg19版本的，但没关系，还有第三步UCSC In-Silico PCR验证呢！这一步选择的是hg19版本，这一步会进行blast!所以primer blast 和另两步的版本不同对结果不会有影响。 点击submit，之后比较慢，等等吧！（同时完成引物的设计和blast，主要是blast比较耗时！） 一般第一条结果比较好，但是如果给出的若干个引物中有一条的中心更趋近与500处（待检测位点位于中间有利于测序，因为一般测序结果两端50bp会出现杂峰），则最好选择这一条，翻查下面对应的引物的正反向序列。 UCSC In-Silico PCR验证引物网址： https://genome.ucsc.edu/cgi-bin/hgPcr?hgsid=603243225_C0DlViEzt0mvZEqK0DLtJx4pfsRN &emsp;&emsp;UCSC的PCR选项为电子PCR，输入引物（&gt;15bp），即可得到两引物间序列。UCSC是基于基因组而非转录组，如果两引物间隔很大，则先调节Max Product Size。UCSC自动预测的TM值是基于primer3的，跟我们用的DNAman算出来的值也比较接近，PCR时可直接使用其退火温度。 用法：打开UCSC中的in silicon PCR，将上下游引物分别输入，可以选择物种，基因组，产物长度等，submit即可 Submit后，如果结果只对应处一条染色体上的一个位点，且primer melting温度控制在2度左右差范围即可，如下 整理结果： 参考 如何高效率地批量处理一代Sanger测序数据：链接]]></content>
      <categories>
        <category>NGS</category>
      </categories>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基因组数据下载]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F08%2F12%2F%E5%8F%82%E8%80%83%E5%9F%BA%E5%9B%A0%E7%BB%84%E6%95%B0%E6%8D%AE%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;常用到的基因组数据格式括:fasta,fastq,gff,GenBank format, EMBL format；常用的基因组数据库包括：（1）Ensembl基因组注释数据库；（2）UCUS基因组浏览器 &emsp;&emsp;常用到的基因组数据格式括:fasta,fastq,gff,GenBank format, EMBL format；常用的基因组数据库包括：（1）Ensembl基因组注释数据库；（2）UCUS基因组浏览器 （1）通过Ensembl基因组注释数据库下载网址：http://www.ensembl.org/info/data/ftp/index.html 下载数据前一定要仔细查看相应目录下的README文件 上述网页链接都是最新版的，并且会随着基因组版本的更新而更新，历史版本可以在以下网址查询并下载：http://www.gencodegenes.org/releases/ 可以找到Ensembl来源的各个版本的基因注释GTF或者GFF3文件 其FTP site地址为：ftp://ftp.sanger.ac.uk/pub/gencode/Gencode_human Freeze date GENCODE release Ensembl release Release date Genome assembly version 01.2017 27 90 08.2017 GRCh38.p10 03.2016 25 85, 86, 87 07.2016 GRCh38.p7 基因组序列下载:&emsp;&emsp;Ensembl提供的参考基因组有2种组装形式和3种重复序列处理方式, 分别是primary, toplevel和unmasked (dna)、soft-masked (dna_sm)和masked (dna_rm)。一般选择dna.primary或dna_sm.primary。 为什么选择Primary Primary assembly contains all toplevel sequence regions excluding haplotypes and patches. This file is best used for performing sequence similarity searcheswhere patch and haplotype sequences would confuse analysis. 网页版的也为Primary Assembly版本的，例如Homo sapiens chromosome 7, GRCh38.p7 Primary Assembly 为什么不选择masked &emsp;&emsp;Masked基因组是指所有重复区和低复杂区被N代替的基因组序列，比对时就不会有reads比对到这些区域。一般不推荐用masked的基因组，因为它造成了信息的丢失，由此带来的一个问题是uniquely比对到masked基因组上的reads实际上可能不是unique的。而且masked基因组还会带来比对错误，使得在允许错配的情况下，本来来自重复区的reads比对到基因组的其它位置。 另外检测重复区和低复杂区的软件不可能是完美的，这就造成遮盖住的重复序列和低复杂区并不一定是100%准确和敏感的。 &emsp;&emsp;soft-masked基因组是指把所有重复区和低复杂区的序列用小写字母标出的基因组，由于主要的比对软件，比如BWA、bowtie2等都忽略这些soft-mask，直接把小写字母当做大写字母比对，所以使用soft-masked基因组的比对效果和使用unmasked基因组的比对效果是相同的。 (1)文件命名规则： \.\.\.\.\.fa.gz species:物种的名称 assembly:基因组的版本 sequence type（主要有三类）: ‘dna’ - unmasked genomic DNA sequences. ‘dna_rm’ - masked genomic DNA.通过RepeatMasker软件 检测弥散的重复序列和低复杂度的区域，并将重复序列使用N替代。 ‘dna_sm’ - soft-masked genomic DNA. 指Soft-masked的DNA序列，其中的重复序列和低复杂度的区域会用其相应碱基的小写字母来表示 举个栗子（1）连续的N &gt;Homo_sapiens.GRCh38.dna_rm.chromosome.15.fa NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNTTAGAGACCTTGAGA GGAATTAAACATCTCTGTGAGTATATGCTGTAGGGCTTTGCTGCACTGTCCTTGGAGGCT （2）小写字母表示碱基 &gt;Homo_sapiens.GRCh38.dna_sm.chromosome.X.fa nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnctaaccctaaccctaaccct aaccctaaccctaaccctctgaaagtggacctatcagcaggatgtgggtgggagcagatt gacaacCCCTAGAAGAGCACCTGGTTGAtaacccagttcccatctgggatttaggggacc aggggccctgggacagccctgtacatgagctcctggtctgtaacacagttcccctgtggg gatttagggACTTGGGCCTTCTGTCTTTGGGATCTACTCTCTATGGGCCACACAGATATG &emsp;&emsp;所以，使用RepeatMasker和Tandem Repeats Finder (with period of 12 or less)识别的重复在dna_rm中用大写的N表示，而在dna_sm中用小写字母表示，而非重复序列用大写字母表示。至于序列的开头和结尾，无论是dna_rm还是dna_sm，N/n表示（A,C,G,T）任意一种，也叫做Gaps，它意味着真实具体是哪一种碱基，测序平台不能确定，N/n的数目可能是不确定碱基数,都被一并maked掉了，在序列分析的时候并不会分析。 为什么要这样做呢？&emsp;&emsp;RepeatMasker是一款基于Library-based，通过相似性比对来识别重复序列，可以屏蔽序列中转座子重复序列和低复杂度序列（默认将其替换成N），几乎用于所有物种，是做基因组、非编码RNA的必备软件。在人类基因组分析当中，大约 56% 的序列会被mask； RepeatMasker在进行序列比对时可以选用常见的几种算法，包括nhmmer、cross_match、ABBlast/WUBlast、RMBlast 、Decypher（可以安装多个比对引擎，但每次只能使用其中一个）。 &emsp;&emsp;RepeatMasker应该是做已知repeat和TE的。基本原理是用已知repeats去blast。所以潜在的未知重复序列应该是无法用repeatmasker找到的，而在mRNA中的repeat序列也不应该用RepeatMasker找。repeatmasker的实际意义，就象这个软件的名字一样，是为了mask掉repeat。从而在查找基因，鉴定有功能的ncRNA，或者设计引物等提供一个精简的序列。毕竟用带有大量TE和repeat的序列做引物设计或者基因和蛋白功能分析，最后验证的时候只是得到了一批repeat 重复序列的种类： Tandem repeats 串连重复 Satellite DNA 卫星DNA Variable number tandem repeat /Minisatellite 小卫星 Short tandem repeat（STR）/Microsatellite (Trinucleotide repeat disorders)微卫星 Interspersed repeats 散落重复 Transposon (Transposable elements (TEs) )转座子 Retrotransposon 反转录转座子 SINEs – Alu sequence, MIR 短散落元件 LINEs – LINE1, LINE2 长散落元件 LTRs – HERV, MER4, retroposon 长末端重复 DNA transposon DNA转座子 MER1, MER2, Mariners TIR（Terminal Inverted Repeat） 末端方向重复 Genomic island Genomic island &emsp;&emsp;这种对RepeatMasker 和 Tandem Repeats Finder用小写表示的方式，可以用于UCSC的Genome Browser来展示重复序列。 id type: 可选值包括chromosome,nonchromosomal,seqlevel。 （1）chromosome就不用说了； （2）nonchromosal中包含了暂时未能确定染色体的序列； （3）seqlevel包括sequence scaffolds, chunks 或者clones三个层次。 ‘scaffold’：通过短的测序reads拼接组装成更大的序列—-contigs（通常来自全基因组鸟枪测序，WGS），但是还不能组成到染色体的程度。通常还需要更多的测序，来消除gaps并确定顺序（tiling path） ‘chunk’:当contigs序列能被组装成大的实体时，有时候必须认为的将其打断为更小的实体，称之为’chunks’。这是由于注释管道的限制并且受存储序列和注释信息的MySQL数据库的记录限制。 ‘clone’ ：通常这是最小的序列实体。它经常与一个BAC clone或者部分区域的序列是一样的。 id:实际序列的标示符，和\对应 fa:表示文件格式为FASTA gz:文件压缩方式为GUN Zip toplevel文件中包含了所有的在ensembl数据库schema中被定义为toplevel的序列，包括染色体，未能组装到染色体上的区域以及含有N的haplotype/patch区域。 primary_assembly文件相比于toplevel文件，减去了含有N的haplotype/patch区域。这类文件比较适合用来比对。 除基因组注释文件（GTF或者GFF）下载&emsp;&emsp;例如在RNA-seq分析流程中，参考基因组序列用于reads的比对，而GTF或者GFF用于确定比对上的reads是否落在基因内，由此来相对定量基因的表达量，鉴定差异表达基因。 (1)文件命名规则：\.\.\.gtf.gz 注释基因生物证据的比对（例如蛋白，cdna，RNA-seq）来组装基因组 对于预测的基因集：\.\.\.abinitio.gtf.gz 这里的预测是指通过GenScan和其他的从头预测工具分析产生的基因。 确定了需要下载什么后，那如何下载呢？可以通过浏览器下载，但需要再上传到服务器；也可以通过之前介绍的多线程下载工具axel下载，速度很快。当然还可以使用ensembl提供的rsync工具下载。 （2）通过UCSC下载基因组注释数据 Genome Browser’s “Table Browser”： http://genome.ucsc.edu/cgi-bin/hgTables?command=start Bulk Downloads page： http://hgdownload.cse.ucsc.edu/downloads.html &emsp;&emsp;对于NGS的序列分析来说，如果没有reference genome和genome annotation下游的分析可能根本无法进行。UCSC提供的数据分为sequence和annotation两大类，对于人、小鼠在内的71种脊椎动物，可以从UCSC同时下载sequence和annotation，其他的一般只有sequence。 基因组的版本： &emsp;&emsp;不同的生物信息学数据库对于基因组的命名方式各不相同。以人为例，NCBI/ENSEMBL用GRCh系列命名，而UCSC则使用hg系列命名。这两套命名系统背后的版本对应关系如下： UCSC NCBI hg18 GRCh36 hg19 GRCh37 hg38 GRCh38 hg系列和GRCh系列主要的差别有两处： （1）hg系列的染色体命名是”chr”+染色体号，而GRCh系列的染色体没有前缀的”chr”； （2）hg系列序列是0-based（第一个核苷酸记0），GRCh系列是1-based（第一个核苷酸记1，两种计数方法的区别参见《基因组的坐标系统》）。 （1）从FTP站点获取 获取sequence UCSC的reference genome是分染色体保存的。 对于hg38来说，单个的染色体序列可以在以下网址下载： http://hgdownload.soe.ucsc.edu/goldenPath/hg38/chromosomes/ 所有染色体打包好的文件在以下网址下载： http://hgdownload.soe.ucsc.edu/goldenPath/hg38/bigZips/hg38.chromFa.tar.gz 如果需要下载其他版本（19/18），可以把上述链接中的hg38换成hg19/hg18。如果需要将所有的染色体序列合并到一个文件中，可以在下载完成后依次执行下列命令（POSIX compatible）： tar –xzvf hg38.chromFa.tar.gz cd hg38 cat *.fa &amp;gt; hg38.fa 获取注释 UCSC提供了SNP、RepeatMask、refSeq、GENCODE等注释文件。 但是在UCSC的FTP站点： http://hgdownload.soe.ucsc.edu/goldenPath/hg38/database 这些数据被分成了两个文件——一个是.sql结尾的SQL语句文件，描述了数据表的结构和创建数据表的方法；另一个是.txt.gz结尾的数据文件。我们可以通过.sql文件来查看表的结构，再把.txt.gz格式的文件解压后转换成所需要的格式。下面是将.txt.gz的数据文件转换成gtf格式的三个例子： RepeatMask gunzip rmsk.txt.gz gawk &apos;OFS=&quot;\t&quot;{print $6,&quot;rmsk &quot;,$12,$7+1,$8,&quot;.&quot;,$10,&quot;.&quot;,&quot; repName \&quot;&quot;$11&quot;\&quot;; repFamily \&quot;&quot;$13&quot;\&quot;;&quot;}&apos; rmsk.txt &amp;gt; rmsk.gtf simpleRepeat gunzip simpleRepeat.txt.gz gawk &apos;OFS=&quot;\t&quot;{print $2,&quot; simpleRepeat&quot;,&quot;trf&quot;,$3+1,$4,&quot;.&quot;,&quot;+&quot;,&quot;.&quot;,&quot;name \&quot;&quot;$5&quot;\&quot;; sequence \&quot;&quot;$17&quot;\&quot;;&quot;}&apos; simpleRepeat.txt &amp;gt; simpleRepeat.gtf RefSeq &emsp;&emsp;UCSC为RefSeq和GENCODE等以genePred形式保存的注释文件提供了专门的格式转换程序——genePredToBed、genePredToGenePred、genePredToFakePsl、genePredToGtf、genePredToMafFrames 各自的使用方法参见： http://hgdownload.soe.ucsc.edu/admin/exe/linux.x86_64/FOOTER 若需将RefSeq转存为gtf格式，可参考下列命令： gunzip refGene.txt.gz cut -f 2- refGene.txt | genePredToGtf -utr -source=hg38 file stdin refGene.gtf （2）从Table Browser获取针对annotation，UCSC还通过Table Browser页面 http://genome.ucsc.edu/cgi-bin/hgTables 提供了一个更加友好的获取方法。Table Browser的使用基本使用方法可以参考 http://genome.ucsc.edu/goldenPath/help/hgTablesHelp.html#GettingStarted 为了避免和官方帮助文档的重叠，我仅在这里分享在做REP项目过程中发现的几种比较tricky的用法。 （1）获取GENCODE转录本ID和Gene Symbol的映射 clade设置为”Mammal”, genome设置为”Human”，assembly设置为”Dec. 2013 (GRCh38/hg38)”； 将group设置为”Genes and Gene Predictions”，track设置为”All GENCODE V24”； Table设置为”Basic (wgEncodeGencodeBasicV24)”； Output format设置为”selected fields from primary and related tables”； 点击”get output”； 在新页面中勾选”name”和”name2”前的复选框； 点击”get output”即可； （2）获取5’UTR/3’ UTR/Coding Exons/Intron的BED文件 clade设置为”Mammal”, genome设置为”Human”，assembly设置为”Dec. 2013 (GRCh38/hg38)”； 将group设置为”Genes and Gene Predictions”，track设置为”All GENCODE V24”； Table设置为”Basic (wgEncodeGencodeBasicV24)”； Output format设置为”BED – browser extensible data”； 点击”get output”； 在新页面中勾选自己需要的elements； 点击”get BED”即可。 （3）获取指定范围的序列 UCSC可以通过使用符合自己需要的注释数据，然后再获取进一步的数据。操作方法如下： 点击Table Browser的”add custom tracks”按钮； 在”Paste URLs or data”中添加数据的地址或者使用旁边的文件上传框上传文件，点击”Submit”； 在新页面中选择view in“Table Brower”，点击”go”，这时会跳回Table Browser； 这个时候将region选为“genome”，将Output format设置成”sequence”，结果可以选择“plain text”呈现或者“gzip compressed”下载，点击”get output”即可获取指定范围内的序列。 （4）Table Browser使用过程中可能会遇到的问题 由于抽取数据脚本执行超时（&gt;10min）或者下载地的网络不佳，下载下来的文件可能会不完整； 获取3’ UTR等序列时，若直接将track指定为系统自带的annotation，会有概率出现序列的start与annotation中不符的情况（0-based和1-based的杂合），建议先下载BED文件，然后通过前述的“获取指定范围的序列”来下载序列。 (3)从NCBI下载GFF注释文件在Assembly数据库搜索对应版本，例如GRCh37.p13，在右侧点击Download the RefSeq assembly进入FTP下载即可 补充 iGenomes The iGenomes are a collection of reference sequences and annotation files for commonly analyzed organisms. The files have been downloaded from Ensembl, NCBI, or UCSC, and chromosome names have been changed to be simple and consistent with their download source. 参考：（1）为什么序列分析要repeatmasker： http://www.dxy.cn/bbs/topic/9424163 （2）博耘生物： http://boyun.sh.cn/bio/?p=1845 （3）linux进进阶屋： http://sookk8.blog.51cto.com/455855/328076/ （4）BioDog的博客： https://www.yaolibio.com/2016/09/01/retrieve-genome-data-from-ucsc/ （5）6有才 http://www.jianshu.com/p/542c78a8ee0a （6）生信宝典 https://mp.weixin.qq.com/s/2OoXy4f1t0hE8OUqsAt1kw （7）生物信息学数据库资源]]></content>
      <categories>
        <category>NGS</category>
      </categories>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux多线程下载工具axel编译安装]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F08%2F06%2FLinux%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;linux 效率工具持续收集 &emsp;&emsp;Axel插件是基于yum下的一个多线程下载插件。axel插件也可以当独立下载工具来使用。当成独立下载工具使用时，适用于所有Linux发行版。通过打开多个HTTP/FTP连接来将一个文件进行分段下载，从而达到加速下载的目的。对于下载大文件，该工具特别有用。同时支持断点续传，速度通常情况下是Wget的几倍。可用于CentOS、RHEL、Fedora等使用yum的Linux发行版。由于没有管理员权限，只能编译安装源码。使用Axel可以在低速网络环境里提高数倍的下载速度。 Linux多线程下载工具axel编译安装&emsp;&emsp;Axel插件是基于yum下的一个多线程下载插件。axel插件也可以当独立下载工具来使用。当成独立下载工具使用时，适用于所有Linux发行版。通过打开多个HTTP/FTP连接来将一个文件进行分段下载，从而达到加速下载的目的。对于下载大文件，该工具特别有用。同时支持断点续传，速度通常情况下是Wget的几倍。可用于CentOS、RHEL、Fedora等使用yum的Linux发行版。由于没有管理员权限，只能编译安装源码。使用Axel可以在低速网络环境里提高数倍的下载速度。 官方主页:http://axel.alioth.debian.org/ 下载安装下载： wget https://sourceforge.net/projects/axel2/files/axel-2.4/axel-2.4.tar.gz tar -xzf axel-2.4.tar.gz cd axel-2.4 编译安装： ./configure --prefix=/home/u641750/axel-2.4 make &amp;&amp; make install 添加环境变量： echo &apos;export PATH=/home/u641750/axel-2.4/bin:$PATH&apos;&gt;&gt;~/.bashrc source ~/.bashrc 使用参数如下： –max-speed=x , -s x 最高速度x，指定每秒的最大比特数 –num-connections=x , -n x 指定线程数 –output=f , -o f 指定另存为目录f –search[=x] , -S [x] 搜索镜像 –header=x , -H x 添加头文件字符串x（指定 HTTP header） –user-agent=x , -U x 设置用户代理（指定 HTTP user agent –no-proxy ， -N 不使用代理服务器 –quiet ， -q 静默模式 –verbose ，-v 更多状态信息 –alternate ， -a Alternate progress indicator –help ，-h 帮助 –version ，-V 版本信息 测试例如下载Python安装包：time axel -n 10 http://mirrors.sohu.com/python/3.4.1/Python-3.4.1.tar.xz time wget http://mirrors.sohu.com/python/3.4.1/Python-3.4.1.tar.xz 如果下载过程中下载中断可以再执行下载命令即可恢复上次的下载进度 当然，linux也还有其他的多线程下载工具，比如myget。有人测试，axel、myget支持多线程，且速度较快都在2M。断点续传对比，三个工具都支持，但wget需要增加-c参数，axel、myget再次执行命令即可。 例如： wget -c http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso 参考：（1）（原创）CentOS 5.x/6.x下安装Axel多线程下载插件加速yum下载！ （2）Axel命令 （3）Dreamway的运维点滴（推荐阅读） （4）Linux 常用工具之 Axel &emsp;&emsp;zsh是bash的增强版，可以兼容bash，可谓是shell中的战斗机，非常方便的命令提示、补全、忽略大小写等功能 安装参考：http://www.zxzyl.com/archives/1001 配置环境变量PATH即可，使用时exec zsh -l （避免启动shell时切换zsh，这会导致xftp连接不上） pigz这款神器，可以在压缩数据时，发挥多核多处理器的优势，简而言之就是利用多线程进行gzip任务，比单纯的gzip压缩要快很多，有人测试快了5倍多 安装参考：连接]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SRA数据加速下载打包解决]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F08%2F06%2FSRA%E6%A0%BC%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8A%A0%E9%80%9F%E4%B8%8B%E8%BD%BD%E6%89%93%E5%8C%85%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;NCBI维护Short Read Archive (SRA)作为大规模平行测序（NGS）项目产生的数据仓库。这些方法在单个循环中能产生数百万碱基至千兆级碱基的数据，是标准Sanger测序仪输出的数百万倍。运用这些技术，包括新基因组的测序，捕获基因组区域测序，多个个体的完整基因组测序来寻找变异，转录组测序来研究样本可变剪切变异和表达水平，环境样本和其他宏基因组，染色质DNA结合蛋白分析等。SRA数据库可以用于搜索和展示SRA项目数据，包括SRA主页和 Entrez system。 &emsp;&emsp;NCBI维护Short Read Archive (SRA)作为大规模平行测序（NGS）项目产生的数据仓库。这些方法在单个循环中能产生数百万碱基至千兆级碱基的数据，是标准Sanger测序仪输出的数百万倍。运用这些技术，包括新基因组的测序，捕获基因组区域测序，多个个体的完整基因组测序来寻找变异，转录组测序来研究样本可变剪切变异和表达水平，环境样本和其他宏基因组，染色质DNA结合蛋白分析等。SRA数据库可以用于搜索和展示SRA项目数据，包括SRA主页和 Entrez system。 SRA下载方式：（1）Aspera（2）sratoolkit（3）FTP 比较：通过sratoolkit，可以直接下载成fastq格式，速度比ftp快，比aspera慢。 Aspera关于速铂Aspera &emsp;&emsp;速铂Aspera是一套商业的高速文件传输解决方案，随着高通量数据的大量产生，从而对于大文件快速传输的需求，开始应用到生物领域，目前NCBI、EBI的SRA库都提供这样的服务。 &emsp;&emsp;传统的FTP、HTTP等数据传输协议都是基于TCP的，TCP在远距离数据传输中存在一些先天的不足，文件越大、距离越远，其丢包、延时等问题对于传输速度的影响就越大。 Aspera使用的两种方式（1）客户端的下载与安装 &emsp;&emsp;即便Aspera是商业软件，但是作为客户应用方（相对于NCBI），我们使用其客户对进行数据的上传与下载是不用支付费用的。 &emsp;&emsp;网页下载：速度很快，不过需要把数据再上传到服务器上，多费一道工序下载网页版AsperaConnectML-3.5.2.97180.msi安装，网页上下载SRA数据时点aspera下载链接就可以。 客户端下载链接： http://downloads.asperasoft.com/connect2/ 设置下载目录及速度限制等： 至此，客户端工具准备妥当了~ （2）使用ascp下载SRA数据：ascp是Aspera Connect的命令行程序。 下载与安装（不需要root或者sudo权限）： curl -O http://download.asperasoft.com/download/sw/connect/3.6.1/aspera-connect-3.6.1.110647-linux-64.tar.gz tar zxf asper-connect-3.6.1.110647-linux.tar.gz sh aspera-connect-3.6.1.110647-linux-64.sh 添加环境变量： export PATH=&quot;/home/u641750/.aspera/connect/bin:$PATH&quot; 可以将密钥备份到/home/的家目录下方便使用（后文将用到）: $ cp ~/.aspera/connect/etc/asperaweb_id_dsa.openssh ~/ 至此，命令行工具准备妥当了~ 那么如何找到我们要下载的SRA数据呢？首先我们需要了解下NSBI的SRA数据结构的层次关系： NCBI官网说明：https://www.ncbi.nlm.nih.gov/books/NBK7522/ &emsp;&emsp;SRA数据库中的数据分为Studies, Experiments, Samples和相应的Runs四个层次。Studies有一个总体目标并可能包含数个Experiments。一个Experiments描述具体测了什么和使用的方法。它包括DNA来源信息，样本，测序平台，数据处理。每个Experiments由一个或者多个Runs组成。一个Run包含来自每个spot的reads结果。在未来，一些数据将具有相关分析。这些分析可能包括short reads组装为基因组或者转录组的contigs，现有基因组的比对，SRA数据的比对。每个水平的记录具有唯一的accession identifiers ，并且具有三个大写字母前缀： &emsp;&emsp;NCBI中SRA数据结构的层次关系： Studies: SRA Study accessions (prefixes SRP, DRP, ERP) Examples: SRP000002, DRP000617, ERP002000 BioProject accessions (prefixes PRJNA, PRJDB, PRJEB) Examples: PRJNA111397, PRJDB90, PRJEB1976 dbGaP study accessions (prefix phs) Example: phs000159 GEO Study (prefix GSE) Example: GSE12578 Samples: SRA Sample accessions (prefixes SRS, DRS, ERS) Examples: SRS000013, DRS000020, ERS000016 BioSample accessions (prefixes SAMN, SAME) Examples: SAMN00000013, SAMEA774460 GEO Sample (prefix GSM) Example: GSM769008 SRA Experiment(s) SRA Experiment accessions (prefixes SRX, DRX, ERX) Example: SRX000002,SRX000003,SRX000004 Figure 2 shows Study (SRP000095, top panel), Experiment (SRX000113, middle panel, and SRX000114), and Run (SRR000416, bottom panel) records for the 454 sequencing of James Watson’s genome by Cold Spring Harbor Laboratory. Study and Run records are displayed in the SRA browser. The corresponding Experiment records are displayed in the NCBI Entrez system as described in the next section. 在SRA浏览页面和Entrez可以搜索和查看SRA数据 Studies, Runs和它们相关的Samples可以通过SRA主页浏览和查看： www.ncbi.nlm.nih.gov/Traces/sra Experiment记录可以通过搜索 Entrez SRA数据库获得： www.ncbi.nlm.nih.gov/sites/entrez?db=sra 接下来具体介绍：搜索地址：https://www.ncbi.nlm.nih.gov/Traces/study/ （1）通过以上网址，查询得到SRA数据的SRA Experiment accessions (prefixes SRX, DRX, ERX) （2）在NCBI的SRA数据库搜索SRA Experiment accessions，例如：SRX000004，点选All runs ,下载Accession List ，使用prefetch下载(prefetch直接调用ascp，没有安装ascp之前直接用http） 点击Download data： 此时鼠标选中SRX实验或者任意一个SRR记录，通过Aspera client客户端下载。但这样需要等下载完再使用FTP上传到自己的服务器，前面提过，FTP速度很慢！！！ 那么如何在服务器使用ascp命令行工具下载呢？命令格式： ascp -i &lt;path-to-asperaweb_id_dsa.openssh&gt; -k1 -QTr –l200m anonftp@ftp-private.ncbi.nlm.nih.gov:/&lt;files to transfer&gt; &lt;local destination&gt; 相关的参数 –Q (for adaptive flow control) – needed for disk throttling! –T to disable encryption –k1 enable resume of failed transfers –l (maximum bandwidth of request, try 200M and go up from there) –r recursive copy –i &lt;密钥文件&gt; 表明下载存放路径，一定要有，缺少会报错！！！关键是如何获取，也就是你要下载的SRR数据的地址，并且一定要保证其存在，否则会报错！！！ 将鼠标选中上图任意一个SRR文件，例如SRR00006.sra,右键，复制链接地址：fasp://anonftp@ftp.ncbi.nlm.nih.gov:22/sra/sra-instant/reads/ByExp/sra/SRX/SRX000/SRX000004/SRR000006/SRR000006.sra?auth=no&amp;port=33001&amp;bwcap=300000&amp;targetrate=100p&amp;policy=fair&amp;enc=none&amp;lockpolicy=no&amp;locktargetrate=no&amp;lockminrate=no&amp;v=2 摘取/sra/sra-instant/reads/ByExp/sra/SRX/SRX000/SRX000004/SRR000006/SRR000006.sra部分即为 网上有其他教程说遵循如/sra/sra-instant/reads/ByRun/sra/SRR/SRR689/SRR689250/SRR689250.sra固定的格式，但实际并非如此，比如上面的例子，所以并不能图省事硬套上述格式，还是要再win下如上述方法找到文件具体的地址，摘取部分，以确保文件存在，否则会报错：“ascp: no remote host specified, exiting” 举个栗子： （1）单个文件下载： ascp -i ~/asperaweb_id_dsa.openssh -k1 -Tr -l100m anonftp@ftp-private.ncbi.nlm.nih.gov:/sra/sra-instant/reads/ByExp/sra/SRX/SRX000/SRX000004/SRR000006/SRR000006.sra ~ （2）批量下载： 观察发现，一个SRX Experiment accessions下的是有规律的，如win下的目录结构所示,只是后两个字段不同：/sra/sra-instant/reads/ByExp/sra/SRX/SRX000/SRX000004/SRR000006/SRR000006 因此可以整理为下面的格式黏贴在文本SRR_Download_List_file_list.txt 中： /sra/sra-instant/reads/ByExp/sra/SRX/SRX000/SRX000004/SRR000006/SRR000006.sra/sra/sra-instant/reads/ByExp/sra/SRX/SRX000/SRX000004/SRR000009/SRR000009.sra/sra/sra-instant/reads/ByExp/sra/SRX/SRX000/SRX000004/SRR000010/SRR000010.sra …….等 ascp -i ~/asperaweb_id_dsa.openssh --mode recv --host ftp-private.ncbi.nlm.nih.gov --user anonftp --file-list SRR_Download_List_file_list.txt ~ 如此可以实现批量下载！ 使用后会发现，从NCBI上下载SRA速度，一般的宽带的话，也可以达到100M/s，大大节约了下载的时间，非常给力 注意事项： （1）如果报错：Error: Server aborted session: Client requests stronger encryption than server allows，那么可以参考：https://support.asperasoft.com/hc/en-us/articles/216126788-Error-Client-requests-stronger-encryption-than-server-allows 对客户端和命令行两种方式都给出了解决方案。在linux命令行下也就是加个-T参数，即： ascp -T -i ~/asperaweb_id_dsa.openssh --mode recv --host ftp-private.ncbi.nlm.nih.gov --user anonftp --file-list SRR_Download_List_file_list.txt ./ （2）放入后台下载，这样不用担心关闭客户端，下载也停止了~ nohup ascp -T -i ~/asperaweb_id_dsa.openssh --mode recv --host ftp-private.ncbi.nlm.nih.gov --user anonftp --file-list SRR_Download_List_file_list.txt ./ &amp; （3）aspera默认不支持断点续传，要支持这个功能添加参数： ascp -k1 -T -i ~/asperaweb_id_dsa.openssh --mode recv --host ftp-private.ncbi.nlm.nih.gov --user anonftp --file-list SRR_Download_List_file_list.txt ./ 所以 ascp -i ~/asperaweb_id_dsa.openssh -k1 -Tr -l100m anonftp@ftp-private.ncbi.nlm.nih.gov:命令可以通用 （4）从EBI上下载也类似，给个例子： ascp -i ~/asperaweb_id_dsa.putty era-fasp@fasp.sra.ebi.ac.uk:/vol1/ERA012/ERA012008/sff/library08_GJ6U61T06.sff 提供Aspera的数据库： （1）NCBI的Sequence Read Archive (SRA), dbGaP. （2）1000genomes – EBI Aspera site, the NCBI Aspera site 1000genomes – EBI Aspera site: http://www.internationalgenome.org/aspera 1000genomes – the NCBI Aspera site https://www.ncbi.nlm.nih.gov/projects/faspftp/1000genomes/ sra数据转为fastaq&emsp;&emsp;sra是NCBI 推出的存储高通量数据的格式，而平常我们工作用得多是fastq格式。如果需要把sra 转成fastq，则下载NCBI SRA Toolkit。 下载地址：https://trace.ncbi.nlm.nih.gov/Traces/sra/sra.cgi?cmd=show&amp;f=software&amp;m=software&amp;s=software (1)下载安装（CentOS Linux 64 bit architecture）： curl -O https://ftp-trace.ncbi.nlm.nih.gov/sra/sdk/2.8.2-1/sratoolkit.2.8.2-1-centos_linux64.tar.gz tar xzvf sratoolkit.2.8.2-1-centos_linux64.tar.gz cd sratoolkit.2.8.2-1-centos_linux64 程序都在bin目录下，来看看有什么： cd bin SRA Toolkit Documentation, Frequently Used Tools: fastq-dump: Convert SRA data into fastq format prefetch: Allows command-line downloading of SRA, dbGaP, and ADSP data sam-dump: Convert SRA data to sam format sra-pileup: Generate pileup statistics on aligned SRA data vdb-config: Display and modify VDB configuration information vdb-decrypt: Decrypt non-SRA dbGaP data (“phenotype data”) (2)添加环境变量 echo &apos;export PATH=/home/wangdong/softwares/sratoolkit.2.8.2-centos_linux64/bin&apos;&gt;&gt;~/.bashrc source ~/.bashrc (3)使用： 使用prefetch下载SRA数据下载文件: （1）单个下载 prefetch SRR1553610 （2）批量下载 for i in $(seq 58 79);do prefetch -v SRR8287$i ;done 或者使用 prefetch --option-file sra.ids ，其中sra.ids一行一个SRR编号 （3)检查给定序列号是否可以能够下载 prefetch -c SRR390728 这些文件区哪儿了？这些文件去哪里了？存在了你home目录下的一个默认文件夹里。 ls ~/ncbi 从NCBI下下来的数据，双端测序数据是放在一个文件里的，所以需要把它们重新拆解为两个文件。注意，下载下来的这个SRA文件虽然只有一份，但是里面其实存了read1和read2的测序数据。我们用程序fastq-dump来把文件拆包 fastq-dump --split-files SRR1553610 那么我怎么知道哪些数据是双端测序的呢？上文的网址关于NSBI的SRA数据结构的Study层次对实验方法有具体介绍：网址再贴一遍：https://www.ncbi.nlm.nih.gov/Traces/study/ 小细节之拆包后文件的命名： File name Description SRR030257_1.fastq Paired-end Illumina, First of pair, FASTQ format SRR030257_2.fastq Paired-end Illumina, Second of pair, FASTQ format 因为在后续分析，mapping到RefSeq上时，单端测序和双端测序命令有些不同！需要注意下。 更多的说明,请参见官方的SRA下载手册: NCBI: https://www.ncbi.nlm.nih.gov/books/NBK242625/ EBI: http://www.ebi.ac.uk/ena/about/sra_data_download FTP下载方式：使用Xftp5 匿名登录FTP站点即可下载资源，慢点就慢点吧~有时需要下载的文件也就1-2M 三大数据库的FTP地址： ensembl : ftp://ftp.ensembl.org/pub NCBI : ftp://ftp.ncbi.nih.gov/genomes/ UCSC：ftp://hgdownload.soe.ucsc.edu/goldenPath 补充：使用SRA Run Selector下载网址：https://www.ncbi.nlm.nih.gov/Traces/study/帮助（步骤很详细了）：https://www.ncbi.nlm.nih.gov/Traces/study/?go=help 参考：（1）博耘生物： http://boyun.sh.cn/bio/?p=1933 （2）Keep Learning的博客 http://blog.csdn.net/xubo245/article/details/50513201 （3）郑俊娟的博客： http://blog.sciencenet.cn/blog-1271266-775638.html （4）鳉鲈的博客： http://blog.sina.com.cn/s/blog_71df25810102w2vf.html （5）生信笔记的博客： http://www.bioinfo-scrounger.com/ （6）Rethink的博客 http://blog.leanote.com/post/hwoihann/how-to-download-series-of-sra-data-in-one-command]]></content>
      <categories>
        <category>NGS软件</category>
      </categories>
      <tags>
        <tag>NGS软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何优雅的输出python字典]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F08%2F05%2F%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%BE%93%E5%87%BApython%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[如何优雅的输出python字典&emsp;&emsp;python中的字典是一种清晰的数据结构，生信学习过程中有很多统计的事儿。比如有10个样本，Variant calling 分析后需要根据每个样本，统计每种变异类型并绘图。此时就可以用到python的嵌套字典或者嵌套列表。 &emsp;&emsp;python中的字典是一种清晰的数据结构，生信学习过程中有很多统计的事儿。比如有10个样本，Variant calling 分析后需要根据每个样本，统计每种变异类型并绘图。此时就可以用到python的嵌套字典或者嵌套列表。 （1）一层字典1gene_symbol_ENGS=&#123;'PKHD1': 'ENSG00000170927', 'ATP6V0A4': 'ENSG00000105929', 'TSC2': 'ENSG00000103197'&#125; 123456789from pandas import Seriesframe1 = Series(gene_symbol_ENGS)print(frame1) ATP6V0A4 ENSG00000105929 PKHD1 ENSG00000170927 TSC2 ENSG00000103197 dtype: object （2）嵌套字典1sample_mutation_count = &#123;'PDC668_vs_PDC668A2': &#123;'ncRNA_intronic': 32, 'UTR5': 6, 'ncRNA_splicing': 0, 'exonic;splicing': 0, 'UTR3': 6, 'upstream;downstream': 1, 'downstream': 6, 'exonic': 155, 'upstream': 2, 'splicing': 1, 'ncRNA_exonic': 19, 'intergenic': 162, 'intronic': 162&#125;, 'PDC3748_vs_PDC3748B4': &#123;'ncRNA_intronic': 21, 'UTR5': 6, 'ncRNA_splicing': 0, 'exonic;splicing': 0, 'UTR3': 2, 'upstream;downstream': 0, 'downstream': 2, 'exonic': 123, 'upstream': 8, 'splicing': 2, 'ncRNA_exonic': 15, 'intergenic': 122, 'intronic': 130&#125;&#125; 1234567891011121314151617181920212223242526from pandas import DataFrameframe2 = DataFrame(sample_mutation_count)print(frame2) PDC3748_vs_PDC3748B4 PDC668_vs_PDC668A2 UTR3 2 6 UTR5 6 6 downstream 2 6 exonic 123 155 exonic;splicing 0 0 intergenic 122 162 intronic 130 162 ncRNA_exonic 15 19 ncRNA_intronic 21 32 ncRNA_splicing 0 0 splicing 2 1 upstream 8 2 upstream;downstream 0 1``` 那么问题来了，当每个样本的行不完全一样时如何解决呢，```pythonlen_exon = &#123;'ENSG00000008710': &#123;'ENST00000570193': 591, 'ENST00000483558': 573&#125;,'ENSG00000089597': &#123;'ENST00000526210': 529, 'ENST00000526392': 255, 'ENST00000532402': 3695&#125;&#125; 12345678910111213141516171819202122232425from pandas import Seriesfor key,value in len_exon.items(): print(key) print(Series(value)) ENSG00000008710 ENST00000483558 573 ENST00000570193 591 dtype: int64 ENSG00000089597 ENST00000526210 529 ENST00000526392 255 ENST00000532402 3695 dtype: int64``` ## 当然，也可以使用pprint输出字典结构，看着还行，但不利于后续R绘图```pythonimport pprintresultFile = open('result.py', 'w')resultFile.write(pprint.pformat(len_exon))resultFile.close() 1234&#123;'ENSG00000008710': &#123;'ENST00000483558': 573, 'ENST00000570193': 591&#125;, 'ENSG00000089597': &#123;'ENST00000526210': 529, 'ENST00000526392': 255, 'ENST00000532402': 3695&#125;&#125;]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[picard]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F08%2F03%2Fpicard%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;picard 是用java开发的用于处理高通量测序数据和格式转换（SAM/BAM/CRAM和VCF）的命令行工具集 #Picard 高通量测序数据处理及格式转换工具大合集 picard 是用java开发的用于处理高通量测序数据和格式转换（SAM/BAM/CRAM和VCF）的命令行工具集 其官网为：http://broadinstitute.github.io/picard/ 先看看picard都有哪些工具集： Available Programs:Alpha Tools: 目前无支持，需要进一步测试完善的工具集 CollectIndependentReplicateMetrics 预测bam文件中reads的独立重复率 CollectWgsMetricsWithNonZeroCoverage 收集关于全基因组（WGS）测序的覆盖度和测序质量信息 UmiAwareMarkDuplicatesWithMateCigar 利用read的位置和UMIs信息鉴定重复的reads Fasta: 操作FASTAor相关数据工具集 CreateSequenceDictionary 创建参考序列的序列字典 ExtractSequences 从参考序列中创建子区间存为新的FASTA NonNFastaSize 对fasta文件中non-N碱基计数 NormalizeFasta 规范FASTA文件中的序列行为相同长度 Fingerprinting Tools: 操作印迹图谱工具集 CheckFingerprint 计算来自提供的(SAM/BAM or VCF) 文件的指纹图谱，并与提供的基因型比较 ClusterCrosscheckMetrics 通过LOD得分对CrosscheckFingerprints的结果进行聚类 CrosscheckFingerprints 检查是否所有的指纹图谱来自相同的个体 CrosscheckReadGroupFingerprints 弃用：使用CrosscheckFingerprints.检查是否所有的指纹图谱来自相同的个体 Illumina Tools: 操作具体Illumina测序数据工具集 CheckIlluminaDirectory 维护具体的Illumina basecalling数据的有效性 CollectIlluminaBasecallingMetrics 从一次测序运行中收集Illumina Basecalling矩阵 CollectIlluminaLaneMetrics 对于每个给定的BaseCalling分析路径收集Illumina lane矩阵 ExtractIlluminaBarcodes 确定Illumina lane中每个read的barcode IlluminaBasecallsToFastq 从Illumina basecall read数据中产生ASTQ 文件 IlluminaBasecallsToSam 转换原始的Illumina测序数据为unmapped 的SAM或者BAM 文件. MarkIlluminaAdapters 读SAM或者BAM 文件并用新的接头修饰标签重写 Interval Tools: 操作Picard区间列表工具集 BedToIntervalList 转换BED 文件为Picard区间列表 IntervalListToBed 转换Picard的IntervalList文件为BED文件. IntervalListTools 操作区间列表 LiftOverIntervalList 从一个参考转为另一个时去除区间列表 ScatterIntervalsByNs 通过Ns分割参考，写入区间列表 Metrics: 各种不同数据类型报表矩阵工具集 AccumulateVariantCallingMetrics 组合多个变异Calling矩阵为单个文件 CollectAlignmentSummaryMetrics &lt;b&gt;从SAM或BAM文件产生比对矩阵总结 &lt;/b&gt; CollectBaseDistributionByCycle 对SAM或BAM文件中每个循环核苷酸分布制表 CollectGcBiasMetrics 收集关于GC bias的矩阵 CollectHiSeqXPfFailMetrics 将HiSeqX Illumina Basecalling directory下的PF-Failing reads归类为不同类别 CollectHsMetrics 从SAM或BAM文件收集杂交选择（HS）矩阵 CollectInsertSizeMetrics 从配对末端文库中收集插入片段分布矩阵 CollectJumpingLibraryMetrics 收集跳跃文库矩阵 CollectMultipleMetrics 收集多类矩阵 CollectOxoGMetrics 收集矩阵评估氧化产物 CollectQualityYieldMetrics 收集关于通过质控阈值和 Illumina-specific过滤的reads矩阵 CollectRawWgsMetrics 收集全基因组测序相关矩阵 CollectRnaSeqMetrics 从SAM或BAM文件中产生RNA比对矩阵 CollectRrbsMetrics &lt;b&gt;从简化的亚硫酸氢盐测序(Rrbs)数据收集矩阵&lt;/b&gt; CollectSequencingArtifactMetrics 收集量化单末端测序产品的矩阵 CollectTargetedPcrMetrics 从目标测序数据中收集PCR相关矩阵 CollectVariantCallingMetrics 从提供的VCF文件文件中收集每个样本和包含所有样本集合的矩阵 CollectWgsMetrics 收集关于全基因组测序（WGS）实验的覆盖度和质量矩阵 CompareMetrics 比较两个矩阵文件 ConvertSequencingArtifactToOxoG 从广义的人工矩阵提取OxoG矩阵 EstimateLibraryComplexity 预测测序文库中特异性分子数量 MeanQualityByCycle 通过循环收集均值质量 QualityScoreDistribution 为质量得分的分布绘制表格 Miscellaneous Tools: 混杂工具集 BaitDesigner 为杂交选择反应设计寡核苷酸baits FifoBuffer FIFO buffer 用来缓冲具有可定制缓冲大小的输入和输出流 SAM/BAM: 操作SAM, BAMor者相关数据的工具集 AddCommentsToBam 为headerBAM 文件的header增加评论 AddOrReplaceReadGroups 替代BAM 文件的read groups BamIndexStats 从BAM 文件产生索引统计 BamToBfq 通过maq aligner从BAM文件产生BFQ文件s BuildBamIndex 生成BAM索引，&quot;.bai&quot; 文件 CalculateReadGroupChecksum 基于read groups(RG)产生哈希码 CheckTerminatorBlock 维护提供的gzip 文件(e.g., BAM)最后一个区块格式正确; 否则RC 100 CleanSam 清除提供的SAM/BAM，soft-clipping beyond-end-of-reference alignments并且对于未比对上的reads设置MAPQ为0 CompareSAMs 比较两个输入的&quot;.sam&quot; or &quot;.bam&quot; 文件 DownsampleSam 对SAM或BAM文件缩小取样 FastqToSam 转换FASTQ文件为unaligned的BAM或SAM文件 FilterSamReads 从SAM或BAM文件取read数据子集 FixMateInformation 如果需要，在mates和fix之间确认mate-pair信息 GatherBamFiles 尽可能高效的连接一个或多个BAM文件 MarkDuplicates 鉴定重复的reads MarkDuplicatesWithMateCigar 鉴定重复的reads,解释mate CIGAR. MergeBamAlignment 从SAM或者BAM文件中合并alignment数据到unmapped BAM文件 MergeSamFiles 合并多个SAM和/或BAM 文件为单个文件 PositionBasedDownsampleSam 缩小SAM或者BAM文件取样来维持reads子集，基于reads在每个flowcell的每个tile的位置 ReorderSam 对SAM或者BAM文件中的reads重排序，来匹配参考文件中的顺序 ReplaceSamHeader 替代SAM或BAM文件的SAMFileHeader RevertOriginalBaseQualitiesAndAddMateCigar 转换原始碱基质量并增加mate cigar到read-group BAMs RevertSam 转换SAM或BAM 文件回到之前状态 SamFormatConverter BAM文件与SAM 文件互相转换 SamToFastq 转换SAM或者BAM文件为FASTQ文件 SetNmAndUqTags 弃用：使用SetNmMdAndUqTags代替 SetNmMdAndUqTags 修改SAM文件中NM,MD和UQ标签 SortSam 对一个SAM或BAM文件排序 SplitSamByLibrary 通过文库分割SAM或BAM文件为独立文件 ValidateSamFile 确认SAM或BAM文件 ViewSam 打印SAM或BAM文件到屏幕 Unit Testing: 测试单元 SimpleMarkDuplicatesWithMateCigar 测试提供的SAM或BAM文件中比对上的记录来定位重复分子 VCF/BCF: 操作VCF, BCFor者相关数据的工具集 FilterVcf 严格过滤VCF FindMendelianViolations 在VCF文件中寻找所有违反孟德尔法则的类型 FixVcfHeader 代替或者修改VCF header GatherVcfs 文件从一个分散的多个VCF文件产生单个VCF文件 GenotypeConcordance 评估callsets之间的基因型一致性 LiftoverVcf 从一个引用构建另一个引用时留下一个VCF文件 MakeSitesOnlyVcf 从VCF或BCF文件创建没有基因型信息的VCF文件 MergeVcfs 合并多个VCF或者BCF文件为一个VCF文件或者BCF文件 RenameSampleInVcf 对VCF或BCF中样本重命名 SortVcf 对一个或多个VCF 文件排序 SplitVcfs 分割SNPs和INDELs为独立的文件 UpdateVcfSequenceDictionary 对于VCF文件和包含有序列字典的文件，利用新的序列字典更新VCF文件 VcfFormatConverter VCF与BCF互相转换 VcfToIntervalList 转换VCF or BCF 文件为Picard区间列表 （1）接下来看看如何安装： #查看Java版本 java -version Java 1.8及以后版本即OK #从github拷贝库 git clone https://github.com/broadinstitute/picard.git #进入picard文件目录 cd picard/ #编译 ./gradlew shadowJar 此时，在build/libs/文件夹下可见picard.jar程序 #运行 java -jar build/libs/picard.jar （2）如何设置环境变量： vim ~/.bashrc i PICARD=&apos;/home/u631758/biosoftwares/picard/build/libs/picard.jar&apos; alias picard=&quot;java -jar $PICARD&quot; 如此就可以用picard命名代替官网中的java -jar picard.jar命令了！！！ （3）查看有哪些可用的工具： picard （4）查看某个工具的具体用法： 例如VcfFormatConverter工具： picard VcfFormatConverter -h 结果为： java -jar picard.jar VcfFormatConverter \ I=input.vcf \ O=output.bcf \ 所以使用方式为： picard VcfFormatConverter I=input.vcf O=output.bcf]]></content>
      <categories>
        <category>NGS软件</category>
      </categories>
      <tags>
        <tag>NGS软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux中python2和python3环境搭建及共存]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F08%2F03%2Fpython%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本教程将展示如何在CentOS上通过源码编辑安装最新的Python 2 和 Python 3。以下例子使用Python 2.7.13 and Python 3.6.2，但是操作流程对于其他新版python都是相同的。 linux中python2和python3环境搭建及共存&emsp;&emsp;如果你使用的是CentOS 6，你可以使用本教程安装 Python 2.7.x and Python 3.6.x。对于CentOS 7 只有Python 3.6.x的安装方法是适用的。警告！不要在CentOS 7上使用本教程安装Python 2.7.13。这样你的系统将有两个不同的python2.7二进制文件，每个具有自己的安装包路径。这将可能造成不能区分的问题！ 查看linux系统版本信息：lsb_release -a 注: 这个命令适用于所有的linux，包括Redhat、SuSE、Debian等发行版 问题所在？&emsp;&emsp;CentOS携带Python作为基础系统的一个重要部分。因为其十分重要，所以未及时更新，或者为了避免安全漏洞。缺少更新，意味着CentOS 6用户无法摆脱2010年8月发布的Python 2.6.6，CentOS 7用户无法摆脱2013年发布的Python 2.7.5。 通常/usr/bin下面的都是系统预装的可执行程序，会随着系统升级而改变 cd /usr/bin ls |grep ^p 只安装了python2.6 YUM&emsp;&emsp;YUM（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，避免了手动安装的麻烦(寻找资源、下载；放到指定目录安装；处理依赖关系并下载依赖关系的包进行安装)。所以用yum安装，实质上是用RPM安装，所以RPM查询信息的指令都可用。 如果使用RPM安装了一些包，一般来说，RPM默认安装路径如下： Directory Contents of Directory /usr/bin 一些可执行文件 /usr/lib 一些程序使用的动态函数库 /usr/share/doc 一些基本的软件使用手册与帮助文档 /usr/share/man 一些man page文件所以没有root权限，是没有办法通过yum进行软件安装的 需要考虑的事项：使用 “make altinstall” 来避免麻烦 &emsp;&emsp;当安装定制版的Python时使用make altinstall时十分重要的。如果使用常规的make install的结局是安装不同的python版本，但出现在文件系统中却出现同为python的程序,这将导致很难辨别的麻烦。 &emsp;&emsp;编译安装的准备 为了编译Python之前最好先安装一系列的开发工具和一些拓展库，但不是必须的，但这样Python才能依赖这些工具和拓展库展示它强悍的功能。 (1)下载并编译安装pythonPython 2.7.13: wget http://python.org/ftp/python/2.7.13/Python-2.7.13.tar.xz tar xf Python-2.7.13.tar.xz cd Python-2.7.13 ./configure --prefix=/home/wangdong/python/python27 make &amp;&amp; make altinstall Python 3.6.2: wget http://python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz tar xf Python-3.6.2.tar.xz cd Python-3.6.2 ./configure --prefix=/home/wangdong/python/python36 make &amp;&amp; make altinstall (2)设置环境变量echo &apos;export PATH=/home/wangdong/python/python36/bin:$PATH&apos;&gt;&gt;~/.bashrc echo &apos;export PATH=/home/wangdong/python/python27/bin:$PATH&apos;&gt;&gt;~/.bashrc &emsp;&emsp;注意使用python3.6, 使用python仍旧为系统预装的python版本，以后使用Python解释器时,同样需要注意使用python和python3.6调用的Python解释器是不同的！！ linux添加环境环境变量注意事项： （1）=号左右两边没有空格 （2）路径之间用：分隔 （3）$PATH 表示原先设定的路径仍然有效，注意不要漏掉 （4）需要引号,因为用echo命令输出加引号的字符串时，将字符串原样输出 (3) 安装/升级pip,setuotools和wheel 安装pip,setuotools和wheel系统中的每个Python解释器都需要自己的pip,setuotools和wheel,安装和升级这些包最简单的方式是使用get-pip.py脚本。 First get the script: wget https://bootstrap.pypa.io/get-pip.py Then execute it using Python 2.7 and/or Python 3.6: python2.7 get-pip.py python3.6 get-pip.py PYTHONPATH是Python搜索路径，默认我们import的模块都会从PYTHONPATH里面寻找 echo &apos;export PYTHONPATH=/home/wangdong/python/python36/lib/python3.6/site-packages&apos;&gt;&gt;~/.bashrc echo &apos;export PYTHONPATH=/home/wangdong/python/python27/lib/python2.7/site-packages&apos;&gt;&gt;~/.bashrc source ~/.bashrc With pip installed you can now do things like this: pip2.7 install [packagename] pip2.7 install –upgrade [packagename] pip2.7 uninstall [packagename] pip3.6 install [packagename] pip3.6 install –upgrade [packagename] pip3.6 uninstall [packagename] &emsp;&emsp;注意使用pip2.7和pip3.6安装软件不同点在于，安装文件的路径不同。pip2.7的安装路径是/home/wangdong/python/python27/lib/python2.7/site-packages，而pip3.6的安装路径是/home/wangdong/python/python36/lib/python3.6/site-packages ###（4）虚拟环境的使用 &emsp;&emsp;如果你使用Python2.7，则强烈推荐使用安装virtualenv并且学习使用它。virtualenv可以创建独立的Python环境。如果你使用Python3.3+，那么你没有必要安装virtualenv，因为其功能已经内建了。 每个独立的Python环境（又叫sandbox）能具有自己的Python版本和包。这对于多项目或者相同项目需要不同的版本的场合是十分重要的。 先看看virtualenv中文教程： http://virtualenv-chinese-docs.readthedocs.io/en/latest/#id29 Install virtualenv for Python 2.7 and create a sandbox called my27project: pip2.7 install virtualenv virtualenv my27project Use the built-in functionality in Python 3.6 to create a sandbox called my36project: python3.6 -m venv my36project (1)Check the system Python interpreter version: python --version This will show Python 2.6.6 Activate the my27project sandbox: source my27project/bin/activate (2)Check the Python version in the sandbox (it should be Python 2.7.13): python --version This will show Python 2.7.13 Deactivate the sandbox: deactivate Activate the my36project sandbox: source my36project/bin/activate (3)Check the Python version in the sandbox (it should be Python 3.6.2): python --version This will show Python 3.6.2 Deactivate the sandbox: deactivate 小结：(1) 从（1）和（2）或者（1）和（3）的对比看出：创建虚拟环境并激活后，虚拟环境的环境变量和系统的环境变量是隔离的，互不影响。 (2) 创建的虚拟环境的Python解释器版本是如何指定的呢？先看看virtualenv用法: $ virtualenv [OPTIONS] DEST_DIR其中一个选项-p PYTHON_EXE, –python=PYTHON_EXE &emsp;&emsp;指定所用的python解析器的版本，比如 –python=python2.5 就使用2.5版本的解析器创建新的隔离环境。 默认使用的是当前目录下安装(/home/wangdong/python/python36/bin/python3.6或者/home/wangdong/python/python27/bin/python2.7)的python解析器 所以可以在python27下使用-p指定python3.6解释器创建虚拟环境： 反过来，对于Python3.3+ 通过venv模块创建指定python2.7虚拟环境则不行了！ 首先看看venv模块官方文档： https://docs.python.org/3/library/venv.html 需要注意的是，在Python3.3中使用”venv”命令创建的环境不包含”pip”，你需要进行手动安装。在Python3.4中改进了这一个缺陷。 并没有相关参数！！ 所以类似的可以使用virtualenv解决： 在python36目录下： virtualenv my27project_test source my27project_test/bin/activate python This will show Python 2.7.13 在python36目录下： virtualenv -p /home/wangdong/python/python36/bin/python3.6 my36proje_test source my36project_test/bin/activate python This will show Python 3.6.2 （3）在对应虚拟环境下使用对应pip安装软件：例如： source my36project/bin/activate pip3.6 install numpy &emsp;&emsp;安装路径为： ./my36project/lib/python3.6/site-packages **所以安装包也和系统是完全隔离的，二者互不影响。因此虚拟环境不再使用时，直接删除该虚拟环境即可。 rm -rf my36project 在my27project下则使用pip2.7,其他类似。 ####（4）接下来讲讲pip使用 使用清华的pip源安装包更快： pip3.6 install -i https://pypi.tuna.tsinghua.edu.cn/simple bcbio-gff biopython cython nose numpy pandas shove sqlalchemy python-memcached pyvcf (不同安装包之间使用空格即可) 指定安装包的版本,例如： pip3.6 install pysam==0.7.5 卸载指定版本安装包，例如： pip3.6 uninstall biopython==1.70 把常用的包离线下载，然后使用pip离线安装包，例如： pip3.6 install pysam-0.7.5.tar.gz 查看当前环境pip已安装包列表： pip3.6 list 导出包列表，批量安装python2.7 -m pip freeze &gt;python2.7_pip_requirements.txt 或者 python3.6 -m pip freeze &gt;python3.6_pip_requirements.txt python2.7 -m pip install -r python2.7_pip_requirements 参考： https://danieleriksson.net/2017/02/08/how-to-install-latest-python-on-centos/]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[添加PATH环境变量及设置别名]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F08%2F02%2F%E6%B7%BB%E5%8A%A0PATH%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%8F%8A%E8%AE%BE%E7%BD%AE%E5%88%AB%E5%90%8D%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Linux下想让某个命令可以全局使用，可以有两种方法来实现，具体请看下文！ 想让某个命令可以全局使用，可以有两种方法来实现：方法一.在命令行将路径添加到 .bashrc文件echo &apos;export PATH=~/home/biosoftwares/FastQC/bin/fastqc:$PATH&apos; &gt;&gt;~/.bashrc source ~/.bashrc 注意： （1）注意添加的路径是可执行文件的绝对路径，一般在bin下，可执行文件为绿色 （2）用echo命令输出加引号的字符串时，将字符串原样输出 （3）export可新增，修改或删除环境变量，供后续执行的程序使用。export的效力仅及于该次登陆操作 （4）&gt;&gt;以追加方式添加 （5） ~/.bashrc表示家目录下的.bashrc文件，为隐藏文件，使用ls -a可以查看 （6）使用source ~/.bashrc之前需要先回到家目录 （7）Source命令也称为“点命令”，也就是一个点符号（.）。source命令通常用于重新执行刚修改的 初始化文件，使之立即生效，而不必注销并重新登录。用法：source filename 或 . filename 也可以在用vim打开~/.bashrc文件直接添加 vim ~/.bashrc i PATH=~/home/biosoftwares/FastQC/bin/fastqc Esc :x 注意： （1）i 进入vim编辑模式 （2）Esc退出vim编辑模式 （3）:x保存修改并退出（需要在英文输入法状态下） 方法二. 将目录添加到~/.bashrc 文件，比如~/bin，然后创建软连接（相当于win下的快捷方式）#创建~/bin目录 mkdir -p ~/bin #将~/bin目录添加到PATH echo &apos;export PATH=~/bin:$PATH&apos;&gt;&gt;~/.bashrc #使修改生效 source ~/.bashrc #在/bin下生成fastqc软连接 ln -s ~/src/fastQC/fastqc ~/bin/fastqc 设置命令别名alias ll=’ls -l’ #在当前的Shell生效 echo “alias ll=’ls -l’” &gt;&gt;~/.bashrc #永久生效source ~/.bashrc 其他常用别名举例： （1）alias ll=’ls -l –color=tty’ #按系统预定义的颜色区分不同的文件类型 （2）alias la=’ls -a’ #显示隐藏文件 （3）alias rmall=’rm -rf’ #显示隐藏文件 （4）alias less=’less -S’ #根据屏幕大小显示,且列对齐 （5）解压命令 *.tar 用 tar -xvf 解压，echo “alias untar=’tar -xvf’” &gt;&gt;~/.bashrc *.gz 用 gzip -d或者gunzip 解压, echo “alias ungz=’gunzip’” &gt;&gt;~/.bashrc .tar.gz和.tgz 用 tar -xzf 解压, echo “alias untargz=’tar -xzf’” &gt;&gt;~/.bashrc *.bz2 用 bzip2 -d或者用bunzip2 解压, echo “alias unbz2=’bunzip2’” &gt;&gt;~/.bashrc *.tar.bz2用tar -xjf 解压, echo “alias untarbz2z=’tar -xjf’” &gt;&gt;~/.bashrc *.Z 用 uncompress 解压, echo “alias unZ=’uncompress’” &gt;&gt;~/.bashrc *.tar.Z 用tar -xZf 解压, echo “alias untarZ=’tar -xZf’” &gt;&gt;~/.bashrc *.rar 用 unrar e解压, echo “alias unrar=’unrar e’” &gt;&gt;~/.bashrc *.zip 用 unzip 解压 *.tar.xz 用 $xz -d *.tar.xz $tar -xvf *.tar *.tgz 用tar zxvf 解压, echo “alias untgz=’tar zxvf’” &gt;&gt;~/.bashrc (5)列出目前所有的别名设置。 alias 或 alias -p 注意： （1）mkdir -p 表示创建多级目录 （2）ln是link的缩写，-s选项创建软连接 创建软连接格式： ln/link SOURCE [TARGET] 创建软链接： ln/link -s SOURCE [TARGET] 软连接不占用磁盘空间，硬链接相当于拷贝，占磁盘空间 如下图，-&gt;带有这个符号的则为软连接,initrd.img为软连接的文件名，而-&gt;后面跟着的boot/initrd.img-3.13.0-32-geberic则为这个软连接文件的真实路径 参考（1）我使用过的Linux命令之alias - 设置命令的别名，让 Linux 命令更简练]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改host文件-科学上网]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F08%2F02%2F%E4%BF%AE%E6%94%B9host%E6%96%87%E4%BB%B6-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[Hosts文件是Windows系统中一个负责IP地址与域名快递解析的文件，以ASCLL格式保存。计算机在键入域名的时候，首先会去看看hosts文件汇总有没有关于此域名IP地址的记录。如果有，就直接登陆该网站；如果没有再查询DNS服务器。 那么，为什么修改HOSTS文件可以实现翻墙呢？ 无论你上网打的什么网站地址, 实际上最终总归是要转换成一个IP地址才能访问的,平时这个转换工作是有网络上的DNS服务器来完成的。但是有些时候,有些网站, 处于某些原因, 网络上的DNS服务器无法给出正确的或可用IP地址(天朝特别多, 大家懂的)。 这个时候hosts文件就可以代劳了, 你可以直接用记事本打开这文件看看就知道了, 里面一行就是一条记录, 一个IP地址接一个空格或tab, 再后面就是一个网址。它起到的作用就是直接在你本机上就把这些网址翻译成IP地址. 从Windows 2000开始，Windows解析名称的顺序为：DNS cache –&gt; hosts 文件 –&gt; DNS Server –&gt; NetBIOS cache –&gt; WINS Server –&gt; 广播 –&gt; LMHOSTS 文件hosts 文件的优先级高于 DNS Server，因此修改hosts文件可以跳过被污染的dns服务器。 Hosts文件格式是咋样的？ 用记事本打开hosts文件，它的作用是包含IP地址和Host name(主机名)的映射关系，是一个映射IP地址和Hostname(主机名)的规定，规定要求每段只能包括一个映射关系，IP地址要放在每段的最前面，空格后再写上映射的Host name(主机名)。对于这段的映射说明用“#”分割后用文字说明。 为啥还需要及时更新Hosts文件？ Hosts文件配置的映射是静态的，如果网络上的计算机更改了请及时更新IP地址，否则将不能访问。 该Git项目持续更新可用的Hosts文件： https://github.com/racaljk/hosts 如何修改Hosts文件实现翻墙呢？ （1）. 从上述Git项目中复制hosts文件内容至txt文件，命名为HOSTS, 并去掉扩展名！！！ Win7 系统HOSTS文件位于 C:\Windows\System32\drivers\etc\hosts，没有拓展名。 （2）. 使之生效 Windows 开始 -&gt; 运行 -&gt; 输入cmd -&gt; 在CMD窗口输入 ipconfig /flushdns （3）使用谷歌浏览器随意登陆Google、Gmail、维基百科、Twitter、Facebook等，但必须使用https加密方式打开 谷歌香港：https://www.google.com.hk 谷歌：https://www.google.com/ncr PS: www.google.com/ncr中的”/ncr”是什么意思?起什么作用的? ncr : no country redirect If google thinks you are from a foreign country or region,it likes to redirect you to your regional google page.For most people,this makes sense.However,if you prefer the generic,english,plain version,this would be very annoying. 参考： 老D博客（很多黑科技~）：https://laod.cn/hosts/2017-google-hosts.html http://blog.sina.com.cn/s/blog_9caf88850102xnlb.html 用亚马逊的AWS来搭梯子]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生命在于折腾之Github+HEXO搭建博客]]></title>
    <url>https%3A%2F%2F%2FAnJingwd.github.io%2F2017%2F08%2F02%2F%E7%94%9F%E5%91%BD%E5%9C%A8%E4%BA%8E%E6%8A%98%E8%85%BE%E4%B9%8BGithub-HEXO%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;生命在于折腾之Github+HEXO搭建博客 &emsp;&emsp;花了近四个小时，总算还是成功了~现在的心情是这样的： 开心之余，将我的经验和踩过的坑分享给大家~ 首先推荐下参考的博客，基本是对的，实在大赞。（1）Never_yu’s的博客： https://neveryu.github.io/2016/09/03/hexo-next-one/ （2）金石开的博客 http://www.cnblogs.com/zhcncn/p/4097881.html 建议主要根据上面两个博客的方法搭建，遇到问题看看这些填坑博客~（1）文青程序猿的博客： http://www.jianshu.com/p/31eb84182156 （2）WebEnh的博客 http://www.cnblogs.com/webenh/p/5792632.html 我的安装过程还算顺利，遇到的问题：(1)安装nvm后node -v报错，表明环境变量问题：解决： ivanyb的简书文章 http://www.jianshu.com/p/07c3456e875a 孙群的博客 http://blog.csdn.net/iispring/article/details/8023319/ （2）使用npm install -g hexo-cli命令安装Hexo，很卡，最后还报错，查了查，说因为npm被墙了。 所以首先更改了淘宝的源： nvm node_mirror https://npm.taobao.org/mirrors/node/ nvm npm_mirror https://npm.taobao.org/mirrors/npm/ 参考：https://github.com/coreybutler/nvm-windows 问题依旧！！！ 查了下报错：npm ERR! 参考：http://blog.csdn.net/weng423811758/article/details/51537594 因为我开了全局VPN,但依然没解决。 淘宝说用cnpm代替npm： 参考：https://npm.taobao.org/ 然并卵！！ 最后，查看node官网，后来看看其官网，推荐使用v6.11.2LTS，改为v6.11.2LTS之后就解决了（ps:开始是使用的node的最新的v8.2.1版本） （3）部署时报错error deployer not found:git 解决：http://www.jianshu.com/p/4d2c07a330da 我的deploy配置 deploy: type: git repository: https://github.com/AnJingwd/AnJingwd.github.io.git branch: master 然后就成功了！！！ 我的博客：https://anjingwd.github.io/ Hexo 博客的访问速度相关配置优化（推荐） 未完待续~ 博客将继续完善]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
</search>
